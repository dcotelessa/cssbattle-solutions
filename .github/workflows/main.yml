name: Create or Update Solutions File for Daily CSSBattle
on:
  issues:
    types: [opened]
  workflow_dispatch:
    inputs:
      date:
        description: 'Target date (e.g., Jun 8, 2025)'
        required: true
        type: string
      css_content:
        description: 'CSS Solution(s) - separate multiple versions with ---VERSION---'
        required: true
        type: string
      additional_notes:
        description: 'Additional notes for LinkedIn post (optional)'
        required: false
        type: string
      operation_type:
        description: 'Operation type'
        required: true
        type: choice
        options:
          - create
          - update

permissions:
  contents: write
  issues: write
  
jobs:
  process-solutions-file:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || contains(github.event.issue.title, '[CSSBattle]') || contains(github.event.issue.title, '[CSSBattle-UPDATE]')
    
    env:
      GIT_USER_EMAIL: ${{ secrets.GIT_USER_EMAIL }}
      GIT_USER_NAME: ${{ secrets.GIT_USER_NAME }}
    
    steps:
      - name: Debug trigger conditions
        run: |
          echo "ðŸ” DEBUG: Trigger Analysis"
          echo "Event name: ${{ github.event_name }}"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "Manual trigger detected"
            echo "Date: ${{ github.event.inputs.date }}"
            echo "Operation: ${{ github.event.inputs.operation_type }}"
          else
            echo "Issue title: '${{ github.event.issue.title }}'"
            echo "Issue number: ${{ github.event.issue.number }}"
            echo "Issue author: ${{ github.event.issue.user.login }}"
          fi
          echo "Repository: ${{ github.repository }}"
          echo ""
          
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
      
      - name: Determine operation type
        id: operation
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "type=${{ github.event.inputs.operation_type }}" >> $GITHUB_OUTPUT
            echo "Operation (manual): ${{ github.event.inputs.operation_type }}"
          elif [[ "${{ github.event.issue.title }}" == *"[CSSBattle-UPDATE]"* ]]; then
            echo "type=update" >> $GITHUB_OUTPUT
            echo "Operation (issue): UPDATE"
          else
            echo "type=create" >> $GITHUB_OUTPUT
            echo "Operation (issue): CREATE"
          fi
      
      - name: Extract and validate issue data
        id: extract
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "ðŸŽ¯ Manual workflow - using provided inputs"
            
            # Use manual inputs
            DATE="${{ github.event.inputs.date }}"
            echo "parsed_date=$DATE" >> $GITHUB_OUTPUT
            echo "DEBUG: Using manual date: '$DATE'"
            
            # Create CSS content file from manual input
            cat > css_content.txt << EOF
${{ github.event.inputs.css_content }}
EOF
            
            echo "DEBUG: CSS content from manual input:"
            cat css_content.txt
            
          else
            echo "ðŸ“‹ Issue workflow - extracting from issue body"
            
            # Save issue body to file for processing
            cat > issue_body.txt << EOF
${{ github.event.issue.body }}
EOF
            
            echo "DEBUG: Issue body content:"
            cat issue_body.txt
            echo "DEBUG: ===== END OF ISSUE BODY ====="
            
            # Validate issue body is not empty
            if [ ! -s issue_body.txt ]; then
              echo "ERROR: Issue body is empty"
              exit 1
            fi
            
            # Extract date based on operation type
            if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
              echo "DEBUG: Extracting date for CREATE operation"
              
              # Method 1: Look for date pattern directly (for "Jun 8, 2025" format)
              DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
              
              # Method 2: If not found, look for numeric date formats
              if [ -z "$DATE" ]; then
                DATE=$(grep -oE "[0-9]{1,2}/[0-9]{1,2}/[0-9]{4}" issue_body.txt | head -1)
              fi
              
              # Method 3: Look for ISO format dates
              if [ -z "$DATE" ]; then
                DATE=$(grep -oE "[0-9]{4}-[0-9]{2}-[0-9]{2}" issue_body.txt | head -1)
              fi
              
              # Method 4: Search around common labels (fallback)
              if [ -z "$DATE" ]; then
                DATE=$(grep -A 5 -i "date\|when\|day" issue_body.txt | grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" | head -1)
              fi
              
            else
              echo "DEBUG: Extracting date for UPDATE operation"
              # For update operations, look for target date
              DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
              
              # Extract update type and version number
              UPDATE_TYPE=$(grep -A 3 -i "update.*type" issue_body.txt | grep -v -i "update.*type" | head -1 | xargs)
              VERSION_NUMBER=$(grep -A 3 -i "version.*number" issue_body.txt | grep -v -i "version.*number" | head -1 | xargs)
              
              echo "update_type=$UPDATE_TYPE" >> $GITHUB_OUTPUT
              echo "version_number=$VERSION_NUMBER" >> $GITHUB_OUTPUT
            fi
            
            echo "parsed_date=$DATE" >> $GITHUB_OUTPUT
            echo "DEBUG: Extracted date: '$DATE'"
            
            # Validate date was extracted
            if [ -z "$DATE" ]; then
              echo "ERROR: Could not extract date from issue."
              echo "DEBUG: Issue body for troubleshooting:"
              echo "--- ISSUE BODY START ---"
              cat issue_body.txt
              echo "--- ISSUE BODY END ---"
              echo ""
              echo "Expected format examples:"
              echo "  - Jun 8, 2025"
              echo "  - January 15, 2025"
              echo "  - 6/8/2025"
              echo "  - 2025-06-08"
              exit 1
            fi
          fi
          
      - name: Convert and validate date format
        id: date
        run: |
          DATE="${{ steps.extract.outputs.parsed_date }}"
          echo "DEBUG: Converting date: '$DATE'"
          
          # Enhanced date parsing for various formats
          if [ -n "$DATE" ]; then
            # Try GNU date first (handles "Jun 8, 2025" format perfectly)
            if FORMATTED_DATE=$(date -d "$DATE" +%Y-%m-%d 2>/dev/null); then
              echo "DEBUG: Successfully parsed with GNU date: $FORMATTED_DATE"
            else
              echo "DEBUG: GNU date failed, attempting manual parsing"
              
              # Clean up the date string - remove extra spaces and commas
              DATE_CLEAN=$(echo "$DATE" | sed 's/,/ /g' | tr -s ' ' | xargs)
              echo "DEBUG: Cleaned date: '$DATE_CLEAN'"
              
              # Extract components for "Mon D, YYYY" or "Mon D YYYY" format
              if echo "$DATE_CLEAN" | grep -qE "^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2}[[:space:]]+[0-9]{4}$"; then
                
                # Extract components
                MONTH_NAME=$(echo "$DATE_CLEAN" | cut -d' ' -f1)
                DAY_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f2)
                YEAR_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f3)
                
                echo "DEBUG: Extracted - Month: '$MONTH_NAME', Day: '$DAY_NUM', Year: '$YEAR_NUM'"
                
                # Convert month name to number
                case "$MONTH_NAME" in
                  Jan|January) MONTH_NUM="01" ;;
                  Feb|February) MONTH_NUM="02" ;;
                  Mar|March) MONTH_NUM="03" ;;
                  Apr|April) MONTH_NUM="04" ;;
                  May) MONTH_NUM="05" ;;
                  Jun|June) MONTH_NUM="06" ;;
                  Jul|July) MONTH_NUM="07" ;;
                  Aug|August) MONTH_NUM="08" ;;
                  Sep|September) MONTH_NUM="09" ;;
                  Oct|October) MONTH_NUM="10" ;;
                  Nov|November) MONTH_NUM="11" ;;
                  Dec|December) MONTH_NUM="12" ;;
                  *) 
                    echo "ERROR: Could not parse month: '$MONTH_NAME'"
                    exit 1
                    ;;
                esac
                
                # Validate day (1-31)
                if ! [[ "$DAY_NUM" =~ ^[0-9]+$ ]] || [ "$DAY_NUM" -lt 1 ] || [ "$DAY_NUM" -gt 31 ]; then
                  echo "ERROR: Invalid day: '$DAY_NUM' (must be 1-31)"
                  exit 1
                fi
                
                # Validate year (reasonable range)
                if ! [[ "$YEAR_NUM" =~ ^[0-9]{4}$ ]] || [ "$YEAR_NUM" -lt 2020 ] || [ "$YEAR_NUM" -gt 2030 ]; then
                  echo "ERROR: Invalid year: '$YEAR_NUM' (must be 2020-2030)"
                  exit 1
                fi
                
                # Format as YYYY-MM-DD with zero padding
                FORMATTED_DATE=$(printf "%04d-%02d-%02d" "$YEAR_NUM" "$MONTH_NUM" "$DAY_NUM")
                echo "DEBUG: Manual parsing result: $FORMATTED_DATE"
                
              else
                echo "ERROR: Date format not recognized: '$DATE_CLEAN'"
                echo "Expected format: 'Jun 8, 2025' or 'June 8, 2025'"
                exit 1
              fi
            fi
          else
            echo "ERROR: No date provided"
            exit 1
          fi
          
          # Final validation
          if ! echo "$FORMATTED_DATE" | grep -qE "^[0-9]{4}-[0-9]{2}-[0-9]{2}$"; then
            echo "ERROR: Invalid formatted date: '$FORMATTED_DATE'"
            exit 1
          fi
          
          # Verify it's a valid date
          if ! date -d "$FORMATTED_DATE" >/dev/null 2>&1; then
            echo "ERROR: '$FORMATTED_DATE' is not a valid date"
            exit 1
          fi
          
          echo "formatted_date=$FORMATTED_DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Final formatted date: $FORMATTED_DATE"
          
      - name: Extract and validate CSS content
        id: css
        if: github.event_name != 'workflow_dispatch'
        run: |
          echo "DEBUG: Extracting CSS content from issue for ${{ steps.operation.outputs.type }} operation"
          echo "DEBUG: Full issue body structure:"
          echo "--- ISSUE BODY START ---"
          cat issue_body.txt
          echo "--- ISSUE BODY END ---"
          echo ""
          
          # Method 1: Look for CSS content in code blocks (```css ... ```)
          echo "DEBUG: Method 1 - Looking for CSS in code blocks..."
          if sed -n '/```css/,/```/p' issue_body.txt | sed '1d;$d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
            echo "DEBUG: Found CSS in code blocks"
            
            # Check if the content looks like valid CSS (not mixed with form elements)
            if grep -q "Confirmation\|checkbox\|\[x\]\|\[ \]" css_content_raw.txt; then
              echo "DEBUG: CSS block contains form elements, needs cleaning..."
              # Extract only the actual CSS part, stop at form elements
              sed '/### Comparison Images/,$d; /### Additional Notes/,$d; /### Confirmation/,$d; /- \[/,$d' css_content_raw.txt > css_content_cleaned.txt
              if [ -s css_content_cleaned.txt ]; then
                mv css_content_cleaned.txt css_content_raw.txt
                echo "DEBUG: Cleaned CSS content of form elements"
              fi
            fi
            
          # Method 2: Look for CSS in GitHub issue form structure
          elif echo "DEBUG: Method 2 - Looking for CSS in issue form structure..." && \
               sed -n '/### CSS Solution/,/### Comparison Images/p; /### CSS Solution/,/### Additional Notes/p; /### CSS Solution/,/### Confirmation/p' issue_body.txt | \
               sed '/### Comparison Images/,$d; /### Additional Notes/,$d; /### Confirmation/,$d; /^### /d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
            echo "DEBUG: Found CSS in issue form structure"
            
            # Clean up any remaining form elements or markdown
            sed -e '/^```css$/d' -e '/^```$/d' -e '/^- \[/d' -e '/^\[x\]/d' -e '/Confirmation/d' css_content_raw.txt > css_content_temp.txt
            mv css_content_temp.txt css_content_raw.txt
            
          else
            echo "ERROR: No CSS content found in issue"
            exit 1
          fi
          
          # Clean up the CSS content more thoroughly
          echo "DEBUG: Cleaning CSS content..."
          
          # Remove common issue form artifacts and clean up formatting
          sed -e '/^[[:space:]]*$/d' \
              -e '/^```css$/d' \
              -e '/^```$/d' \
              -e '/^### /d' \
              -e '/^- \[/d' \
              -e '/^\[x\]/d' \
              -e '/^\[ \]/d' \
              -e '/Confirmation/d' \
              -e '/I have tested/d' \
              -e '/comparison images/d' \
              -e '/show the target/d' \
              -e 's/^[[:space:]]*//' \
              css_content_raw.txt > css_content.txt
          
          # Final validation - CSS content exists after cleaning
          if [ ! -s css_content.txt ]; then
            echo "ERROR: CSS content is empty after processing"
            exit 1
          fi
          
          echo "DEBUG: Final cleaned CSS content:"
          echo "--- FINAL CSS CONTENT START ---"
          cat css_content.txt
          echo "--- FINAL CSS CONTENT END ---"
          
          # Count versions by counting ---VERSION--- separators
          VERSION_COUNT=$(grep -c "---VERSION---" css_content.txt 2>/dev/null || echo 0)
          VERSION_COUNT=$((VERSION_COUNT + 1))
          echo "version_count=$VERSION_COUNT" >> $GITHUB_OUTPUT
          echo "DEBUG: Found $VERSION_COUNT CSS versions"
          
      - name: Process manual CSS content
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "DEBUG: Processing manual CSS content"
          echo "Raw CSS content:"
          cat css_content.txt
          
          # Count versions by counting ---VERSION--- separators
          VERSION_COUNT=$(grep -c "---VERSION---" css_content.txt 2>/dev/null || echo 0)
          VERSION_COUNT=$((VERSION_COUNT + 1))
          echo "DEBUG: Found $VERSION_COUNT CSS versions"
          
      - name: Create directory structure
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          echo "DEBUG: Creating directory: $TARGET_DIR"
          
          mkdir -p "$TARGET_DIR"
          
          if [ ! -d "$TARGET_DIR" ]; then
            echo "ERROR: Failed to create directory: $TARGET_DIR"
            exit 1
          fi
          
          echo "DEBUG: Directory created successfully"
          ls -la daily-targets/
          
      - name: Create or update solutions file
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          SOLUTIONS_FILE="$TARGET_DIR/solutions.html"
          
          echo "DEBUG: Processing solutions file: $SOLUTIONS_FILE"
          
          # Clean CSS content - remove ```css and ``` markers, keep only the actual CSS
          sed -e '/^```css$/d' -e '/^```$/d' css_content.txt > css_cleaned.txt
          
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "Creating new solutions file..."
            
            # Start with Version 1 comment
            echo "<!-- Version 1 -->" > "$SOLUTIONS_FILE"
            
            # Process CSS content with version separation
            version_num=1
            while IFS= read -r line || [ -n "$line" ]; do
              if [[ "$line" == "---VERSION---" ]]; then
                # Close current version and start new one
                echo "</style>" >> "$SOLUTIONS_FILE"
                echo "" >> "$SOLUTIONS_FILE"
                version_num=$((version_num + 1))
                echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
              else
                echo "$line" >> "$SOLUTIONS_FILE"
              fi
            done < css_cleaned.txt
            
            # Ensure file ends with </style>
            if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
              echo "</style>" >> "$SOLUTIONS_FILE"
            fi
            
          else
            echo "Updating existing solutions file..."
            
            if [ ! -f "$SOLUTIONS_FILE" ]; then
              echo "ERROR: Solutions file not found: $SOLUTIONS_FILE"
              echo "Available dates:"
              ls daily-targets/ 2>/dev/null || echo "No existing solutions found"
              exit 1
            fi
            
            # For updates, add new versions
            echo "Adding new CSS versions..."
            # Find last version number
            LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
            NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
            
            echo "" >> "$SOLUTIONS_FILE"
            echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
            
            # Process CSS content with version separation
            version_num=$NEXT_VERSION
            while IFS= read -r line || [ -n "$line" ]; do
              if [[ "$line" == "---VERSION---" ]]; then
                # Close current version and start new one
                echo "</style>" >> "$SOLUTIONS_FILE"
                echo "" >> "$SOLUTIONS_FILE"
                version_num=$((version_num + 1))
                echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
              else
                echo "$line" >> "$SOLUTIONS_FILE"
              fi
            done < css_cleaned.txt
            
            # Ensure file ends with </style>
            if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
              echo "</style>" >> "$SOLUTIONS_FILE"
            fi
          fi
          
          echo "Solutions file processing complete"
          echo "DEBUG: Final solutions file content:"
          cat "$SOLUTIONS_FILE"
          
      - name: Download and process images
        if: github.event_name != 'workflow_dispatch'
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          ISSUE_NUM="${{ github.event.issue.number }}"
          
          echo "DEBUG: Processing images for issue #$ISSUE_NUM"
          
          # Get the full issue data including uploaded assets
          echo "DEBUG: Fetching issue data..."
          gh issue view "$ISSUE_NUM" --repo "${{ github.repository }}" --json body,url > issue_data.json
          
          # Extract the issue body
          ISSUE_BODY=$(jq -r '.body' issue_data.json)
          echo "DEBUG: Issue body extracted, length: ${#ISSUE_BODY}"
          
          # Look for image URL patterns in issue body
          echo "DEBUG: Searching for image URLs in issue body..."
          
          # Clear any existing image URLs file
          > image_urls.txt
          
          # Pattern 1: GitHub user content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 2: GitHub assets URLs  
          echo "$ISSUE_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/assets/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 3: Generic GitHub content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://[^.]*\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Remove duplicates and empty lines
          if [ -f image_urls.txt ]; then
            sort image_urls.txt | uniq | grep -v '^$' > image_urls_clean.txt || touch image_urls_clean.txt
            mv image_urls_clean.txt image_urls.txt
          else
            touch image_urls.txt
          fi
          
          # Download images
          NEXT_NUM=1
          IMAGE_COUNT=$(wc -l < image_urls.txt)
          
          if [ -s image_urls.txt ] && [ "$IMAGE_COUNT" -gt 0 ]; then
            echo "Found $IMAGE_COUNT image(s) to download"
            
            while IFS= read -r img_url; do
              if [ -n "$img_url" ]; then
                ext=$(echo "$img_url" | grep -oE '\.(png|jpg|jpeg|gif|webp)$' | head -1)
                if [ -z "$ext" ]; then
                  ext=".png"
                fi
                
                filename="target-${NEXT_NUM}-comparison${ext}"
                filepath="$TARGET_DIR/$filename"
                
                echo "Downloading: $img_url to $filename"
                
                if curl -L -f -s "$img_url" -o "$filepath" 2>/dev/null; then
                  file_type=$(file "$filepath" 2>/dev/null || echo "unknown")
                  if echo "$file_type" | grep -qi "image"; then
                    echo "âœ… Successfully downloaded: $filename"
                    NEXT_NUM=$((NEXT_NUM + 1))
                  else
                    rm -f "$filepath"
                  fi
                fi
              fi
            done < image_urls.txt
          fi
          
      - name: Process local screenshots
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          
          # Check for existing images to determine next number
          EXISTING_IMAGES=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | wc -l)
          NEXT_NUM=$((EXISTING_IMAGES + 1))
          
          # Look for common screenshot file patterns in root directory
          SCREENSHOT_PATTERNS=(
            "screenshot*.png"
            "screenshot*.jpg"
            "comparison*.png"
            "target*.png"
            "cssbattle*.png"
          )
          
          for pattern in "${SCREENSHOT_PATTERNS[@]}"; do
            if ls $pattern 1> /dev/null 2>&1; then
              for file in $pattern; do
                if [ -f "$file" ]; then
                  ext=$(echo "$file" | grep -oE '\.[^.]*$')
                  if [ -z "$ext" ]; then
                    ext=".png"
                  fi
                  
                  target_filename="target-${NEXT_NUM}-comparison${ext}"
                  target_filepath="$TARGET_DIR/$target_filename"
                  
                  echo "Moving: $file to $target_filename"
                  
                  if cp "$file" "$target_filepath"; then
                    file_type=$(file "$target_filepath" 2>/dev/null || echo "unknown")
                    if echo "$file_type" | grep -qi "image"; then
                      echo "âœ… Successfully moved: $target_filename"
                      rm -f "$file"
                      NEXT_NUM=$((NEXT_NUM + 1))
                    else
                      rm -f "$target_filepath"
                    fi
                  fi
                fi
              done
            fi
          done
          
      - name: Generate LinkedIn post
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          LINKEDIN_FILE="$TARGET_DIR/linkedin-post.md"
          
          # Extract additional notes
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ADDITIONAL_NOTES="${{ github.event.inputs.additional_notes }}"
          elif [ "${{ github.event_name }}" != "workflow_dispatch" ] && [ -f issue_body.txt ]; then
            # Extract from issue
            ADDITIONAL_NOTES=$(awk '/### Additional Notes/{flag=1; next} /### Confirmation|### /{flag=0} flag && !/^[[:space:]]*$/ && !/^- \[/ && !/^\[x\]/' issue_body.txt | head -3 | tr '\n' ' ' | xargs)
          fi
          
          # Use default if empty
          if [ -z "$ADDITIONAL_NOTES" ]; then
            if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
              ADDITIONAL_NOTES="Another CSS challenge completed! ðŸŽ¯"
            else
              ADDITIONAL_NOTES="Updated my CSS solution with improvements! ðŸš€"
            fi
          fi
          
          # Generate the repository URL
          REPO_URL="https://github.com/${{ github.repository }}"
          SOLUTIONS_URL="$REPO_URL/blob/main/daily-targets/${{ steps.date.outputs.formatted_date }}/solutions.html"
          
          # Create LinkedIn post
          cat > "$LINKEDIN_FILE" << EOF
# LinkedIn Post for ${{ steps.date.outputs.formatted_date }}

---

Today's CSSBattle solution:

$ADDITIONAL_NOTES

$SOLUTIONS_URL

(My journal notes.)

#cssgang #CSS #CSSBattle #HTML
EOF
          
          echo "LinkedIn post generated successfully"
          
      - name: Commit and push changes
        run: |
          # Configure git
          git config --local user.email "${GIT_USER_EMAIL:-${{ github.actor }}@users.noreply.github.com}"
          git config --local user.name "${GIT_USER_NAME:-${{ github.actor }}}"
          
          # Check for changes
          git add .
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "has_changes=false" >> $GITHUB_ENV
          else
            # Commit and push
            if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
              COMMIT_MSG="feat: CSS Battle solution for ${{ steps.date.outputs.formatted_date }}"
            else
              COMMIT_MSG="update: CSS Battle solution for ${{ steps.date.outputs.formatted_date }}"
            fi
            
            git commit -m "$COMMIT_MSG"
            git push origin main
            echo "has_changes=true" >> $GITHUB_ENV
          fi
          
      - name: Create success comment and close issue
        if: github.event_name != 'workflow_dispatch' && env.has_changes != 'false'
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          VERSION_COUNT=$(grep -c "<!-- Version" "$TARGET_DIR/solutions.html" 2>/dev/null || echo 1)
          IMAGE_COUNT=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | wc -l)
          
          cat > comment.txt << EOF
# âœ… CSS Battle Solution Processed Successfully!

## ðŸ“ Location
\`$TARGET_DIR/\`

## ðŸ“Š Processing Summary
- ðŸŽ¯ **CSS Versions Created:** $VERSION_COUNT
- ðŸ“¥ **Images Downloaded:** $IMAGE_COUNT
- ðŸ“… **Target Date:** ${{ steps.date.outputs.formatted_date }}
- ðŸ”„ **Operation Type:** ${{ steps.operation.outputs.type }}

## ðŸ“„ Files Created
- âœ… \`solutions.html\` - Your CSS solution
- âœ… \`linkedin-post.md\` - Ready-to-post LinkedIn content

## ðŸ”— Quick Links
- ðŸ“± **LinkedIn Post:** [\`linkedin-post.md\`](${{ github.server_url }}/${{ github.repository }}/blob/main/$TARGET_DIR/linkedin-post.md)
- ðŸ’» **CSS Solution:** [\`solutions.html\`](${{ github.server_url }}/${{ github.repository }}/blob/main/$TARGET_DIR/solutions.html)

## ðŸŽ‰ Ready for Battle!
Your solution is now organized and ready for sharing!
EOF
          
          gh issue comment "${{ github.event.issue.number }}" --repo "${{ github.repository }}" --body-file comment.txt
          gh issue close "${{ github.event.issue.number }}" --repo "${{ github.repository }}" --reason completed

      - name: Cleanup temporary files
        if: always()
        run: |
          echo "ðŸ§¹ Cleaning up temporary files..."
          
          TEMP_FILES=(
            "issue_body.txt"
            "css_content.txt"
            "css_content_raw.txt"
            "css_cleaned.txt"
            "image_urls.txt"
            "image_urls_clean.txt"
            "issue_data.json"
            "comment.txt"
          )
          
          for file in "${TEMP_FILES[@]}"; do
            if [ -f "$file" ]; then
              echo "Removing: $file"
              rm -f "$file"
            fi
          done
          
          # Remove any remaining temporary files
          rm -f version_*.css 2>/dev/null || true
          rm -f *.tmp 2>/dev/null || true
          
          echo "âœ… Cleanup completed"
