name: Create or Update Solutions File for Daily CSSBattle
on:
  issues:
    types: [opened]

permissions:
  contents: write
  issues: write
  
jobs:
  process-solutions-file:
    runs-on: ubuntu-latest
    if: contains(github.event.issue.title, '[CSSBattle]') || contains(github.event.issue.title, '[CSSBattle-UPDATE]')
    
    env:
      GIT_USER_EMAIL: ${{ secrets.GIT_USER_EMAIL }}
      GIT_USER_NAME: ${{ secrets.GIT_USER_NAME }}
    
    steps:
      - name: Debug trigger conditions
        run: |
          echo "ðŸ” DEBUG: Trigger Analysis"
          echo "Issue title: '${{ github.event.issue.title }}'"
          echo "Issue number: ${{ github.event.issue.number }}"
          echo "Issue author: ${{ github.event.issue.user.login }}"
          echo "Repository: ${{ github.repository }}"
          echo "Event action: ${{ github.event.action }}"
          echo ""
          echo "ðŸ” Checking trigger conditions:"
          if [[ "${{ github.event.issue.title }}" == *"[CSSBattle]"* ]]; then
            echo "âœ… Title contains '[CSSBattle]'"
          else
            echo "âŒ Title does NOT contain '[CSSBattle]'"
          fi
          
          if [[ "${{ github.event.issue.title }}" == *"[CSSBattle-UPDATE]"* ]]; then
            echo "âœ… Title contains '[CSSBattle-UPDATE]'"
          else
            echo "âŒ Title does NOT contain '[CSSBattle-UPDATE]'"
          fi
          echo ""
          
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
      
      - name: Determine operation type
        id: operation
        run: |
          if [[ "${{ github.event.issue.title }}" == *"[CSSBattle-UPDATE]"* ]]; then
            echo "type=update" >> $GITHUB_OUTPUT
            echo "Operation: UPDATE"
          else
            echo "type=create" >> $GITHUB_OUTPUT
            echo "Operation: CREATE"
          fi
      
      - name: Extract and validate issue data
        id: extract
        run: |
          # Save issue body to file for processing
          cat > issue_body.txt << 'EOF'
          ${{ github.event.issue.body }}
          EOF
          
          echo "DEBUG: Issue body content:"
          cat issue_body.txt
          echo "DEBUG: ===== END OF ISSUE BODY ====="
          
          # Validate issue body is not empty
          if [ ! -s issue_body.txt ]; then
            echo "ERROR: Issue body is empty"
            exit 1
          fi
          
          # Extract date based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "DEBUG: Extracting date for CREATE operation"
            
            # GitHub issue forms create structured output, look for the date field
            # The issue body will contain the date value after field processing
            
            # Method 1: Look for date pattern directly (for "Jun 8, 2025" format)
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Method 2: If not found, look for numeric date formats
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{1,2}/[0-9]{1,2}/[0-9]{4}" issue_body.txt | head -1)
            fi
            
            # Method 3: Look for ISO format dates
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{4}-[0-9]{2}-[0-9]{2}" issue_body.txt | head -1)
            fi
            
            # Method 4: Search around common labels (fallback)
            if [ -z "$DATE" ]; then
              # Look for lines that might contain dates after field labels
              DATE=$(grep -A 5 -i "date\|when\|day" issue_body.txt | grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" | head -1)
            fi
            
          else
            echo "DEBUG: Extracting date for UPDATE operation"
            # For update operations, look for target date
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Extract update type and version number (implement as needed for UPDATE template)
            UPDATE_TYPE=$(grep -A 3 -i "update.*type" issue_body.txt | grep -v -i "update.*type" | head -1 | xargs)
            VERSION_NUMBER=$(grep -A 3 -i "version.*number" issue_body.txt | grep -v -i "version.*number" | head -1 | xargs)
            
            echo "update_type=$UPDATE_TYPE" >> $GITHUB_OUTPUT
            echo "version_number=$VERSION_NUMBER" >> $GITHUB_OUTPUT
          fi
          
          echo "parsed_date=$DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Extracted date: '$DATE'"
          
          # Validate date was extracted
          if [ -z "$DATE" ]; then
            echo "ERROR: Could not extract date from issue."
            echo "DEBUG: Issue body for troubleshooting:"
            echo "--- ISSUE BODY START ---"
            cat issue_body.txt
            echo "--- ISSUE BODY END ---"
            echo ""
            echo "Expected format examples:"
            echo "  - Jun 8, 2025"
            echo "  - January 15, 2025"
            echo "  - 6/8/2025"
            echo "  - 2025-06-08"
            exit 1
          fi
          
      - name: Convert and validate date format
        id: date
        run: |
          DATE="${{ steps.extract.outputs.parsed_date }}"
          echo "DEBUG: Converting date: '$DATE'"
          
          # Enhanced date parsing specifically for your formats
          if [ -n "$DATE" ]; then
            # Try GNU date first (handles "Jun 8, 2025" format perfectly)
            if FORMATTED_DATE=$(date -d "$DATE" +%Y-%m-%d 2>/dev/null); then
              echo "DEBUG: Successfully parsed with GNU date: $FORMATTED_DATE"
            else
              echo "DEBUG: GNU date failed, attempting manual parsing for format like 'Jun 8, 2025'"
              
              # Clean up the date string - remove extra spaces and commas
              DATE_CLEAN=$(echo "$DATE" | sed 's/,/ /g' | tr -s ' ' | xargs)
              echo "DEBUG: Cleaned date: '$DATE_CLEAN'"
              
              # Extract components for "Mon D, YYYY" or "Mon D YYYY" format
              if echo "$DATE_CLEAN" | grep -qE "^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2}[[:space:]]+[0-9]{4}$"; then
                
                # Extract month name
                MONTH_NAME=$(echo "$DATE_CLEAN" | cut -d' ' -f1)
                # Extract day
                DAY_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f2)
                # Extract year  
                YEAR_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f3)
                
                echo "DEBUG: Extracted - Month: '$MONTH_NAME', Day: '$DAY_NUM', Year: '$YEAR_NUM'"
                
                # Convert month abbreviation to number
                case "$MONTH_NAME" in
                  Jan|January) MONTH_NUM="01" ;;
                  Feb|February) MONTH_NUM="02" ;;
                  Mar|March) MONTH_NUM="03" ;;
                  Apr|April) MONTH_NUM="04" ;;
                  May) MONTH_NUM="05" ;;
                  Jun|June) MONTH_NUM="06" ;;
                  Jul|July) MONTH_NUM="07" ;;
                  Aug|August) MONTH_NUM="08" ;;
                  Sep|September) MONTH_NUM="09" ;;
                  Oct|October) MONTH_NUM="10" ;;
                  Nov|November) MONTH_NUM="11" ;;
                  Dec|December) MONTH_NUM="12" ;;
                  *) 
                    echo "ERROR: Could not parse month: '$MONTH_NAME'"
                    echo "Expected: Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec"
                    echo "Or full names: January, February, etc."
                    exit 1
                    ;;
                esac
                
                # Validate day (1-31)
                if ! [[ "$DAY_NUM" =~ ^[0-9]+$ ]] || [ "$DAY_NUM" -lt 1 ] || [ "$DAY_NUM" -gt 31 ]; then
                  echo "ERROR: Invalid day: '$DAY_NUM' (must be 1-31)"
                  exit 1
                fi
                
                # Validate year (reasonable range)
                if ! [[ "$YEAR_NUM" =~ ^[0-9]{4}$ ]] || [ "$YEAR_NUM" -lt 2020 ] || [ "$YEAR_NUM" -gt 2030 ]; then
                  echo "ERROR: Invalid year: '$YEAR_NUM' (must be 2020-2030)"
                  exit 1
                fi
                
                # Format as YYYY-MM-DD with zero padding
                FORMATTED_DATE=$(printf "%04d-%02d-%02d" "$YEAR_NUM" "$MONTH_NUM" "$DAY_NUM")
                echo "DEBUG: Manual parsing result: $FORMATTED_DATE"
                
              else
                echo "ERROR: Date format not recognized: '$DATE_CLEAN'"
                echo "Expected format: 'Jun 8, 2025' or 'June 8, 2025'"
                echo "Received: '$DATE'"
                exit 1
              fi
            fi
          else
            echo "ERROR: No date provided"
            exit 1
          fi
          
          # Final validation of formatted date
          if ! echo "$FORMATTED_DATE" | grep -qE "^[0-9]{4}-[0-9]{2}-[0-9]{2}$"; then
            echo "ERROR: Invalid formatted date: '$FORMATTED_DATE'"
            echo "Expected format: YYYY-MM-DD"
            exit 1
          fi
          
          # Additional sanity check - verify it's a valid date
          if ! date -d "$FORMATTED_DATE" >/dev/null 2>&1; then
            echo "ERROR: '$FORMATTED_DATE' is not a valid date"
            exit 1
          fi
          
          echo "formatted_date=$FORMATTED_DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Final formatted date: $FORMATTED_DATE"
          
      - name: Extract and validate CSS content
        id: css
        run: |
          echo "DEBUG: Extracting CSS content for ${{ steps.operation.outputs.type }} operation"
          
          # For GitHub issue forms, the CSS content is in the issue body
          # Look for CSS code blocks or direct CSS content
          
          # Method 1: Look for CSS content in code blocks (```css ... ```)
          if sed -n '/```css/,/```/p' issue_body.txt | sed '1d;$d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
            echo "DEBUG: Found CSS in code blocks"
          else
            # Method 2: Look for CSS content in HTML style blocks
            if grep -A 50 -B 5 "<style>" issue_body.txt | sed '/^--$/d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
              echo "DEBUG: Found CSS with <style> tags"
            else
              # Method 3: Look for any CSS-like content (fallback)
              if grep -A 20 -i "css\|style" issue_body.txt | grep -E "(background|width|height|margin|padding|color)" > css_content_raw.txt && [ -s css_content_raw.txt ]; then
                echo "DEBUG: Found CSS-like content"
              else
                echo "ERROR: No CSS content found in issue"
                echo "DEBUG: Issue body for troubleshooting:"
                echo "--- ISSUE BODY START ---"
                cat issue_body.txt
                echo "--- ISSUE BODY END ---"
                echo ""
                echo "Expected: CSS code in \`\`\`css blocks or <style> tags"
                exit 1
              fi
            fi
          fi
          
          # Clean up the CSS content
          # Remove empty lines and clean up formatting
          sed '/^[[:space:]]*$/d' css_content_raw.txt > css_content.txt
          
          # Validate CSS content exists after cleaning
          if [ ! -s css_content.txt ]; then
            echo "ERROR: CSS content is empty after processing"
            echo "DEBUG: Raw CSS content was:"
            cat css_content_raw.txt
            exit 1
          fi
          
          echo "DEBUG: CSS content extracted successfully:"
          echo "--- CSS CONTENT START ---"
          head -10 css_content.txt
          if [ $(wc -l < css_content.txt) -gt 10 ]; then
            echo "... (truncated, total lines: $(wc -l < css_content.txt))"
          fi
          echo "--- CSS CONTENT END ---"
          
          # Count versions by counting ---VERSION--- separators
          VERSION_COUNT=$(grep -c "---VERSION---" css_content.txt 2>/dev/null || echo 0)
          VERSION_COUNT=$((VERSION_COUNT + 1))
          echo "version_count=$VERSION_COUNT" >> $GITHUB_OUTPUT
          echo "DEBUG: Found $VERSION_COUNT CSS versions"
          
      - name: Create directory structure
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          echo "DEBUG: Creating directory: $TARGET_DIR"
          
          mkdir -p "$TARGET_DIR"
          
          # Verify directory creation
          if [ ! -d "$TARGET_DIR" ]; then
            echo "ERROR: Failed to create directory: $TARGET_DIR"
            exit 1
          fi
          
          echo "DEBUG: Directory created successfully"
          ls -la daily-targets/
          
      - name: Create or update solutions file
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          SOLUTIONS_FILE="$TARGET_DIR/solutions.html"
          
          echo "DEBUG: Processing solutions file: $SOLUTIONS_FILE"
          
          # Clean CSS content - remove ```css and ``` markers, keep only the actual CSS
          sed -e '/^```css$/d' -e '/^```$/d' css_content.txt > css_cleaned.txt
          
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "Creating new solutions file..."
            
            # Start with Version 1 comment
            echo "<!-- Version 1 -->" > "$SOLUTIONS_FILE"
            
            # Process CSS content with version separation
            version_num=1
            while IFS= read -r line || [ -n "$line" ]; do
              if [[ "$line" == "---VERSION---" ]]; then
                # Close current version and start new one
                echo "</style>" >> "$SOLUTIONS_FILE"
                echo "" >> "$SOLUTIONS_FILE"
                version_num=$((version_num + 1))
                echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
              else
                echo "$line" >> "$SOLUTIONS_FILE"
              fi
            done < css_cleaned.txt
            
            # Ensure file ends with </style>
            if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
              echo "</style>" >> "$SOLUTIONS_FILE"
            fi
            
          else
            echo "Updating existing solutions file..."
            
            if [ ! -f "$SOLUTIONS_FILE" ]; then
              echo "ERROR: Solutions file not found: $SOLUTIONS_FILE"
              echo "Available dates:"
              ls daily-targets/ 2>/dev/null || echo "No existing solutions found"
              exit 1
            fi
            
            case "${{ steps.extract.outputs.update_type }}" in
              "Add new CSS version(s)")
                echo "Adding new CSS versions..."
                # Find last version number
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                # Ensure file ends with </style>
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              "Replace existing CSS version(s)")
                if [ -n "${{ steps.extract.outputs.version_number }}" ]; then
                  echo "Note: Version replacement is complex and not fully implemented"
                  echo "Adding as new version instead..."
                  LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                  NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                  
                  echo "" >> "$SOLUTIONS_FILE"
                  echo "<!-- Version $NEXT_VERSION (replacement for Version ${{ steps.extract.outputs.version_number }}) -->" >> "$SOLUTIONS_FILE"
                  
                  # Add cleaned CSS content
                  cat css_cleaned.txt >> "$SOLUTIONS_FILE"
                  
                  if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                    echo "</style>" >> "$SOLUTIONS_FILE"
                  fi
                else
                  echo "ERROR: Version number required for replacement"
                  exit 1
                fi
                ;;
                
              "Add new comparison image(s)")
                echo "Images will be processed in next step..."
                ;;
                
              "Add both CSS and images")
                echo "Adding new CSS versions and images..."
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              *)
                echo "ERROR: Unknown update type: ${{ steps.extract.outputs.update_type }}"
                exit 1
                ;;
            esac
          fi
          
          echo "Solutions file processing complete"
          echo "DEBUG: Final solutions file content:"
          cat "$SOLUTIONS_FILE"
          
      - name: Download and process images
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          ISSUE_NUM="${{ github.event.issue.number }}"
          
          echo "DEBUG: Processing images for issue #$ISSUE_NUM"
          echo "DEBUG: Target directory: $TARGET_DIR"
          
          # Determine next available image number
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            NEXT_NUM=1
          else
            # Find existing images and get next number
            EXISTING_IMAGES=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | sort)
            if [ -n "$EXISTING_IMAGES" ]; then
              LAST_NUM=$(echo "$EXISTING_IMAGES" | sed 's/.*target-\([0-9]\+\)-comparison\..*/\1/' | sort -n | tail -1)
              NEXT_NUM=$((LAST_NUM + 1))
              echo "DEBUG: Found existing images, starting from number: $NEXT_NUM"
            else
              NEXT_NUM=1
              echo "DEBUG: No existing images found, starting from: $NEXT_NUM"
            fi
          fi
          
          # Get the full issue data including uploaded assets
          echo "DEBUG: Fetching issue data..."
          gh issue view "$ISSUE_NUM" --repo "${{ github.repository }}" --json body,url > issue_data.json
          
          # Debug: Show what we got
          echo "DEBUG: Issue data received:"
          cat issue_data.json
          
          # Extract the issue body
          ISSUE_BODY=$(jq -r '.body' issue_data.json)
          echo "DEBUG: Issue body extracted, length: ${#ISSUE_BODY}"
          
          # Save issue body for debugging
          echo "$ISSUE_BODY" > issue_body_full.txt
          echo "DEBUG: Full issue body saved to file"
          
          # Look for multiple image URL patterns that GitHub uses
          echo "DEBUG: Searching for image URLs..."
          
          # Clear any existing image URLs file
          > image_urls.txt
          
          # Pattern 1: GitHub user content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 2: GitHub assets URLs  
          echo "$ISSUE_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/assets/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 3: Generic GitHub content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://[^.]*\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 4: Any https image URLs (broader catch)
          echo "$ISSUE_BODY" | grep -oE 'https://[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Remove duplicates and empty lines
          if [ -f image_urls.txt ]; then
            sort image_urls.txt | uniq | grep -v '^name: Create or Update Solutions File for Daily CSSBattle
on:
  issues:
    types: [opened]

permissions:
  contents: write
  issues: write
  
jobs:
  process-solutions-file:
    runs-on: ubuntu-latest
    if: contains(github.event.issue.title, '[CSSBattle]') || contains(github.event.issue.title, '[CSSBattle-UPDATE]')
    
    env:
      GIT_USER_EMAIL: ${{ secrets.GIT_USER_EMAIL }}
      GIT_USER_NAME: ${{ secrets.GIT_USER_NAME }}
    
    steps:
      - name: Debug trigger conditions
        run: |
          echo "ðŸ” DEBUG: Trigger Analysis"
          echo "Issue title: '${{ github.event.issue.title }}'"
          echo "Issue number: ${{ github.event.issue.number }}"
          echo "Issue author: ${{ github.event.issue.user.login }}"
          echo "Repository: ${{ github.repository }}"
          echo "Event action: ${{ github.event.action }}"
          echo ""
          echo "ðŸ” Checking trigger conditions:"
          if [[ "${{ github.event.issue.title }}" == *"[CSSBattle]"* ]]; then
            echo "âœ… Title contains '[CSSBattle]'"
          else
            echo "âŒ Title does NOT contain '[CSSBattle]'"
          fi
          
          if [[ "${{ github.event.issue.title }}" == *"[CSSBattle-UPDATE]"* ]]; then
            echo "âœ… Title contains '[CSSBattle-UPDATE]'"
          else
            echo "âŒ Title does NOT contain '[CSSBattle-UPDATE]'"
          fi
          echo ""
          
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
      
      - name: Determine operation type
        id: operation
        run: |
          if [[ "${{ github.event.issue.title }}" == *"[CSSBattle-UPDATE]"* ]]; then
            echo "type=update" >> $GITHUB_OUTPUT
            echo "Operation: UPDATE"
          else
            echo "type=create" >> $GITHUB_OUTPUT
            echo "Operation: CREATE"
          fi
      
      - name: Extract and validate issue data
        id: extract
        run: |
          # Save issue body to file for processing
          cat > issue_body.txt << 'EOF'
          ${{ github.event.issue.body }}
          EOF
          
          echo "DEBUG: Issue body content:"
          cat issue_body.txt
          echo "DEBUG: ===== END OF ISSUE BODY ====="
          
          # Validate issue body is not empty
          if [ ! -s issue_body.txt ]; then
            echo "ERROR: Issue body is empty"
            exit 1
          fi
          
          # Extract date based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "DEBUG: Extracting date for CREATE operation"
            
            # GitHub issue forms create structured output, look for the date field
            # The issue body will contain the date value after field processing
            
            # Method 1: Look for date pattern directly (for "Jun 8, 2025" format)
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Method 2: If not found, look for numeric date formats
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{1,2}/[0-9]{1,2}/[0-9]{4}" issue_body.txt | head -1)
            fi
            
            # Method 3: Look for ISO format dates
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{4}-[0-9]{2}-[0-9]{2}" issue_body.txt | head -1)
            fi
            
            # Method 4: Search around common labels (fallback)
            if [ -z "$DATE" ]; then
              # Look for lines that might contain dates after field labels
              DATE=$(grep -A 5 -i "date\|when\|day" issue_body.txt | grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" | head -1)
            fi
            
          else
            echo "DEBUG: Extracting date for UPDATE operation"
            # For update operations, look for target date
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Extract update type and version number (implement as needed for UPDATE template)
            UPDATE_TYPE=$(grep -A 3 -i "update.*type" issue_body.txt | grep -v -i "update.*type" | head -1 | xargs)
            VERSION_NUMBER=$(grep -A 3 -i "version.*number" issue_body.txt | grep -v -i "version.*number" | head -1 | xargs)
            
            echo "update_type=$UPDATE_TYPE" >> $GITHUB_OUTPUT
            echo "version_number=$VERSION_NUMBER" >> $GITHUB_OUTPUT
          fi
          
          echo "parsed_date=$DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Extracted date: '$DATE'"
          
          # Validate date was extracted
          if [ -z "$DATE" ]; then
            echo "ERROR: Could not extract date from issue."
            echo "DEBUG: Issue body for troubleshooting:"
            echo "--- ISSUE BODY START ---"
            cat issue_body.txt
            echo "--- ISSUE BODY END ---"
            echo ""
            echo "Expected format examples:"
            echo "  - Jun 8, 2025"
            echo "  - January 15, 2025"
            echo "  - 6/8/2025"
            echo "  - 2025-06-08"
            exit 1
          fi
          
      - name: Convert and validate date format
        id: date
        run: |
          DATE="${{ steps.extract.outputs.parsed_date }}"
          echo "DEBUG: Converting date: '$DATE'"
          
          # Enhanced date parsing specifically for your formats
          if [ -n "$DATE" ]; then
            # Try GNU date first (handles "Jun 8, 2025" format perfectly)
            if FORMATTED_DATE=$(date -d "$DATE" +%Y-%m-%d 2>/dev/null); then
              echo "DEBUG: Successfully parsed with GNU date: $FORMATTED_DATE"
            else
              echo "DEBUG: GNU date failed, attempting manual parsing for format like 'Jun 8, 2025'"
              
              # Clean up the date string - remove extra spaces and commas
              DATE_CLEAN=$(echo "$DATE" | sed 's/,/ /g' | tr -s ' ' | xargs)
              echo "DEBUG: Cleaned date: '$DATE_CLEAN'"
              
              # Extract components for "Mon D, YYYY" or "Mon D YYYY" format
              if echo "$DATE_CLEAN" | grep -qE "^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2}[[:space:]]+[0-9]{4}$"; then
                
                # Extract month name
                MONTH_NAME=$(echo "$DATE_CLEAN" | cut -d' ' -f1)
                # Extract day
                DAY_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f2)
                # Extract year  
                YEAR_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f3)
                
                echo "DEBUG: Extracted - Month: '$MONTH_NAME', Day: '$DAY_NUM', Year: '$YEAR_NUM'"
                
                # Convert month abbreviation to number
                case "$MONTH_NAME" in
                  Jan|January) MONTH_NUM="01" ;;
                  Feb|February) MONTH_NUM="02" ;;
                  Mar|March) MONTH_NUM="03" ;;
                  Apr|April) MONTH_NUM="04" ;;
                  May) MONTH_NUM="05" ;;
                  Jun|June) MONTH_NUM="06" ;;
                  Jul|July) MONTH_NUM="07" ;;
                  Aug|August) MONTH_NUM="08" ;;
                  Sep|September) MONTH_NUM="09" ;;
                  Oct|October) MONTH_NUM="10" ;;
                  Nov|November) MONTH_NUM="11" ;;
                  Dec|December) MONTH_NUM="12" ;;
                  *) 
                    echo "ERROR: Could not parse month: '$MONTH_NAME'"
                    echo "Expected: Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec"
                    echo "Or full names: January, February, etc."
                    exit 1
                    ;;
                esac
                
                # Validate day (1-31)
                if ! [[ "$DAY_NUM" =~ ^[0-9]+$ ]] || [ "$DAY_NUM" -lt 1 ] || [ "$DAY_NUM" -gt 31 ]; then
                  echo "ERROR: Invalid day: '$DAY_NUM' (must be 1-31)"
                  exit 1
                fi
                
                # Validate year (reasonable range)
                if ! [[ "$YEAR_NUM" =~ ^[0-9]{4}$ ]] || [ "$YEAR_NUM" -lt 2020 ] || [ "$YEAR_NUM" -gt 2030 ]; then
                  echo "ERROR: Invalid year: '$YEAR_NUM' (must be 2020-2030)"
                  exit 1
                fi
                
                # Format as YYYY-MM-DD with zero padding
                FORMATTED_DATE=$(printf "%04d-%02d-%02d" "$YEAR_NUM" "$MONTH_NUM" "$DAY_NUM")
                echo "DEBUG: Manual parsing result: $FORMATTED_DATE"
                
              else
                echo "ERROR: Date format not recognized: '$DATE_CLEAN'"
                echo "Expected format: 'Jun 8, 2025' or 'June 8, 2025'"
                echo "Received: '$DATE'"
                exit 1
              fi
            fi
          else
            echo "ERROR: No date provided"
            exit 1
          fi
          
          # Final validation of formatted date
          if ! echo "$FORMATTED_DATE" | grep -qE "^[0-9]{4}-[0-9]{2}-[0-9]{2}$"; then
            echo "ERROR: Invalid formatted date: '$FORMATTED_DATE'"
            echo "Expected format: YYYY-MM-DD"
            exit 1
          fi
          
          # Additional sanity check - verify it's a valid date
          if ! date -d "$FORMATTED_DATE" >/dev/null 2>&1; then
            echo "ERROR: '$FORMATTED_DATE' is not a valid date"
            exit 1
          fi
          
          echo "formatted_date=$FORMATTED_DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Final formatted date: $FORMATTED_DATE"
          
      - name: Extract and validate CSS content
        id: css
        run: |
          echo "DEBUG: Extracting CSS content for ${{ steps.operation.outputs.type }} operation"
          
          # For GitHub issue forms, the CSS content is in the issue body
          # Look for CSS code blocks or direct CSS content
          
          # Method 1: Look for CSS content in code blocks (```css ... ```)
          if sed -n '/```css/,/```/p' issue_body.txt | sed '1d;$d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
            echo "DEBUG: Found CSS in code blocks"
          else
            # Method 2: Look for CSS content in HTML style blocks
            if grep -A 50 -B 5 "<style>" issue_body.txt | sed '/^--$/d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
              echo "DEBUG: Found CSS with <style> tags"
            else
              # Method 3: Look for any CSS-like content (fallback)
              if grep -A 20 -i "css\|style" issue_body.txt | grep -E "(background|width|height|margin|padding|color)" > css_content_raw.txt && [ -s css_content_raw.txt ]; then
                echo "DEBUG: Found CSS-like content"
              else
                echo "ERROR: No CSS content found in issue"
                echo "DEBUG: Issue body for troubleshooting:"
                echo "--- ISSUE BODY START ---"
                cat issue_body.txt
                echo "--- ISSUE BODY END ---"
                echo ""
                echo "Expected: CSS code in \`\`\`css blocks or <style> tags"
                exit 1
              fi
            fi
          fi
          
          # Clean up the CSS content
          # Remove empty lines and clean up formatting
          sed '/^[[:space:]]*$/d' css_content_raw.txt > css_content.txt
          
          # Validate CSS content exists after cleaning
          if [ ! -s css_content.txt ]; then
            echo "ERROR: CSS content is empty after processing"
            echo "DEBUG: Raw CSS content was:"
            cat css_content_raw.txt
            exit 1
          fi
          
          echo "DEBUG: CSS content extracted successfully:"
          echo "--- CSS CONTENT START ---"
          head -10 css_content.txt
          if [ $(wc -l < css_content.txt) -gt 10 ]; then
            echo "... (truncated, total lines: $(wc -l < css_content.txt))"
          fi
          echo "--- CSS CONTENT END ---"
          
          # Count versions by counting ---VERSION--- separators
          VERSION_COUNT=$(grep -c "---VERSION---" css_content.txt 2>/dev/null || echo 0)
          VERSION_COUNT=$((VERSION_COUNT + 1))
          echo "version_count=$VERSION_COUNT" >> $GITHUB_OUTPUT
          echo "DEBUG: Found $VERSION_COUNT CSS versions"
          
      - name: Create directory structure
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          echo "DEBUG: Creating directory: $TARGET_DIR"
          
          mkdir -p "$TARGET_DIR"
          
          # Verify directory creation
          if [ ! -d "$TARGET_DIR" ]; then
            echo "ERROR: Failed to create directory: $TARGET_DIR"
            exit 1
          fi
          
          echo "DEBUG: Directory created successfully"
          ls -la daily-targets/
          
      - name: Create or update solutions file
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          SOLUTIONS_FILE="$TARGET_DIR/solutions.html"
          
          echo "DEBUG: Processing solutions file: $SOLUTIONS_FILE"
          
          # Clean CSS content - remove ```css and ``` markers, keep only the actual CSS
          sed -e '/^```css$/d' -e '/^```$/d' css_content.txt > css_cleaned.txt
          
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "Creating new solutions file..."
            
            # Start with Version 1 comment
            echo "<!-- Version 1 -->" > "$SOLUTIONS_FILE"
            
            # Process CSS content with version separation
            version_num=1
            while IFS= read -r line || [ -n "$line" ]; do
              if [[ "$line" == "---VERSION---" ]]; then
                # Close current version and start new one
                echo "</style>" >> "$SOLUTIONS_FILE"
                echo "" >> "$SOLUTIONS_FILE"
                version_num=$((version_num + 1))
                echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
              else
                echo "$line" >> "$SOLUTIONS_FILE"
              fi
            done < css_cleaned.txt
            
            # Ensure file ends with </style>
            if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
              echo "</style>" >> "$SOLUTIONS_FILE"
            fi
            
          else
            echo "Updating existing solutions file..."
            
            if [ ! -f "$SOLUTIONS_FILE" ]; then
              echo "ERROR: Solutions file not found: $SOLUTIONS_FILE"
              echo "Available dates:"
              ls daily-targets/ 2>/dev/null || echo "No existing solutions found"
              exit 1
            fi
            
            case "${{ steps.extract.outputs.update_type }}" in
              "Add new CSS version(s)")
                echo "Adding new CSS versions..."
                # Find last version number
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                # Ensure file ends with </style>
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              "Replace existing CSS version(s)")
                if [ -n "${{ steps.extract.outputs.version_number }}" ]; then
                  echo "Note: Version replacement is complex and not fully implemented"
                  echo "Adding as new version instead..."
                  LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                  NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                  
                  echo "" >> "$SOLUTIONS_FILE"
                  echo "<!-- Version $NEXT_VERSION (replacement for Version ${{ steps.extract.outputs.version_number }}) -->" >> "$SOLUTIONS_FILE"
                  
                  # Add cleaned CSS content
                  cat css_cleaned.txt >> "$SOLUTIONS_FILE"
                  
                  if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                    echo "</style>" >> "$SOLUTIONS_FILE"
                  fi
                else
                  echo "ERROR: Version number required for replacement"
                  exit 1
                fi
                ;;
                
              "Add new comparison image(s)")
                echo "Images will be processed in next step..."
                ;;
                
              "Add both CSS and images")
                echo "Adding new CSS versions and images..."
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              *)
                echo "ERROR: Unknown update type: ${{ steps.extract.outputs.update_type }}"
                exit 1
                ;;
            esac
          fi
          
          echo "Solutions file processing complete"
          echo "DEBUG: Final solutions file content:"
          cat "$SOLUTIONS_FILE"
          
      - name: Download and process images
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          ISSUE_NUM="${{ github.event.issue.number }}"
          
          echo "DEBUG: Processing images for issue #$ISSUE_NUM"
          echo "DEBUG: Target directory: $TARGET_DIR"
          
          # Determine next available image number
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            NEXT_NUM=1
          else
            # Find existing images and get next number
            EXISTING_IMAGES=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | sort)
            if [ -n "$EXISTING_IMAGES" ]; then
              LAST_NUM=$(echo "$EXISTING_IMAGES" | sed 's/.*target-\([0-9]\+\)-comparison\..*/\1/' | sort -n | tail -1)
              NEXT_NUM=$((LAST_NUM + 1))
              echo "DEBUG: Found existing images, starting from number: $NEXT_NUM"
            else
              NEXT_NUM=1
              echo "DEBUG: No existing images found, starting from: $NEXT_NUM"
            fi
          fi
          
          # Get the full issue data including uploaded assets
          echo "DEBUG: Fetching issue data..."
          gh issue view "$ISSUE_NUM" --repo "${{ github.repository }}" --json body,url > issue_data.json
          
          # Debug: Show what we got
          echo "DEBUG: Issue data received:"
          cat issue_data.json
          
          # Extract the issue body
          ISSUE_BODY=$(jq -r '.body' issue_data.json)
          echo "DEBUG: Issue body extracted, length: ${#ISSUE_BODY}"
          
          # Save issue body for debugging
          echo "$ISSUE_BODY" > issue_body_full.txt
          echo "DEBUG: Full issue body saved to file"
          
          # Look for multiple image URL patterns that GitHub uses
          echo "DEBUG: Searching for image URLs..."
          
          # Clear any existing image URLs file
          > image_urls.txt
          
          # Pattern 1: GitHub user content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 2: GitHub assets URLs  
          echo "$ISSUE_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/assets/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 3: Generic GitHub content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://[^.]*\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 4: Any https image URLs (broader catch)
          echo "$ISSUE_BODY" | grep -oE 'https://[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Remove duplicates and empty lines
          if [ -f image_urls.txt ]; then
            sort image_urls.txt | uniq | grep -v '^name: Create or Update Solutions File for Daily CSSBattle
on:
  issues:
    types: [opened]

permissions:
  contents: write
  issues: write
  
jobs:
  process-solutions-file:
    runs-on: ubuntu-latest
    if: contains(github.event.issue.title, '[CSSBattle]') || contains(github.event.issue.title, '[CSSBattle-UPDATE]')
    
    env:
      GIT_USER_EMAIL: ${{ secrets.GIT_USER_EMAIL }}
      GIT_USER_NAME: ${{ secrets.GIT_USER_NAME }}
    
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
      
      - name: Determine operation type
        id: operation
        run: |
          if [[ "${{ github.event.issue.title }}" == *"[CSSBattle-UPDATE]"* ]]; then
            echo "type=update" >> $GITHUB_OUTPUT
            echo "Operation: UPDATE"
          else
            echo "type=create" >> $GITHUB_OUTPUT
            echo "Operation: CREATE"
          fi
      
      - name: Extract and validate issue data
        id: extract
        run: |
          # Save issue body to file for processing
          cat > issue_body.txt << 'EOF'
          ${{ github.event.issue.body }}
          EOF
          
          echo "DEBUG: Issue body content:"
          cat issue_body.txt
          echo "DEBUG: ===== END OF ISSUE BODY ====="
          
          # Validate issue body is not empty
          if [ ! -s issue_body.txt ]; then
            echo "ERROR: Issue body is empty"
            exit 1
          fi
          
          # Extract date based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "DEBUG: Extracting date for CREATE operation"
            
            # GitHub issue forms create structured output, look for the date field
            # The issue body will contain the date value after field processing
            
            # Method 1: Look for date pattern directly (for "Jun 8, 2025" format)
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Method 2: If not found, look for numeric date formats
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{1,2}/[0-9]{1,2}/[0-9]{4}" issue_body.txt | head -1)
            fi
            
            # Method 3: Look for ISO format dates
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{4}-[0-9]{2}-[0-9]{2}" issue_body.txt | head -1)
            fi
            
            # Method 4: Search around common labels (fallback)
            if [ -z "$DATE" ]; then
              # Look for lines that might contain dates after field labels
              DATE=$(grep -A 5 -i "date\|when\|day" issue_body.txt | grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" | head -1)
            fi
            
          else
            echo "DEBUG: Extracting date for UPDATE operation"
            # For update operations, look for target date
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Extract update type and version number (implement as needed for UPDATE template)
            UPDATE_TYPE=$(grep -A 3 -i "update.*type" issue_body.txt | grep -v -i "update.*type" | head -1 | xargs)
            VERSION_NUMBER=$(grep -A 3 -i "version.*number" issue_body.txt | grep -v -i "version.*number" | head -1 | xargs)
            
            echo "update_type=$UPDATE_TYPE" >> $GITHUB_OUTPUT
            echo "version_number=$VERSION_NUMBER" >> $GITHUB_OUTPUT
          fi
          
          echo "parsed_date=$DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Extracted date: '$DATE'"
          
          # Validate date was extracted
          if [ -z "$DATE" ]; then
            echo "ERROR: Could not extract date from issue."
            echo "DEBUG: Issue body for troubleshooting:"
            echo "--- ISSUE BODY START ---"
            cat issue_body.txt
            echo "--- ISSUE BODY END ---"
            echo ""
            echo "Expected format examples:"
            echo "  - Jun 8, 2025"
            echo "  - January 15, 2025"
            echo "  - 6/8/2025"
            echo "  - 2025-06-08"
            exit 1
          fi
          
      - name: Convert and validate date format
        id: date
        run: |
          DATE="${{ steps.extract.outputs.parsed_date }}"
          echo "DEBUG: Converting date: '$DATE'"
          
          # Enhanced date parsing specifically for your formats
          if [ -n "$DATE" ]; then
            # Try GNU date first (handles "Jun 8, 2025" format perfectly)
            if FORMATTED_DATE=$(date -d "$DATE" +%Y-%m-%d 2>/dev/null); then
              echo "DEBUG: Successfully parsed with GNU date: $FORMATTED_DATE"
            else
              echo "DEBUG: GNU date failed, attempting manual parsing for format like 'Jun 8, 2025'"
              
              # Clean up the date string - remove extra spaces and commas
              DATE_CLEAN=$(echo "$DATE" | sed 's/,/ /g' | tr -s ' ' | xargs)
              echo "DEBUG: Cleaned date: '$DATE_CLEAN'"
              
              # Extract components for "Mon D, YYYY" or "Mon D YYYY" format
              if echo "$DATE_CLEAN" | grep -qE "^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2}[[:space:]]+[0-9]{4}$"; then
                
                # Extract month name
                MONTH_NAME=$(echo "$DATE_CLEAN" | cut -d' ' -f1)
                # Extract day
                DAY_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f2)
                # Extract year  
                YEAR_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f3)
                
                echo "DEBUG: Extracted - Month: '$MONTH_NAME', Day: '$DAY_NUM', Year: '$YEAR_NUM'"
                
                # Convert month abbreviation to number
                case "$MONTH_NAME" in
                  Jan|January) MONTH_NUM="01" ;;
                  Feb|February) MONTH_NUM="02" ;;
                  Mar|March) MONTH_NUM="03" ;;
                  Apr|April) MONTH_NUM="04" ;;
                  May) MONTH_NUM="05" ;;
                  Jun|June) MONTH_NUM="06" ;;
                  Jul|July) MONTH_NUM="07" ;;
                  Aug|August) MONTH_NUM="08" ;;
                  Sep|September) MONTH_NUM="09" ;;
                  Oct|October) MONTH_NUM="10" ;;
                  Nov|November) MONTH_NUM="11" ;;
                  Dec|December) MONTH_NUM="12" ;;
                  *) 
                    echo "ERROR: Could not parse month: '$MONTH_NAME'"
                    echo "Expected: Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec"
                    echo "Or full names: January, February, etc."
                    exit 1
                    ;;
                esac
                
                # Validate day (1-31)
                if ! [[ "$DAY_NUM" =~ ^[0-9]+$ ]] || [ "$DAY_NUM" -lt 1 ] || [ "$DAY_NUM" -gt 31 ]; then
                  echo "ERROR: Invalid day: '$DAY_NUM' (must be 1-31)"
                  exit 1
                fi
                
                # Validate year (reasonable range)
                if ! [[ "$YEAR_NUM" =~ ^[0-9]{4}$ ]] || [ "$YEAR_NUM" -lt 2020 ] || [ "$YEAR_NUM" -gt 2030 ]; then
                  echo "ERROR: Invalid year: '$YEAR_NUM' (must be 2020-2030)"
                  exit 1
                fi
                
                # Format as YYYY-MM-DD with zero padding
                FORMATTED_DATE=$(printf "%04d-%02d-%02d" "$YEAR_NUM" "$MONTH_NUM" "$DAY_NUM")
                echo "DEBUG: Manual parsing result: $FORMATTED_DATE"
                
              else
                echo "ERROR: Date format not recognized: '$DATE_CLEAN'"
                echo "Expected format: 'Jun 8, 2025' or 'June 8, 2025'"
                echo "Received: '$DATE'"
                exit 1
              fi
            fi
          else
            echo "ERROR: No date provided"
            exit 1
          fi
          
          # Final validation of formatted date
          if ! echo "$FORMATTED_DATE" | grep -qE "^[0-9]{4}-[0-9]{2}-[0-9]{2}$"; then
            echo "ERROR: Invalid formatted date: '$FORMATTED_DATE'"
            echo "Expected format: YYYY-MM-DD"
            exit 1
          fi
          
          # Additional sanity check - verify it's a valid date
          if ! date -d "$FORMATTED_DATE" >/dev/null 2>&1; then
            echo "ERROR: '$FORMATTED_DATE' is not a valid date"
            exit 1
          fi
          
          echo "formatted_date=$FORMATTED_DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Final formatted date: $FORMATTED_DATE"
          
      - name: Extract and validate CSS content
        id: css
        run: |
          echo "DEBUG: Extracting CSS content for ${{ steps.operation.outputs.type }} operation"
          
          # For GitHub issue forms, the CSS content is in the issue body
          # Look for CSS code blocks or direct CSS content
          
          # Method 1: Look for CSS content in code blocks (```css ... ```)
          if sed -n '/```css/,/```/p' issue_body.txt | sed '1d;$d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
            echo "DEBUG: Found CSS in code blocks"
          else
            # Method 2: Look for CSS content in HTML style blocks
            if grep -A 50 -B 5 "<style>" issue_body.txt | sed '/^--$/d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
              echo "DEBUG: Found CSS with <style> tags"
            else
              # Method 3: Look for any CSS-like content (fallback)
              if grep -A 20 -i "css\|style" issue_body.txt | grep -E "(background|width|height|margin|padding|color)" > css_content_raw.txt && [ -s css_content_raw.txt ]; then
                echo "DEBUG: Found CSS-like content"
              else
                echo "ERROR: No CSS content found in issue"
                echo "DEBUG: Issue body for troubleshooting:"
                echo "--- ISSUE BODY START ---"
                cat issue_body.txt
                echo "--- ISSUE BODY END ---"
                echo ""
                echo "Expected: CSS code in \`\`\`css blocks or <style> tags"
                exit 1
              fi
            fi
          fi
          
          # Clean up the CSS content
          # Remove empty lines and clean up formatting
          sed '/^[[:space:]]*$/d' css_content_raw.txt > css_content.txt
          
          # Validate CSS content exists after cleaning
          if [ ! -s css_content.txt ]; then
            echo "ERROR: CSS content is empty after processing"
            echo "DEBUG: Raw CSS content was:"
            cat css_content_raw.txt
            exit 1
          fi
          
          echo "DEBUG: CSS content extracted successfully:"
          echo "--- CSS CONTENT START ---"
          head -10 css_content.txt
          if [ $(wc -l < css_content.txt) -gt 10 ]; then
            echo "... (truncated, total lines: $(wc -l < css_content.txt))"
          fi
          echo "--- CSS CONTENT END ---"
          
          # Count versions by counting ---VERSION--- separators
          VERSION_COUNT=$(grep -c "---VERSION---" css_content.txt 2>/dev/null || echo 0)
          VERSION_COUNT=$((VERSION_COUNT + 1))
          echo "version_count=$VERSION_COUNT" >> $GITHUB_OUTPUT
          echo "DEBUG: Found $VERSION_COUNT CSS versions"
          
      - name: Create directory structure
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          echo "DEBUG: Creating directory: $TARGET_DIR"
          
          mkdir -p "$TARGET_DIR"
          
          # Verify directory creation
          if [ ! -d "$TARGET_DIR" ]; then
            echo "ERROR: Failed to create directory: $TARGET_DIR"
            exit 1
          fi
          
          echo "DEBUG: Directory created successfully"
          ls -la daily-targets/
          
      - name: Create or update solutions file
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          SOLUTIONS_FILE="$TARGET_DIR/solutions.html"
          
          echo "DEBUG: Processing solutions file: $SOLUTIONS_FILE"
          
          # Clean CSS content - remove ```css and ``` markers, keep only the actual CSS
          sed -e '/^```css$/d' -e '/^```$/d' css_content.txt > css_cleaned.txt
          
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "Creating new solutions file..."
            
            # Start with Version 1 comment
            echo "<!-- Version 1 -->" > "$SOLUTIONS_FILE"
            
            # Process CSS content with version separation
            version_num=1
            while IFS= read -r line || [ -n "$line" ]; do
              if [[ "$line" == "---VERSION---" ]]; then
                # Close current version and start new one
                echo "</style>" >> "$SOLUTIONS_FILE"
                echo "" >> "$SOLUTIONS_FILE"
                version_num=$((version_num + 1))
                echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
              else
                echo "$line" >> "$SOLUTIONS_FILE"
              fi
            done < css_cleaned.txt
            
            # Ensure file ends with </style>
            if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
              echo "</style>" >> "$SOLUTIONS_FILE"
            fi
            
          else
            echo "Updating existing solutions file..."
            
            if [ ! -f "$SOLUTIONS_FILE" ]; then
              echo "ERROR: Solutions file not found: $SOLUTIONS_FILE"
              echo "Available dates:"
              ls daily-targets/ 2>/dev/null || echo "No existing solutions found"
              exit 1
            fi
            
            case "${{ steps.extract.outputs.update_type }}" in
              "Add new CSS version(s)")
                echo "Adding new CSS versions..."
                # Find last version number
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                # Ensure file ends with </style>
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              "Replace existing CSS version(s)")
                if [ -n "${{ steps.extract.outputs.version_number }}" ]; then
                  echo "Note: Version replacement is complex and not fully implemented"
                  echo "Adding as new version instead..."
                  LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                  NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                  
                  echo "" >> "$SOLUTIONS_FILE"
                  echo "<!-- Version $NEXT_VERSION (replacement for Version ${{ steps.extract.outputs.version_number }}) -->" >> "$SOLUTIONS_FILE"
                  
                  # Add cleaned CSS content
                  cat css_cleaned.txt >> "$SOLUTIONS_FILE"
                  
                  if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                    echo "</style>" >> "$SOLUTIONS_FILE"
                  fi
                else
                  echo "ERROR: Version number required for replacement"
                  exit 1
                fi
                ;;
                
              "Add new comparison image(s)")
                echo "Images will be processed in next step..."
                ;;
                
              "Add both CSS and images")
                echo "Adding new CSS versions and images..."
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              *)
                echo "ERROR: Unknown update type: ${{ steps.extract.outputs.update_type }}"
                exit 1
                ;;
            esac
          fi
          
          echo "Solutions file processing complete"
          echo "DEBUG: Final solutions file content:"
          cat "$SOLUTIONS_FILE"
          
      - name: Download and process images
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          ISSUE_NUM="${{ github.event.issue.number }}"
          
          echo "DEBUG: Processing images for issue #$ISSUE_NUM"
          echo "DEBUG: Target directory: $TARGET_DIR"
          
          # Determine next available image number
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            NEXT_NUM=1
          else
            # Find existing images and get next number
            EXISTING_IMAGES=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | sort)
            if [ -n "$EXISTING_IMAGES" ]; then
              LAST_NUM=$(echo "$EXISTING_IMAGES" | sed 's/.*target-\([0-9]\+\)-comparison\..*/\1/' | sort -n | tail -1)
              NEXT_NUM=$((LAST_NUM + 1))
              echo "DEBUG: Found existing images, starting from number: $NEXT_NUM"
            else
              NEXT_NUM=1
              echo "DEBUG: No existing images found, starting from: $NEXT_NUM"
            fi
          fi
          
          # Get the full issue data including uploaded assets
          echo "DEBUG: Fetching issue data..."
          gh issue view "$ISSUE_NUM" --repo "${{ github.repository }}" --json body,url > issue_data.json
          
          # Debug: Show what we got
          echo "DEBUG: Issue data received:"
          cat issue_data.json
          
          # Extract the issue body
          ISSUE_BODY=$(jq -r '.body' issue_data.json)
          echo "DEBUG: Issue body extracted, length: ${#ISSUE_BODY}"
          
          # Save issue body for debugging
          echo "$ISSUE_BODY" > issue_body_full.txt
          echo "DEBUG: Full issue body saved to file"
          
          # Look for multiple image URL patterns that GitHub uses
          echo "DEBUG: Searching for image URLs..."
          
          # Clear any existing image URLs file
          > image_urls.txt
          
          # Pattern 1: GitHub user content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 2: GitHub assets URLs  
          echo "$ISSUE_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/assets/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 3: Generic GitHub content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://[^.]*\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 4: Any https image URLs (broader catch)
          echo "$ISSUE_BODY" | grep -oE 'https://[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Remove duplicates and empty lines
          if [ -f image_urls.txt ]; then
            sort image_urls.txt | uniq | grep -v '^$' > image_urls_clean.txt || touch image_urls_clean.txt
            mv image_urls_clean.txt image_urls.txt
          else
            touch image_urls.txt
          fi
          
          echo "DEBUG: Found image URLs:"
          cat image_urls.txt
          
          # Count images found
          IMAGE_COUNT=$(wc -l < image_urls.txt)
          echo "DEBUG: Total unique image URLs found: $IMAGE_COUNT"
          
          # Download each image with enhanced error handling
          if [ -s image_urls.txt ] && [ "$IMAGE_COUNT" -gt 0 ]; then
            echo "Found $IMAGE_COUNT image(s) to download"
            
            while IFS= read -r img_url; do
              if [ -n "$img_url" ]; then
                echo "DEBUG: Processing URL: $img_url"
                
                # Extract file extension
                ext=$(echo "$img_url" | grep -oE '\.(png|jpg|jpeg|gif|webp)$' | head -1)
                if [ -z "$ext" ]; then
                  ext=".png"  # Default extension
                  echo "DEBUG: No extension found, defaulting to .png"
                fi
                
                filename="target-${NEXT_NUM}-comparison${ext}"
                filepath="$TARGET_DIR/$filename"
                
                echo "Downloading: $img_url"
                echo "         to: $filename"
                
                # Try multiple download methods
                DOWNLOAD_SUCCESS=false
                
                # Method 1: With GitHub token (for private repos)
                if curl -L -f -s \
                        -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                        -H "User-Agent: GitHub-Actions" \
                        -H "Accept: application/vnd.github.v3+json" \
                        "$img_url" -o "$filepath" 2>/dev/null; then
                  DOWNLOAD_SUCCESS=true
                  echo "âœ… Downloaded with GitHub token"
                fi
                
                # Method 2: Without token (for public URLs)
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if curl -L -f -s \
                          -H "User-Agent: Mozilla/5.0 (GitHub Actions)" \
                          "$img_url" -o "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded without token"
                  fi
                fi
                
                # Method 3: Using wget as fallback
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if wget -q --timeout=30 --tries=2 \
                          --header="User-Agent: GitHub-Actions" \
                          "$img_url" -O "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded with wget"
                  fi
                fi
                
                # Verify download
                if [ "$DOWNLOAD_SUCCESS" = true ] && [ -f "$filepath" ] && [ -s "$filepath" ]; then
                  # Check if it's actually an image file
                  file_type=$(file "$filepath" 2>/dev/null || echo "unknown")
                  if echo "$file_type" | grep -qi "image\|png\|jpeg\|gif\|webp"; then
                    echo "âœ… Successfully downloaded and verified: $filename"
                    echo "   File type: $file_type"
                    echo "   File size: $(du -h "$filepath" | cut -f1)"
                    NEXT_NUM=$((NEXT_NUM + 1))
                  else
                    echo "âŒ Downloaded file is not an image: $filename"
                    echo "   File type detected: $file_type"
                    rm -f "$filepath"
                  fi
                else
                  echo "âŒ Failed to download: $img_url"
                  [ -f "$filepath" ] && rm -f "$filepath"
                fi
                
                echo "---"
              fi
            done < image_urls.txt
          else
            echo "No images found in issue body"
            echo "DEBUG: This could mean:"
            echo "  - No images were uploaded to the issue"
            echo "  - Images are in a format/location we're not detecting"
            echo "  - The issue template format is different than expected"
          fi
          
          # Summary
          FINAL_IMAGE_COUNT=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | wc -l)
          echo ""
          echo "SUMMARY:"
          echo "  Images found in issue: $IMAGE_COUNT"
          echo "  Images successfully downloaded: $FINAL_IMAGE_COUNT"
          echo "  Images saved in: $TARGET_DIR"
          
          if [ "$FINAL_IMAGE_COUNT" -gt 0 ]; then
            echo "  Downloaded files:"
            find "$TARGET_DIR" -name "target-*-comparison.*" | sort
          fi
          
      - name: Generate LinkedIn post
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          LINKEDIN_FILE="$TARGET_DIR/linkedin-post.md"
          
          # Extract additional notes based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            # For GitHub issue forms, look for the "Additional Notes" content
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "additional.*notes\|notes\|description" | grep -v -i "additional.*notes\|notes\|description" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          else
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "update.*notes\|notes" | grep -v -i "update.*notes\|notes" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          fi
          
          # Clean up additional notes - remove empty content
          ADDITIONAL_NOTES=$(echo "$ADDITIONAL_NOTES" | xargs)
          
          # If no additional notes found, create a default description
          if [ -z "$ADDITIONAL_NOTES" ]; then
            if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
              ADDITIONAL_NOTES="Another CSS challenge completed! ðŸŽ¯"
            else
              ADDITIONAL_NOTES="Updated my CSS solution with improvements! ðŸš€"
            fi
          fi
          
          # Generate the repository URL for the solutions.html file
          REPO_URL="https://github.com/${{ github.repository }}"
          SOLUTIONS_URL="$REPO_URL/blob/main/daily-targets/${{ steps.date.outputs.formatted_date }}/solutions.html"
          
          # Create LinkedIn post with the exact format requested
          cat > "$LINKEDIN_FILE" << EOF
# LinkedIn Post for ${{ steps.date.outputs.formatted_date }}

---

Today's CSSBattle solution:

$ADDITIONAL_NOTES

$SOLUTIONS_URL

(My journal notes.)

#cssgang #CSS #CSSBattle #HTML
EOF
          
          echo "LinkedIn post generated successfully"
          echo "DEBUG: LinkedIn post content:"
          cat "$LINKEDIN_FILE"
          
      - name: Commit and push changes
        run: |
          # Configure git
          git config --local user.email "${GIT_USER_EMAIL:-${{ github.actor }}@users.noreply.github.com}"
          git config --local user.name "${GIT_USER_NAME:-${{ github.actor }}}"
          
          # Check if there are changes to commit
          git add .
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "has_changes=false" >> $GITHUB_ENV
          else
            # Pull latest changes to avoid conflicts
            echo "Pulling latest changes..."
            git fetch origin
            git rebase origin/main || {
              echo "Rebase failed, trying merge strategy..." > image_urls_clean.txt || touch image_urls_clean.txt
            mv image_urls_clean.txt image_urls.txt
          else
            touch image_urls.txt
          fi
          
          echo "DEBUG: Found image URLs:"
          cat image_urls.txt
          
          # Count images found
          IMAGE_COUNT=$(wc -l < image_urls.txt)
          echo "DEBUG: Total unique image URLs found: $IMAGE_COUNT"
          
          # Download each image with enhanced error handling
          if [ -s image_urls.txt ] && [ "$IMAGE_COUNT" -gt 0 ]; then
            echo "Found $IMAGE_COUNT image(s) to download"
            
            while IFS= read -r img_url; do
              if [ -n "$img_url" ]; then
                echo "DEBUG: Processing URL: $img_url"
                
                # Extract file extension
                ext=$(echo "$img_url" | grep -oE '\.(png|jpg|jpeg|gif|webp)name: Create or Update Solutions File for Daily CSSBattle
on:
  issues:
    types: [opened]

permissions:
  contents: write
  issues: write
  
jobs:
  process-solutions-file:
    runs-on: ubuntu-latest
    if: contains(github.event.issue.title, '[CSSBattle]') || contains(github.event.issue.title, '[CSSBattle-UPDATE]')
    
    env:
      GIT_USER_EMAIL: ${{ secrets.GIT_USER_EMAIL }}
      GIT_USER_NAME: ${{ secrets.GIT_USER_NAME }}
    
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
      
      - name: Determine operation type
        id: operation
        run: |
          if [[ "${{ github.event.issue.title }}" == *"[CSSBattle-UPDATE]"* ]]; then
            echo "type=update" >> $GITHUB_OUTPUT
            echo "Operation: UPDATE"
          else
            echo "type=create" >> $GITHUB_OUTPUT
            echo "Operation: CREATE"
          fi
      
      - name: Extract and validate issue data
        id: extract
        run: |
          # Save issue body to file for processing
          cat > issue_body.txt << 'EOF'
          ${{ github.event.issue.body }}
          EOF
          
          echo "DEBUG: Issue body content:"
          cat issue_body.txt
          echo "DEBUG: ===== END OF ISSUE BODY ====="
          
          # Validate issue body is not empty
          if [ ! -s issue_body.txt ]; then
            echo "ERROR: Issue body is empty"
            exit 1
          fi
          
          # Extract date based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "DEBUG: Extracting date for CREATE operation"
            
            # GitHub issue forms create structured output, look for the date field
            # The issue body will contain the date value after field processing
            
            # Method 1: Look for date pattern directly (for "Jun 8, 2025" format)
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Method 2: If not found, look for numeric date formats
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{1,2}/[0-9]{1,2}/[0-9]{4}" issue_body.txt | head -1)
            fi
            
            # Method 3: Look for ISO format dates
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{4}-[0-9]{2}-[0-9]{2}" issue_body.txt | head -1)
            fi
            
            # Method 4: Search around common labels (fallback)
            if [ -z "$DATE" ]; then
              # Look for lines that might contain dates after field labels
              DATE=$(grep -A 5 -i "date\|when\|day" issue_body.txt | grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" | head -1)
            fi
            
          else
            echo "DEBUG: Extracting date for UPDATE operation"
            # For update operations, look for target date
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Extract update type and version number (implement as needed for UPDATE template)
            UPDATE_TYPE=$(grep -A 3 -i "update.*type" issue_body.txt | grep -v -i "update.*type" | head -1 | xargs)
            VERSION_NUMBER=$(grep -A 3 -i "version.*number" issue_body.txt | grep -v -i "version.*number" | head -1 | xargs)
            
            echo "update_type=$UPDATE_TYPE" >> $GITHUB_OUTPUT
            echo "version_number=$VERSION_NUMBER" >> $GITHUB_OUTPUT
          fi
          
          echo "parsed_date=$DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Extracted date: '$DATE'"
          
          # Validate date was extracted
          if [ -z "$DATE" ]; then
            echo "ERROR: Could not extract date from issue."
            echo "DEBUG: Issue body for troubleshooting:"
            echo "--- ISSUE BODY START ---"
            cat issue_body.txt
            echo "--- ISSUE BODY END ---"
            echo ""
            echo "Expected format examples:"
            echo "  - Jun 8, 2025"
            echo "  - January 15, 2025"
            echo "  - 6/8/2025"
            echo "  - 2025-06-08"
            exit 1
          fi
          
      - name: Convert and validate date format
        id: date
        run: |
          DATE="${{ steps.extract.outputs.parsed_date }}"
          echo "DEBUG: Converting date: '$DATE'"
          
          # Enhanced date parsing specifically for your formats
          if [ -n "$DATE" ]; then
            # Try GNU date first (handles "Jun 8, 2025" format perfectly)
            if FORMATTED_DATE=$(date -d "$DATE" +%Y-%m-%d 2>/dev/null); then
              echo "DEBUG: Successfully parsed with GNU date: $FORMATTED_DATE"
            else
              echo "DEBUG: GNU date failed, attempting manual parsing for format like 'Jun 8, 2025'"
              
              # Clean up the date string - remove extra spaces and commas
              DATE_CLEAN=$(echo "$DATE" | sed 's/,/ /g' | tr -s ' ' | xargs)
              echo "DEBUG: Cleaned date: '$DATE_CLEAN'"
              
              # Extract components for "Mon D, YYYY" or "Mon D YYYY" format
              if echo "$DATE_CLEAN" | grep -qE "^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2}[[:space:]]+[0-9]{4}$"; then
                
                # Extract month name
                MONTH_NAME=$(echo "$DATE_CLEAN" | cut -d' ' -f1)
                # Extract day
                DAY_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f2)
                # Extract year  
                YEAR_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f3)
                
                echo "DEBUG: Extracted - Month: '$MONTH_NAME', Day: '$DAY_NUM', Year: '$YEAR_NUM'"
                
                # Convert month abbreviation to number
                case "$MONTH_NAME" in
                  Jan|January) MONTH_NUM="01" ;;
                  Feb|February) MONTH_NUM="02" ;;
                  Mar|March) MONTH_NUM="03" ;;
                  Apr|April) MONTH_NUM="04" ;;
                  May) MONTH_NUM="05" ;;
                  Jun|June) MONTH_NUM="06" ;;
                  Jul|July) MONTH_NUM="07" ;;
                  Aug|August) MONTH_NUM="08" ;;
                  Sep|September) MONTH_NUM="09" ;;
                  Oct|October) MONTH_NUM="10" ;;
                  Nov|November) MONTH_NUM="11" ;;
                  Dec|December) MONTH_NUM="12" ;;
                  *) 
                    echo "ERROR: Could not parse month: '$MONTH_NAME'"
                    echo "Expected: Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec"
                    echo "Or full names: January, February, etc."
                    exit 1
                    ;;
                esac
                
                # Validate day (1-31)
                if ! [[ "$DAY_NUM" =~ ^[0-9]+$ ]] || [ "$DAY_NUM" -lt 1 ] || [ "$DAY_NUM" -gt 31 ]; then
                  echo "ERROR: Invalid day: '$DAY_NUM' (must be 1-31)"
                  exit 1
                fi
                
                # Validate year (reasonable range)
                if ! [[ "$YEAR_NUM" =~ ^[0-9]{4}$ ]] || [ "$YEAR_NUM" -lt 2020 ] || [ "$YEAR_NUM" -gt 2030 ]; then
                  echo "ERROR: Invalid year: '$YEAR_NUM' (must be 2020-2030)"
                  exit 1
                fi
                
                # Format as YYYY-MM-DD with zero padding
                FORMATTED_DATE=$(printf "%04d-%02d-%02d" "$YEAR_NUM" "$MONTH_NUM" "$DAY_NUM")
                echo "DEBUG: Manual parsing result: $FORMATTED_DATE"
                
              else
                echo "ERROR: Date format not recognized: '$DATE_CLEAN'"
                echo "Expected format: 'Jun 8, 2025' or 'June 8, 2025'"
                echo "Received: '$DATE'"
                exit 1
              fi
            fi
          else
            echo "ERROR: No date provided"
            exit 1
          fi
          
          # Final validation of formatted date
          if ! echo "$FORMATTED_DATE" | grep -qE "^[0-9]{4}-[0-9]{2}-[0-9]{2}$"; then
            echo "ERROR: Invalid formatted date: '$FORMATTED_DATE'"
            echo "Expected format: YYYY-MM-DD"
            exit 1
          fi
          
          # Additional sanity check - verify it's a valid date
          if ! date -d "$FORMATTED_DATE" >/dev/null 2>&1; then
            echo "ERROR: '$FORMATTED_DATE' is not a valid date"
            exit 1
          fi
          
          echo "formatted_date=$FORMATTED_DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Final formatted date: $FORMATTED_DATE"
          
      - name: Extract and validate CSS content
        id: css
        run: |
          echo "DEBUG: Extracting CSS content for ${{ steps.operation.outputs.type }} operation"
          
          # For GitHub issue forms, the CSS content is in the issue body
          # Look for CSS code blocks or direct CSS content
          
          # Method 1: Look for CSS content in code blocks (```css ... ```)
          if sed -n '/```css/,/```/p' issue_body.txt | sed '1d;$d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
            echo "DEBUG: Found CSS in code blocks"
          else
            # Method 2: Look for CSS content in HTML style blocks
            if grep -A 50 -B 5 "<style>" issue_body.txt | sed '/^--$/d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
              echo "DEBUG: Found CSS with <style> tags"
            else
              # Method 3: Look for any CSS-like content (fallback)
              if grep -A 20 -i "css\|style" issue_body.txt | grep -E "(background|width|height|margin|padding|color)" > css_content_raw.txt && [ -s css_content_raw.txt ]; then
                echo "DEBUG: Found CSS-like content"
              else
                echo "ERROR: No CSS content found in issue"
                echo "DEBUG: Issue body for troubleshooting:"
                echo "--- ISSUE BODY START ---"
                cat issue_body.txt
                echo "--- ISSUE BODY END ---"
                echo ""
                echo "Expected: CSS code in \`\`\`css blocks or <style> tags"
                exit 1
              fi
            fi
          fi
          
          # Clean up the CSS content
          # Remove empty lines and clean up formatting
          sed '/^[[:space:]]*$/d' css_content_raw.txt > css_content.txt
          
          # Validate CSS content exists after cleaning
          if [ ! -s css_content.txt ]; then
            echo "ERROR: CSS content is empty after processing"
            echo "DEBUG: Raw CSS content was:"
            cat css_content_raw.txt
            exit 1
          fi
          
          echo "DEBUG: CSS content extracted successfully:"
          echo "--- CSS CONTENT START ---"
          head -10 css_content.txt
          if [ $(wc -l < css_content.txt) -gt 10 ]; then
            echo "... (truncated, total lines: $(wc -l < css_content.txt))"
          fi
          echo "--- CSS CONTENT END ---"
          
          # Count versions by counting ---VERSION--- separators
          VERSION_COUNT=$(grep -c "---VERSION---" css_content.txt 2>/dev/null || echo 0)
          VERSION_COUNT=$((VERSION_COUNT + 1))
          echo "version_count=$VERSION_COUNT" >> $GITHUB_OUTPUT
          echo "DEBUG: Found $VERSION_COUNT CSS versions"
          
      - name: Create directory structure
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          echo "DEBUG: Creating directory: $TARGET_DIR"
          
          mkdir -p "$TARGET_DIR"
          
          # Verify directory creation
          if [ ! -d "$TARGET_DIR" ]; then
            echo "ERROR: Failed to create directory: $TARGET_DIR"
            exit 1
          fi
          
          echo "DEBUG: Directory created successfully"
          ls -la daily-targets/
          
      - name: Create or update solutions file
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          SOLUTIONS_FILE="$TARGET_DIR/solutions.html"
          
          echo "DEBUG: Processing solutions file: $SOLUTIONS_FILE"
          
          # Clean CSS content - remove ```css and ``` markers, keep only the actual CSS
          sed -e '/^```css$/d' -e '/^```$/d' css_content.txt > css_cleaned.txt
          
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "Creating new solutions file..."
            
            # Start with Version 1 comment
            echo "<!-- Version 1 -->" > "$SOLUTIONS_FILE"
            
            # Process CSS content with version separation
            version_num=1
            while IFS= read -r line || [ -n "$line" ]; do
              if [[ "$line" == "---VERSION---" ]]; then
                # Close current version and start new one
                echo "</style>" >> "$SOLUTIONS_FILE"
                echo "" >> "$SOLUTIONS_FILE"
                version_num=$((version_num + 1))
                echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
              else
                echo "$line" >> "$SOLUTIONS_FILE"
              fi
            done < css_cleaned.txt
            
            # Ensure file ends with </style>
            if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
              echo "</style>" >> "$SOLUTIONS_FILE"
            fi
            
          else
            echo "Updating existing solutions file..."
            
            if [ ! -f "$SOLUTIONS_FILE" ]; then
              echo "ERROR: Solutions file not found: $SOLUTIONS_FILE"
              echo "Available dates:"
              ls daily-targets/ 2>/dev/null || echo "No existing solutions found"
              exit 1
            fi
            
            case "${{ steps.extract.outputs.update_type }}" in
              "Add new CSS version(s)")
                echo "Adding new CSS versions..."
                # Find last version number
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                # Ensure file ends with </style>
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              "Replace existing CSS version(s)")
                if [ -n "${{ steps.extract.outputs.version_number }}" ]; then
                  echo "Note: Version replacement is complex and not fully implemented"
                  echo "Adding as new version instead..."
                  LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                  NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                  
                  echo "" >> "$SOLUTIONS_FILE"
                  echo "<!-- Version $NEXT_VERSION (replacement for Version ${{ steps.extract.outputs.version_number }}) -->" >> "$SOLUTIONS_FILE"
                  
                  # Add cleaned CSS content
                  cat css_cleaned.txt >> "$SOLUTIONS_FILE"
                  
                  if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                    echo "</style>" >> "$SOLUTIONS_FILE"
                  fi
                else
                  echo "ERROR: Version number required for replacement"
                  exit 1
                fi
                ;;
                
              "Add new comparison image(s)")
                echo "Images will be processed in next step..."
                ;;
                
              "Add both CSS and images")
                echo "Adding new CSS versions and images..."
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              *)
                echo "ERROR: Unknown update type: ${{ steps.extract.outputs.update_type }}"
                exit 1
                ;;
            esac
          fi
          
          echo "Solutions file processing complete"
          echo "DEBUG: Final solutions file content:"
          cat "$SOLUTIONS_FILE"
          
      - name: Download and process images
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          ISSUE_NUM="${{ github.event.issue.number }}"
          
          echo "DEBUG: Processing images for issue #$ISSUE_NUM"
          echo "DEBUG: Target directory: $TARGET_DIR"
          
          # Determine next available image number
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            NEXT_NUM=1
          else
            # Find existing images and get next number
            EXISTING_IMAGES=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | sort)
            if [ -n "$EXISTING_IMAGES" ]; then
              LAST_NUM=$(echo "$EXISTING_IMAGES" | sed 's/.*target-\([0-9]\+\)-comparison\..*/\1/' | sort -n | tail -1)
              NEXT_NUM=$((LAST_NUM + 1))
              echo "DEBUG: Found existing images, starting from number: $NEXT_NUM"
            else
              NEXT_NUM=1
              echo "DEBUG: No existing images found, starting from: $NEXT_NUM"
            fi
          fi
          
          # Get the full issue data including uploaded assets
          echo "DEBUG: Fetching issue data..."
          gh issue view "$ISSUE_NUM" --repo "${{ github.repository }}" --json body,url > issue_data.json
          
          # Debug: Show what we got
          echo "DEBUG: Issue data received:"
          cat issue_data.json
          
          # Extract the issue body
          ISSUE_BODY=$(jq -r '.body' issue_data.json)
          echo "DEBUG: Issue body extracted, length: ${#ISSUE_BODY}"
          
          # Save issue body for debugging
          echo "$ISSUE_BODY" > issue_body_full.txt
          echo "DEBUG: Full issue body saved to file"
          
          # Look for multiple image URL patterns that GitHub uses
          echo "DEBUG: Searching for image URLs..."
          
          # Clear any existing image URLs file
          > image_urls.txt
          
          # Pattern 1: GitHub user content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 2: GitHub assets URLs  
          echo "$ISSUE_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/assets/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 3: Generic GitHub content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://[^.]*\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 4: Any https image URLs (broader catch)
          echo "$ISSUE_BODY" | grep -oE 'https://[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Remove duplicates and empty lines
          if [ -f image_urls.txt ]; then
            sort image_urls.txt | uniq | grep -v '^$' > image_urls_clean.txt || touch image_urls_clean.txt
            mv image_urls_clean.txt image_urls.txt
          else
            touch image_urls.txt
          fi
          
          echo "DEBUG: Found image URLs:"
          cat image_urls.txt
          
          # Count images found
          IMAGE_COUNT=$(wc -l < image_urls.txt)
          echo "DEBUG: Total unique image URLs found: $IMAGE_COUNT"
          
          # Download each image with enhanced error handling
          if [ -s image_urls.txt ] && [ "$IMAGE_COUNT" -gt 0 ]; then
            echo "Found $IMAGE_COUNT image(s) to download"
            
            while IFS= read -r img_url; do
              if [ -n "$img_url" ]; then
                echo "DEBUG: Processing URL: $img_url"
                
                # Extract file extension
                ext=$(echo "$img_url" | grep -oE '\.(png|jpg|jpeg|gif|webp)$' | head -1)
                if [ -z "$ext" ]; then
                  ext=".png"  # Default extension
                  echo "DEBUG: No extension found, defaulting to .png"
                fi
                
                filename="target-${NEXT_NUM}-comparison${ext}"
                filepath="$TARGET_DIR/$filename"
                
                echo "Downloading: $img_url"
                echo "         to: $filename"
                
                # Try multiple download methods
                DOWNLOAD_SUCCESS=false
                
                # Method 1: With GitHub token (for private repos)
                if curl -L -f -s \
                        -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                        -H "User-Agent: GitHub-Actions" \
                        -H "Accept: application/vnd.github.v3+json" \
                        "$img_url" -o "$filepath" 2>/dev/null; then
                  DOWNLOAD_SUCCESS=true
                  echo "âœ… Downloaded with GitHub token"
                fi
                
                # Method 2: Without token (for public URLs)
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if curl -L -f -s \
                          -H "User-Agent: Mozilla/5.0 (GitHub Actions)" \
                          "$img_url" -o "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded without token"
                  fi
                fi
                
                # Method 3: Using wget as fallback
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if wget -q --timeout=30 --tries=2 \
                          --header="User-Agent: GitHub-Actions" \
                          "$img_url" -O "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded with wget"
                  fi
                fi
                
                # Verify download
                if [ "$DOWNLOAD_SUCCESS" = true ] && [ -f "$filepath" ] && [ -s "$filepath" ]; then
                  # Check if it's actually an image file
                  file_type=$(file "$filepath" 2>/dev/null || echo "unknown")
                  if echo "$file_type" | grep -qi "image\|png\|jpeg\|gif\|webp"; then
                    echo "âœ… Successfully downloaded and verified: $filename"
                    echo "   File type: $file_type"
                    echo "   File size: $(du -h "$filepath" | cut -f1)"
                    NEXT_NUM=$((NEXT_NUM + 1))
                  else
                    echo "âŒ Downloaded file is not an image: $filename"
                    echo "   File type detected: $file_type"
                    rm -f "$filepath"
                  fi
                else
                  echo "âŒ Failed to download: $img_url"
                  [ -f "$filepath" ] && rm -f "$filepath"
                fi
                
                echo "---"
              fi
            done < image_urls.txt
          else
            echo "No images found in issue body"
            echo "DEBUG: This could mean:"
            echo "  - No images were uploaded to the issue"
            echo "  - Images are in a format/location we're not detecting"
            echo "  - The issue template format is different than expected"
          fi
          
          # Summary
          FINAL_IMAGE_COUNT=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | wc -l)
          echo ""
          echo "SUMMARY:"
          echo "  Images found in issue: $IMAGE_COUNT"
          echo "  Images successfully downloaded: $FINAL_IMAGE_COUNT"
          echo "  Images saved in: $TARGET_DIR"
          
          if [ "$FINAL_IMAGE_COUNT" -gt 0 ]; then
            echo "  Downloaded files:"
            find "$TARGET_DIR" -name "target-*-comparison.*" | sort
          fi
          
      - name: Generate LinkedIn post
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          LINKEDIN_FILE="$TARGET_DIR/linkedin-post.md"
          
          # Extract additional notes based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            # For GitHub issue forms, look for the "Additional Notes" content
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "additional.*notes\|notes\|description" | grep -v -i "additional.*notes\|notes\|description" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          else
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "update.*notes\|notes" | grep -v -i "update.*notes\|notes" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          fi
          
          # Clean up additional notes - remove empty content
          ADDITIONAL_NOTES=$(echo "$ADDITIONAL_NOTES" | xargs)
          
          # If no additional notes found, create a default description
          if [ -z "$ADDITIONAL_NOTES" ]; then
            if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
              ADDITIONAL_NOTES="Another CSS challenge completed! ðŸŽ¯"
            else
              ADDITIONAL_NOTES="Updated my CSS solution with improvements! ðŸš€"
            fi
          fi
          
          # Generate the repository URL for the solutions.html file
          REPO_URL="https://github.com/${{ github.repository }}"
          SOLUTIONS_URL="$REPO_URL/blob/main/daily-targets/${{ steps.date.outputs.formatted_date }}/solutions.html"
          
          # Create LinkedIn post with the exact format requested
          cat > "$LINKEDIN_FILE" << EOF
# LinkedIn Post for ${{ steps.date.outputs.formatted_date }}

---

Today's CSSBattle solution:

$ADDITIONAL_NOTES

$SOLUTIONS_URL

(My journal notes.)

#cssgang #CSS #CSSBattle #HTML
EOF
          
          echo "LinkedIn post generated successfully"
          echo "DEBUG: LinkedIn post content:"
          cat "$LINKEDIN_FILE"
          
      - name: Commit and push changes
        run: |
          # Configure git
          git config --local user.email "${GIT_USER_EMAIL:-${{ github.actor }}@users.noreply.github.com}"
          git config --local user.name "${GIT_USER_NAME:-${{ github.actor }}}"
          
          # Check if there are changes to commit
          git add .
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "has_changes=false" >> $GITHUB_ENV
          else
            # Pull latest changes to avoid conflicts
            echo "Pulling latest changes..."
            git fetch origin
            git rebase origin/main || {
              echo "Rebase failed, trying merge strategy..." | head -1)
                if [ -z "$ext" ]; then
                  ext=".png"  # Default extension
                  echo "DEBUG: No extension found, defaulting to .png"
                fi
                
                filename="target-${NEXT_NUM}-comparison${ext}"
                filepath="$TARGET_DIR/$filename"
                
                echo "Downloading: $img_url"
                echo "         to: $filename"
                
                # Try multiple download methods
                DOWNLOAD_SUCCESS=false
                
                # Method 1: With GitHub token (for private repos)
                if curl -L -f -s \
                        -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                        -H "User-Agent: GitHub-Actions" \
                        -H "Accept: application/vnd.github.v3+json" \
                        "$img_url" -o "$filepath" 2>/dev/null; then
                  DOWNLOAD_SUCCESS=true
                  echo "âœ… Downloaded with GitHub token"
                fi
                
                # Method 2: Without token (for public URLs)
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if curl -L -f -s \
                          -H "User-Agent: Mozilla/5.0 (GitHub Actions)" \
                          "$img_url" -o "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded without token"
                  fi
                fi
                
                # Method 3: Using wget as fallback
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if wget -q --timeout=30 --tries=2 \
                          --header="User-Agent: GitHub-Actions" \
                          "$img_url" -O "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded with wget"
                  fi
                fi
                
                # Verify download
                if [ "$DOWNLOAD_SUCCESS" = true ] && [ -f "$filepath" ] && [ -s "$filepath" ]; then
                  # Check if it's actually an image file
                  file_type=$(file "$filepath" 2>/dev/null || echo "unknown")
                  if echo "$file_type" | grep -qi "image\|png\|jpeg\|gif\|webp"; then
                    echo "âœ… Successfully downloaded and verified: $filename"
                    echo "   File type: $file_type"
                    echo "   File size: $(du -h "$filepath" | cut -f1)"
                    NEXT_NUM=$((NEXT_NUM + 1))
                  else
                    echo "âŒ Downloaded file is not an image: $filename"
                    echo "   File type detected: $file_type"
                    rm -f "$filepath"
                  fi
                else
                  echo "âŒ Failed to download: $img_url"
                  [ -f "$filepath" ] && rm -f "$filepath"
                fi
                
                echo "---"
              fi
            done < image_urls.txt
          else
            echo "No images found in issue body"
            echo "DEBUG: This could mean:"
            echo "  - No images were uploaded to the issue"
            echo "  - Images are in a format/location we're not detecting"
            echo "  - The issue template format is different than expected"
          fi
          
          # Summary
          FINAL_IMAGE_COUNT=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | wc -l)
          echo ""
          echo "SUMMARY:"
          echo "  Images found in issue: $IMAGE_COUNT"
          echo "  Images successfully downloaded: $FINAL_IMAGE_COUNT"
          echo "  Images saved in: $TARGET_DIR"
          
          if [ "$FINAL_IMAGE_COUNT" -gt 0 ]; then
            echo "  Downloaded files:"
            find "$TARGET_DIR" -name "target-*-comparison.*" | sort
          fi
          
      - name: Generate LinkedIn post
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          LINKEDIN_FILE="$TARGET_DIR/linkedin-post.md"
          
          # Extract additional notes based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            # For GitHub issue forms, look for the "Additional Notes" content
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "additional.*notes\|notes\|description" | grep -v -i "additional.*notes\|notes\|description" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          else
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "update.*notes\|notes" | grep -v -i "update.*notes\|notes" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          fi
          
          # Clean up additional notes - remove empty content
          ADDITIONAL_NOTES=$(echo "$ADDITIONAL_NOTES" | xargs)
          
          # If no additional notes found, create a default description
          if [ -z "$ADDITIONAL_NOTES" ]; then
            if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
              ADDITIONAL_NOTES="Another CSS challenge completed! ðŸŽ¯"
            else
              ADDITIONAL_NOTES="Updated my CSS solution with improvements! ðŸš€"
            fi
          fi
          
          # Generate the repository URL for the solutions.html file
          REPO_URL="https://github.com/${{ github.repository }}"
          SOLUTIONS_URL="$REPO_URL/blob/main/daily-targets/${{ steps.date.outputs.formatted_date }}/solutions.html"
          
          # Create LinkedIn post with the exact format requested
          cat > "$LINKEDIN_FILE" << EOF
# LinkedIn Post for ${{ steps.date.outputs.formatted_date }}

---

Today's CSSBattle solution:

$ADDITIONAL_NOTES

$SOLUTIONS_URL

(My journal notes.)

#cssgang #CSS #CSSBattle #HTML
EOF
          
          echo "LinkedIn post generated successfully"
          echo "DEBUG: LinkedIn post content:"
          cat "$LINKEDIN_FILE"
          
      - name: Commit and push changes
        run: |
          # Configure git
          git config --local user.email "${GIT_USER_EMAIL:-${{ github.actor }}@users.noreply.github.com}"
          git config --local user.name "${GIT_USER_NAME:-${{ github.actor }}}"
          
          # Check if there are changes to commit
          git add .
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "has_changes=false" >> $GITHUB_ENV
          else
            # Pull latest changes to avoid conflicts
            echo "Pulling latest changes..."
            git fetch origin
            git rebase origin/main || {
              echo "Rebase failed, trying merge strategy..."
              git rebase --abort
              git merge origin/main
            }
            
            # Commit changes
            if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
              COMMIT_MSG="feat: CSS Battle solution for ${{ steps.date.outputs.formatted_date }}"
            else
              COMMIT_MSG="update: CSS Battle solution for ${{ steps.date.outputs.formatted_date }}"
            fi
            
            git commit -m "$COMMIT_MSG"
            
            # Push with retry logic
            echo "Pushing changes..."
            for i in {1..3}; do
              if git push origin main; then
                echo "âœ… Changes pushed successfully"
                echo "has_changes=true" >> $GITHUB_ENV
                break
              else
                echo "âŒ Push attempt $i failed"
                if [ $i -lt 3 ]; then
                  echo "Retrying after pull..."
                  git pull origin main --rebase
                else
                  echo "All push attempts failed"
                  exit 1
                fi
              fi
            done
          fi
          
      - name: Create success comment and close issue
        if: env.has_changes != 'false'
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          
          # Count final results
          VERSION_COUNT_IN_FILE=$(grep -c "<!-- Version" "$TARGET_DIR/solutions.html" 2>/dev/null || echo 1)
          IMAGE_COUNT=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | wc -l)
          
          # Get processing summary from the image download step
          IMAGES_FOUND=$(cat image_urls.txt 2>/dev/null | wc -l || echo 0)
          
          # Calculate character counts for each CSS version (from original cleaned CSS)
          echo "DEBUG: Calculating character counts..."
          
          # Split the cleaned CSS content by ---VERSION--- markers
          cp css_cleaned.txt css_for_counting.txt
          
          # Create individual version files for counting
          version_num=1
          current_file="version_${version_num}.css"
          > "$current_file"  # Create empty first version file
          
          while IFS= read -r line || [ -n "$line" ]; do
            if [[ "$line" == "---VERSION---" ]]; then
              # Start new version file
              version_num=$((version_num + 1))
              current_file="version_${version_num}.css"
              > "$current_file"  # Create empty new version file
            else
              # Add line to current version file
              echo "$line" >> "$current_file"
            fi
          done < css_for_counting.txt
          
          # Count characters for each version (excluding any </style> tags)
          CHAR_COUNTS=""
          for i in $(seq 1 $VERSION_COUNT_IN_FILE); do
            version_file="version_${i}.css"
            if [ -f "$version_file" ]; then
              # Remove any </style> tags and count characters
              char_count=$(sed 's|</style>||g' "$version_file" | tr -d '\n' | wc -c)
              if [ $i -eq 1 ]; then
                CHAR_COUNTS="Version $i: $char_count chars"
              else
                CHAR_COUNTS="$CHAR_COUNTS - Version $i: $char_count chars"
              fi
              echo "DEBUG: Version $i character count: $char_count"
            fi
          done
          
          # Create comprehensive success comment with detailed summary
          # Using separate echo statements to avoid heredoc quoting issues
          cat > comment.txt << 'COMMENT_EOF'
# âœ… CSS Battle Solution Processed Successfully!

## ðŸ“ Location
COMMENT_EOF
          
          echo "\`$TARGET_DIR/\`" >> comment.txt
          echo "" >> comment.txt
          echo "## ðŸ“Š Processing Summary" >> comment.txt
          echo "- ðŸŽ¯ **CSS Versions Created:** $VERSION_COUNT_IN_FILE" >> comment.txt
          echo "- ðŸ–¼ï¸ **Images Found in Issue:** $IMAGES_FOUND" >> comment.txt
          echo "- ðŸ“¥ **Images Successfully Downloaded:** $IMAGE_COUNT" >> comment.txt
          echo "- ðŸ“… **Target Date:** ${{ steps.date.outputs.formatted_date }}" >> comment.txt
          echo "- ðŸ”„ **Operation Type:** ${{ steps.operation.outputs.type }}" >> comment.txt
          echo "" >> comment.txt
          echo "## âš¡ Char Count" >> comment.txt
          echo "$CHAR_COUNTS" >> comment.txt
          echo "" >> comment.txt
          echo "## ðŸ“„ Files Created/Updated" >> comment.txt
          echo "" >> comment.txt
          echo "### Solutions" >> comment.txt
          echo "- âœ… \`solutions.html\` - Your CSS solution ($VERSION_COUNT_IN_FILE version(s))" >> comment.txt
          echo "" >> comment.txt
          echo "### Content" >> comment.txt
          echo "- âœ… \`linkedin-post.md\` - Ready-to-post LinkedIn content" >> comment.txt
          echo "" >> comment.txt
          echo "### Images" >> comment.txt
          
          if [ "$IMAGE_COUNT" -gt 0 ]; then
            echo "ðŸ“¸ **Downloaded Images:**" >> comment.txt
            find "$TARGET_DIR" -name "target-*-comparison.*" | sort | while read -r img; do
              # Get file size for each image
              size=$(du -h "$img" 2>/dev/null | cut -f1 || echo "?")
              echo "- âœ… \`$(basename "$img")\` (${size})" >> comment.txt
            done
          else
            echo "- â„¹ï¸ No images were uploaded or found" >> comment.txt
            if [ "$IMAGES_FOUND" -gt 0 ]; then
              echo "- âš ï¸ Found $IMAGES_FOUND image URL(s) but download failed" >> comment.txt
            fi
          fi
          
          echo "" >> comment.txt
          echo "## ðŸ”— Quick Links" >> comment.txt
          echo "- ðŸ“± **LinkedIn Post:** [\`linkedin-post.md\`](${{ github.server_url }}/${{ github.repository }}/blob/main/$TARGET_DIR/linkedin-post.md)" >> comment.txt
          echo "- ðŸ’» **CSS Solution:** [\`solutions.html\`](${{ github.server_url }}/${{ github.repository }}/blob/main/$TARGET_DIR/solutions.html)" >> comment.txt
          echo "- ðŸ“ **Full Directory:** [\`$TARGET_DIR/\`](${{ github.server_url }}/${{ github.repository }}/tree/main/$TARGET_DIR)" >> comment.txt
          echo "" >> comment.txt
          echo "## ðŸŽ‰ Ready for Battle!" >> comment.txt
          echo "Your solution is now organized and ready for sharing. Click the LinkedIn post link above to copy the content!" >> comment.txt
          echo "" >> comment.txt
          echo "---" >> comment.txt
          echo "*âœ¨ Processed by GitHub Actions on $(date)*" >> comment.txt
          echo "*ðŸ”§ Workflow: [\`${{ github.workflow }}\`](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*" >> comment.txt
          
          # Post comment and close issue
          gh issue comment "${{ github.event.issue.number }}" \
            --repo "${{ github.repository }}" \
            --body-file comment.txt
          
          gh issue close "${{ github.event.issue.number }}" \
            --repo "${{ github.repository }}" \
            --reason completed

      - name: Cleanup temporary files
        if: always()
        run: |
          echo "ðŸ§¹ Cleaning up temporary files..."
          
          # List of temporary files that may be created during the workflow
          TEMP_FILES=(
            "issue_body.txt"
            "css_content.txt"
            "css_content_raw.txt"
            "css_cleaned.txt"
            "css_for_counting.txt"
            "image_urls.txt"
            "image_urls_clean.txt"
            "formatted_date_backup.txt"
            "date_output.txt"
            "issue_data.json"
            "issue_body_full.txt"
            "comment.txt"
            "temp_solutions.html"
          )
          
          # Remove each temporary file if it exists
          for file in "${TEMP_FILES[@]}"; do
            if [ -f "$file" ]; then
              echo "Removing: $file"
              rm -f "$file"
            fi
          done
          
          # Remove version-specific character counting files
          rm -f version_*.css 2>/dev/null || true
          
          # Double-check for any other temporary files with common patterns
          find . -maxdepth 1 -name "*.tmp" -type f -delete 2>/dev/null || true
          find . -maxdepth 1 -name "temp_*" -type f -delete 2>/dev/null || true
          
          echo "âœ… Cleanup completed - repository is clean"
          
          # Verify cleanup (optional debug)
          echo "DEBUG: Remaining files in root directory:"
          ls -laname: Create or Update Solutions File for Daily CSSBattle
on:
  issues:
    types: [opened]

permissions:
  contents: write
  issues: write
  
jobs:
  process-solutions-file:
    runs-on: ubuntu-latest
    if: contains(github.event.issue.title, '[CSSBattle]') || contains(github.event.issue.title, '[CSSBattle-UPDATE]')
    
    env:
      GIT_USER_EMAIL: ${{ secrets.GIT_USER_EMAIL }}
      GIT_USER_NAME: ${{ secrets.GIT_USER_NAME }}
    
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
      
      - name: Determine operation type
        id: operation
        run: |
          if [[ "${{ github.event.issue.title }}" == *"[CSSBattle-UPDATE]"* ]]; then
            echo "type=update" >> $GITHUB_OUTPUT
            echo "Operation: UPDATE"
          else
            echo "type=create" >> $GITHUB_OUTPUT
            echo "Operation: CREATE"
          fi
      
      - name: Extract and validate issue data
        id: extract
        run: |
          # Save issue body to file for processing
          cat > issue_body.txt << 'EOF'
          ${{ github.event.issue.body }}
          EOF
          
          echo "DEBUG: Issue body content:"
          cat issue_body.txt
          echo "DEBUG: ===== END OF ISSUE BODY ====="
          
          # Validate issue body is not empty
          if [ ! -s issue_body.txt ]; then
            echo "ERROR: Issue body is empty"
            exit 1
          fi
          
          # Extract date based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "DEBUG: Extracting date for CREATE operation"
            
            # GitHub issue forms create structured output, look for the date field
            # The issue body will contain the date value after field processing
            
            # Method 1: Look for date pattern directly (for "Jun 8, 2025" format)
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Method 2: If not found, look for numeric date formats
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{1,2}/[0-9]{1,2}/[0-9]{4}" issue_body.txt | head -1)
            fi
            
            # Method 3: Look for ISO format dates
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{4}-[0-9]{2}-[0-9]{2}" issue_body.txt | head -1)
            fi
            
            # Method 4: Search around common labels (fallback)
            if [ -z "$DATE" ]; then
              # Look for lines that might contain dates after field labels
              DATE=$(grep -A 5 -i "date\|when\|day" issue_body.txt | grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" | head -1)
            fi
            
          else
            echo "DEBUG: Extracting date for UPDATE operation"
            # For update operations, look for target date
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Extract update type and version number (implement as needed for UPDATE template)
            UPDATE_TYPE=$(grep -A 3 -i "update.*type" issue_body.txt | grep -v -i "update.*type" | head -1 | xargs)
            VERSION_NUMBER=$(grep -A 3 -i "version.*number" issue_body.txt | grep -v -i "version.*number" | head -1 | xargs)
            
            echo "update_type=$UPDATE_TYPE" >> $GITHUB_OUTPUT
            echo "version_number=$VERSION_NUMBER" >> $GITHUB_OUTPUT
          fi
          
          echo "parsed_date=$DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Extracted date: '$DATE'"
          
          # Validate date was extracted
          if [ -z "$DATE" ]; then
            echo "ERROR: Could not extract date from issue."
            echo "DEBUG: Issue body for troubleshooting:"
            echo "--- ISSUE BODY START ---"
            cat issue_body.txt
            echo "--- ISSUE BODY END ---"
            echo ""
            echo "Expected format examples:"
            echo "  - Jun 8, 2025"
            echo "  - January 15, 2025"
            echo "  - 6/8/2025"
            echo "  - 2025-06-08"
            exit 1
          fi
          
      - name: Convert and validate date format
        id: date
        run: |
          DATE="${{ steps.extract.outputs.parsed_date }}"
          echo "DEBUG: Converting date: '$DATE'"
          
          # Enhanced date parsing specifically for your formats
          if [ -n "$DATE" ]; then
            # Try GNU date first (handles "Jun 8, 2025" format perfectly)
            if FORMATTED_DATE=$(date -d "$DATE" +%Y-%m-%d 2>/dev/null); then
              echo "DEBUG: Successfully parsed with GNU date: $FORMATTED_DATE"
            else
              echo "DEBUG: GNU date failed, attempting manual parsing for format like 'Jun 8, 2025'"
              
              # Clean up the date string - remove extra spaces and commas
              DATE_CLEAN=$(echo "$DATE" | sed 's/,/ /g' | tr -s ' ' | xargs)
              echo "DEBUG: Cleaned date: '$DATE_CLEAN'"
              
              # Extract components for "Mon D, YYYY" or "Mon D YYYY" format
              if echo "$DATE_CLEAN" | grep -qE "^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2}[[:space:]]+[0-9]{4}$"; then
                
                # Extract month name
                MONTH_NAME=$(echo "$DATE_CLEAN" | cut -d' ' -f1)
                # Extract day
                DAY_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f2)
                # Extract year  
                YEAR_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f3)
                
                echo "DEBUG: Extracted - Month: '$MONTH_NAME', Day: '$DAY_NUM', Year: '$YEAR_NUM'"
                
                # Convert month abbreviation to number
                case "$MONTH_NAME" in
                  Jan|January) MONTH_NUM="01" ;;
                  Feb|February) MONTH_NUM="02" ;;
                  Mar|March) MONTH_NUM="03" ;;
                  Apr|April) MONTH_NUM="04" ;;
                  May) MONTH_NUM="05" ;;
                  Jun|June) MONTH_NUM="06" ;;
                  Jul|July) MONTH_NUM="07" ;;
                  Aug|August) MONTH_NUM="08" ;;
                  Sep|September) MONTH_NUM="09" ;;
                  Oct|October) MONTH_NUM="10" ;;
                  Nov|November) MONTH_NUM="11" ;;
                  Dec|December) MONTH_NUM="12" ;;
                  *) 
                    echo "ERROR: Could not parse month: '$MONTH_NAME'"
                    echo "Expected: Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec"
                    echo "Or full names: January, February, etc."
                    exit 1
                    ;;
                esac
                
                # Validate day (1-31)
                if ! [[ "$DAY_NUM" =~ ^[0-9]+$ ]] || [ "$DAY_NUM" -lt 1 ] || [ "$DAY_NUM" -gt 31 ]; then
                  echo "ERROR: Invalid day: '$DAY_NUM' (must be 1-31)"
                  exit 1
                fi
                
                # Validate year (reasonable range)
                if ! [[ "$YEAR_NUM" =~ ^[0-9]{4}$ ]] || [ "$YEAR_NUM" -lt 2020 ] || [ "$YEAR_NUM" -gt 2030 ]; then
                  echo "ERROR: Invalid year: '$YEAR_NUM' (must be 2020-2030)"
                  exit 1
                fi
                
                # Format as YYYY-MM-DD with zero padding
                FORMATTED_DATE=$(printf "%04d-%02d-%02d" "$YEAR_NUM" "$MONTH_NUM" "$DAY_NUM")
                echo "DEBUG: Manual parsing result: $FORMATTED_DATE"
                
              else
                echo "ERROR: Date format not recognized: '$DATE_CLEAN'"
                echo "Expected format: 'Jun 8, 2025' or 'June 8, 2025'"
                echo "Received: '$DATE'"
                exit 1
              fi
            fi
          else
            echo "ERROR: No date provided"
            exit 1
          fi
          
          # Final validation of formatted date
          if ! echo "$FORMATTED_DATE" | grep -qE "^[0-9]{4}-[0-9]{2}-[0-9]{2}$"; then
            echo "ERROR: Invalid formatted date: '$FORMATTED_DATE'"
            echo "Expected format: YYYY-MM-DD"
            exit 1
          fi
          
          # Additional sanity check - verify it's a valid date
          if ! date -d "$FORMATTED_DATE" >/dev/null 2>&1; then
            echo "ERROR: '$FORMATTED_DATE' is not a valid date"
            exit 1
          fi
          
          echo "formatted_date=$FORMATTED_DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Final formatted date: $FORMATTED_DATE"
          
      - name: Extract and validate CSS content
        id: css
        run: |
          echo "DEBUG: Extracting CSS content for ${{ steps.operation.outputs.type }} operation"
          
          # For GitHub issue forms, the CSS content is in the issue body
          # Look for CSS code blocks or direct CSS content
          
          # Method 1: Look for CSS content in code blocks (```css ... ```)
          if sed -n '/```css/,/```/p' issue_body.txt | sed '1d;$d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
            echo "DEBUG: Found CSS in code blocks"
          else
            # Method 2: Look for CSS content in HTML style blocks
            if grep -A 50 -B 5 "<style>" issue_body.txt | sed '/^--$/d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
              echo "DEBUG: Found CSS with <style> tags"
            else
              # Method 3: Look for any CSS-like content (fallback)
              if grep -A 20 -i "css\|style" issue_body.txt | grep -E "(background|width|height|margin|padding|color)" > css_content_raw.txt && [ -s css_content_raw.txt ]; then
                echo "DEBUG: Found CSS-like content"
              else
                echo "ERROR: No CSS content found in issue"
                echo "DEBUG: Issue body for troubleshooting:"
                echo "--- ISSUE BODY START ---"
                cat issue_body.txt
                echo "--- ISSUE BODY END ---"
                echo ""
                echo "Expected: CSS code in \`\`\`css blocks or <style> tags"
                exit 1
              fi
            fi
          fi
          
          # Clean up the CSS content
          # Remove empty lines and clean up formatting
          sed '/^[[:space:]]*$/d' css_content_raw.txt > css_content.txt
          
          # Validate CSS content exists after cleaning
          if [ ! -s css_content.txt ]; then
            echo "ERROR: CSS content is empty after processing"
            echo "DEBUG: Raw CSS content was:"
            cat css_content_raw.txt
            exit 1
          fi
          
          echo "DEBUG: CSS content extracted successfully:"
          echo "--- CSS CONTENT START ---"
          head -10 css_content.txt
          if [ $(wc -l < css_content.txt) -gt 10 ]; then
            echo "... (truncated, total lines: $(wc -l < css_content.txt))"
          fi
          echo "--- CSS CONTENT END ---"
          
          # Count versions by counting ---VERSION--- separators
          VERSION_COUNT=$(grep -c "---VERSION---" css_content.txt 2>/dev/null || echo 0)
          VERSION_COUNT=$((VERSION_COUNT + 1))
          echo "version_count=$VERSION_COUNT" >> $GITHUB_OUTPUT
          echo "DEBUG: Found $VERSION_COUNT CSS versions"
          
      - name: Create directory structure
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          echo "DEBUG: Creating directory: $TARGET_DIR"
          
          mkdir -p "$TARGET_DIR"
          
          # Verify directory creation
          if [ ! -d "$TARGET_DIR" ]; then
            echo "ERROR: Failed to create directory: $TARGET_DIR"
            exit 1
          fi
          
          echo "DEBUG: Directory created successfully"
          ls -la daily-targets/
          
      - name: Create or update solutions file
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          SOLUTIONS_FILE="$TARGET_DIR/solutions.html"
          
          echo "DEBUG: Processing solutions file: $SOLUTIONS_FILE"
          
          # Clean CSS content - remove ```css and ``` markers, keep only the actual CSS
          sed -e '/^```css$/d' -e '/^```$/d' css_content.txt > css_cleaned.txt
          
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "Creating new solutions file..."
            
            # Start with Version 1 comment
            echo "<!-- Version 1 -->" > "$SOLUTIONS_FILE"
            
            # Process CSS content with version separation
            version_num=1
            while IFS= read -r line || [ -n "$line" ]; do
              if [[ "$line" == "---VERSION---" ]]; then
                # Close current version and start new one
                echo "</style>" >> "$SOLUTIONS_FILE"
                echo "" >> "$SOLUTIONS_FILE"
                version_num=$((version_num + 1))
                echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
              else
                echo "$line" >> "$SOLUTIONS_FILE"
              fi
            done < css_cleaned.txt
            
            # Ensure file ends with </style>
            if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
              echo "</style>" >> "$SOLUTIONS_FILE"
            fi
            
          else
            echo "Updating existing solutions file..."
            
            if [ ! -f "$SOLUTIONS_FILE" ]; then
              echo "ERROR: Solutions file not found: $SOLUTIONS_FILE"
              echo "Available dates:"
              ls daily-targets/ 2>/dev/null || echo "No existing solutions found"
              exit 1
            fi
            
            case "${{ steps.extract.outputs.update_type }}" in
              "Add new CSS version(s)")
                echo "Adding new CSS versions..."
                # Find last version number
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                # Ensure file ends with </style>
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              "Replace existing CSS version(s)")
                if [ -n "${{ steps.extract.outputs.version_number }}" ]; then
                  echo "Note: Version replacement is complex and not fully implemented"
                  echo "Adding as new version instead..."
                  LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                  NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                  
                  echo "" >> "$SOLUTIONS_FILE"
                  echo "<!-- Version $NEXT_VERSION (replacement for Version ${{ steps.extract.outputs.version_number }}) -->" >> "$SOLUTIONS_FILE"
                  
                  # Add cleaned CSS content
                  cat css_cleaned.txt >> "$SOLUTIONS_FILE"
                  
                  if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                    echo "</style>" >> "$SOLUTIONS_FILE"
                  fi
                else
                  echo "ERROR: Version number required for replacement"
                  exit 1
                fi
                ;;
                
              "Add new comparison image(s)")
                echo "Images will be processed in next step..."
                ;;
                
              "Add both CSS and images")
                echo "Adding new CSS versions and images..."
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              *)
                echo "ERROR: Unknown update type: ${{ steps.extract.outputs.update_type }}"
                exit 1
                ;;
            esac
          fi
          
          echo "Solutions file processing complete"
          echo "DEBUG: Final solutions file content:"
          cat "$SOLUTIONS_FILE"
          
      - name: Download and process images
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          ISSUE_NUM="${{ github.event.issue.number }}"
          
          echo "DEBUG: Processing images for issue #$ISSUE_NUM"
          echo "DEBUG: Target directory: $TARGET_DIR"
          
          # Determine next available image number
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            NEXT_NUM=1
          else
            # Find existing images and get next number
            EXISTING_IMAGES=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | sort)
            if [ -n "$EXISTING_IMAGES" ]; then
              LAST_NUM=$(echo "$EXISTING_IMAGES" | sed 's/.*target-\([0-9]\+\)-comparison\..*/\1/' | sort -n | tail -1)
              NEXT_NUM=$((LAST_NUM + 1))
              echo "DEBUG: Found existing images, starting from number: $NEXT_NUM"
            else
              NEXT_NUM=1
              echo "DEBUG: No existing images found, starting from: $NEXT_NUM"
            fi
          fi
          
          # Get the full issue data including uploaded assets
          echo "DEBUG: Fetching issue data..."
          gh issue view "$ISSUE_NUM" --repo "${{ github.repository }}" --json body,url > issue_data.json
          
          # Debug: Show what we got
          echo "DEBUG: Issue data received:"
          cat issue_data.json
          
          # Extract the issue body
          ISSUE_BODY=$(jq -r '.body' issue_data.json)
          echo "DEBUG: Issue body extracted, length: ${#ISSUE_BODY}"
          
          # Save issue body for debugging
          echo "$ISSUE_BODY" > issue_body_full.txt
          echo "DEBUG: Full issue body saved to file"
          
          # Look for multiple image URL patterns that GitHub uses
          echo "DEBUG: Searching for image URLs..."
          
          # Clear any existing image URLs file
          > image_urls.txt
          
          # Pattern 1: GitHub user content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 2: GitHub assets URLs  
          echo "$ISSUE_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/assets/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 3: Generic GitHub content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://[^.]*\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 4: Any https image URLs (broader catch)
          echo "$ISSUE_BODY" | grep -oE 'https://[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Remove duplicates and empty lines
          if [ -f image_urls.txt ]; then
            sort image_urls.txt | uniq | grep -v '^$' > image_urls_clean.txt || touch image_urls_clean.txt
            mv image_urls_clean.txt image_urls.txt
          else
            touch image_urls.txt
          fi
          
          echo "DEBUG: Found image URLs:"
          cat image_urls.txt
          
          # Count images found
          IMAGE_COUNT=$(wc -l < image_urls.txt)
          echo "DEBUG: Total unique image URLs found: $IMAGE_COUNT"
          
          # Download each image with enhanced error handling
          if [ -s image_urls.txt ] && [ "$IMAGE_COUNT" -gt 0 ]; then
            echo "Found $IMAGE_COUNT image(s) to download"
            
            while IFS= read -r img_url; do
              if [ -n "$img_url" ]; then
                echo "DEBUG: Processing URL: $img_url"
                
                # Extract file extension
                ext=$(echo "$img_url" | grep -oE '\.(png|jpg|jpeg|gif|webp)$' | head -1)
                if [ -z "$ext" ]; then
                  ext=".png"  # Default extension
                  echo "DEBUG: No extension found, defaulting to .png"
                fi
                
                filename="target-${NEXT_NUM}-comparison${ext}"
                filepath="$TARGET_DIR/$filename"
                
                echo "Downloading: $img_url"
                echo "         to: $filename"
                
                # Try multiple download methods
                DOWNLOAD_SUCCESS=false
                
                # Method 1: With GitHub token (for private repos)
                if curl -L -f -s \
                        -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                        -H "User-Agent: GitHub-Actions" \
                        -H "Accept: application/vnd.github.v3+json" \
                        "$img_url" -o "$filepath" 2>/dev/null; then
                  DOWNLOAD_SUCCESS=true
                  echo "âœ… Downloaded with GitHub token"
                fi
                
                # Method 2: Without token (for public URLs)
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if curl -L -f -s \
                          -H "User-Agent: Mozilla/5.0 (GitHub Actions)" \
                          "$img_url" -o "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded without token"
                  fi
                fi
                
                # Method 3: Using wget as fallback
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if wget -q --timeout=30 --tries=2 \
                          --header="User-Agent: GitHub-Actions" \
                          "$img_url" -O "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded with wget"
                  fi
                fi
                
                # Verify download
                if [ "$DOWNLOAD_SUCCESS" = true ] && [ -f "$filepath" ] && [ -s "$filepath" ]; then
                  # Check if it's actually an image file
                  file_type=$(file "$filepath" 2>/dev/null || echo "unknown")
                  if echo "$file_type" | grep -qi "image\|png\|jpeg\|gif\|webp"; then
                    echo "âœ… Successfully downloaded and verified: $filename"
                    echo "   File type: $file_type"
                    echo "   File size: $(du -h "$filepath" | cut -f1)"
                    NEXT_NUM=$((NEXT_NUM + 1))
                  else
                    echo "âŒ Downloaded file is not an image: $filename"
                    echo "   File type detected: $file_type"
                    rm -f "$filepath"
                  fi
                else
                  echo "âŒ Failed to download: $img_url"
                  [ -f "$filepath" ] && rm -f "$filepath"
                fi
                
                echo "---"
              fi
            done < image_urls.txt
          else
            echo "No images found in issue body"
            echo "DEBUG: This could mean:"
            echo "  - No images were uploaded to the issue"
            echo "  - Images are in a format/location we're not detecting"
            echo "  - The issue template format is different than expected"
          fi
          
          # Summary
          FINAL_IMAGE_COUNT=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | wc -l)
          echo ""
          echo "SUMMARY:"
          echo "  Images found in issue: $IMAGE_COUNT"
          echo "  Images successfully downloaded: $FINAL_IMAGE_COUNT"
          echo "  Images saved in: $TARGET_DIR"
          
          if [ "$FINAL_IMAGE_COUNT" -gt 0 ]; then
            echo "  Downloaded files:"
            find "$TARGET_DIR" -name "target-*-comparison.*" | sort
          fi
          
      - name: Generate LinkedIn post
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          LINKEDIN_FILE="$TARGET_DIR/linkedin-post.md"
          
          # Extract additional notes based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            # For GitHub issue forms, look for the "Additional Notes" content
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "additional.*notes\|notes\|description" | grep -v -i "additional.*notes\|notes\|description" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          else
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "update.*notes\|notes" | grep -v -i "update.*notes\|notes" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          fi
          
          # Clean up additional notes - remove empty content
          ADDITIONAL_NOTES=$(echo "$ADDITIONAL_NOTES" | xargs)
          
          # If no additional notes found, create a default description
          if [ -z "$ADDITIONAL_NOTES" ]; then
            if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
              ADDITIONAL_NOTES="Another CSS challenge completed! ðŸŽ¯"
            else
              ADDITIONAL_NOTES="Updated my CSS solution with improvements! ðŸš€"
            fi
          fi
          
          # Generate the repository URL for the solutions.html file
          REPO_URL="https://github.com/${{ github.repository }}"
          SOLUTIONS_URL="$REPO_URL/blob/main/daily-targets/${{ steps.date.outputs.formatted_date }}/solutions.html"
          
          # Create LinkedIn post with the exact format requested
          cat > "$LINKEDIN_FILE" << EOF
# LinkedIn Post for ${{ steps.date.outputs.formatted_date }}

---

Today's CSSBattle solution:

$ADDITIONAL_NOTES

$SOLUTIONS_URL

(My journal notes.)

#cssgang #CSS #CSSBattle #HTML
EOF
          
          echo "LinkedIn post generated successfully"
          echo "DEBUG: LinkedIn post content:"
          cat "$LINKEDIN_FILE"
          
      - name: Commit and push changes
        run: |
          # Configure git
          git config --local user.email "${GIT_USER_EMAIL:-${{ github.actor }}@users.noreply.github.com}"
          git config --local user.name "${GIT_USER_NAME:-${{ github.actor }}}"
          
          # Check if there are changes to commit
          git add .
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "has_changes=false" >> $GITHUB_ENV
          else
            # Pull latest changes to avoid conflicts
            echo "Pulling latest changes..."
            git fetch origin
            git rebase origin/main || {
              echo "Rebase failed, trying merge strategy..." > image_urls_clean.txt || touch image_urls_clean.txt
            mv image_urls_clean.txt image_urls.txt
          else
            touch image_urls.txt
          fi
          
          echo "DEBUG: Found image URLs:"
          cat image_urls.txt
          
          # Count images found
          IMAGE_COUNT=$(wc -l < image_urls.txt)
          echo "DEBUG: Total unique image URLs found: $IMAGE_COUNT"
          
          # Download each image with enhanced error handling
          if [ -s image_urls.txt ] && [ "$IMAGE_COUNT" -gt 0 ]; then
            echo "Found $IMAGE_COUNT image(s) to download"
            
            while IFS= read -r img_url; do
              if [ -n "$img_url" ]; then
                echo "DEBUG: Processing URL: $img_url"
                
                # Extract file extension
                ext=$(echo "$img_url" | grep -oE '\.(png|jpg|jpeg|gif|webp)name: Create or Update Solutions File for Daily CSSBattle
on:
  issues:
    types: [opened]

permissions:
  contents: write
  issues: write
  
jobs:
  process-solutions-file:
    runs-on: ubuntu-latest
    if: contains(github.event.issue.title, '[CSSBattle]') || contains(github.event.issue.title, '[CSSBattle-UPDATE]')
    
    env:
      GIT_USER_EMAIL: ${{ secrets.GIT_USER_EMAIL }}
      GIT_USER_NAME: ${{ secrets.GIT_USER_NAME }}
    
    steps:
      - name: Debug trigger conditions
        run: |
          echo "ðŸ” DEBUG: Trigger Analysis"
          echo "Issue title: '${{ github.event.issue.title }}'"
          echo "Issue number: ${{ github.event.issue.number }}"
          echo "Issue author: ${{ github.event.issue.user.login }}"
          echo "Repository: ${{ github.repository }}"
          echo "Event action: ${{ github.event.action }}"
          echo ""
          echo "ðŸ” Checking trigger conditions:"
          if [[ "${{ github.event.issue.title }}" == *"[CSSBattle]"* ]]; then
            echo "âœ… Title contains '[CSSBattle]'"
          else
            echo "âŒ Title does NOT contain '[CSSBattle]'"
          fi
          
          if [[ "${{ github.event.issue.title }}" == *"[CSSBattle-UPDATE]"* ]]; then
            echo "âœ… Title contains '[CSSBattle-UPDATE]'"
          else
            echo "âŒ Title does NOT contain '[CSSBattle-UPDATE]'"
          fi
          echo ""
          
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
      
      - name: Determine operation type
        id: operation
        run: |
          if [[ "${{ github.event.issue.title }}" == *"[CSSBattle-UPDATE]"* ]]; then
            echo "type=update" >> $GITHUB_OUTPUT
            echo "Operation: UPDATE"
          else
            echo "type=create" >> $GITHUB_OUTPUT
            echo "Operation: CREATE"
          fi
      
      - name: Extract and validate issue data
        id: extract
        run: |
          # Save issue body to file for processing
          cat > issue_body.txt << 'EOF'
          ${{ github.event.issue.body }}
          EOF
          
          echo "DEBUG: Issue body content:"
          cat issue_body.txt
          echo "DEBUG: ===== END OF ISSUE BODY ====="
          
          # Validate issue body is not empty
          if [ ! -s issue_body.txt ]; then
            echo "ERROR: Issue body is empty"
            exit 1
          fi
          
          # Extract date based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "DEBUG: Extracting date for CREATE operation"
            
            # GitHub issue forms create structured output, look for the date field
            # The issue body will contain the date value after field processing
            
            # Method 1: Look for date pattern directly (for "Jun 8, 2025" format)
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Method 2: If not found, look for numeric date formats
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{1,2}/[0-9]{1,2}/[0-9]{4}" issue_body.txt | head -1)
            fi
            
            # Method 3: Look for ISO format dates
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{4}-[0-9]{2}-[0-9]{2}" issue_body.txt | head -1)
            fi
            
            # Method 4: Search around common labels (fallback)
            if [ -z "$DATE" ]; then
              # Look for lines that might contain dates after field labels
              DATE=$(grep -A 5 -i "date\|when\|day" issue_body.txt | grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" | head -1)
            fi
            
          else
            echo "DEBUG: Extracting date for UPDATE operation"
            # For update operations, look for target date
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Extract update type and version number (implement as needed for UPDATE template)
            UPDATE_TYPE=$(grep -A 3 -i "update.*type" issue_body.txt | grep -v -i "update.*type" | head -1 | xargs)
            VERSION_NUMBER=$(grep -A 3 -i "version.*number" issue_body.txt | grep -v -i "version.*number" | head -1 | xargs)
            
            echo "update_type=$UPDATE_TYPE" >> $GITHUB_OUTPUT
            echo "version_number=$VERSION_NUMBER" >> $GITHUB_OUTPUT
          fi
          
          echo "parsed_date=$DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Extracted date: '$DATE'"
          
          # Validate date was extracted
          if [ -z "$DATE" ]; then
            echo "ERROR: Could not extract date from issue."
            echo "DEBUG: Issue body for troubleshooting:"
            echo "--- ISSUE BODY START ---"
            cat issue_body.txt
            echo "--- ISSUE BODY END ---"
            echo ""
            echo "Expected format examples:"
            echo "  - Jun 8, 2025"
            echo "  - January 15, 2025"
            echo "  - 6/8/2025"
            echo "  - 2025-06-08"
            exit 1
          fi
          
      - name: Convert and validate date format
        id: date
        run: |
          DATE="${{ steps.extract.outputs.parsed_date }}"
          echo "DEBUG: Converting date: '$DATE'"
          
          # Enhanced date parsing specifically for your formats
          if [ -n "$DATE" ]; then
            # Try GNU date first (handles "Jun 8, 2025" format perfectly)
            if FORMATTED_DATE=$(date -d "$DATE" +%Y-%m-%d 2>/dev/null); then
              echo "DEBUG: Successfully parsed with GNU date: $FORMATTED_DATE"
            else
              echo "DEBUG: GNU date failed, attempting manual parsing for format like 'Jun 8, 2025'"
              
              # Clean up the date string - remove extra spaces and commas
              DATE_CLEAN=$(echo "$DATE" | sed 's/,/ /g' | tr -s ' ' | xargs)
              echo "DEBUG: Cleaned date: '$DATE_CLEAN'"
              
              # Extract components for "Mon D, YYYY" or "Mon D YYYY" format
              if echo "$DATE_CLEAN" | grep -qE "^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2}[[:space:]]+[0-9]{4}$"; then
                
                # Extract month name
                MONTH_NAME=$(echo "$DATE_CLEAN" | cut -d' ' -f1)
                # Extract day
                DAY_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f2)
                # Extract year  
                YEAR_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f3)
                
                echo "DEBUG: Extracted - Month: '$MONTH_NAME', Day: '$DAY_NUM', Year: '$YEAR_NUM'"
                
                # Convert month abbreviation to number
                case "$MONTH_NAME" in
                  Jan|January) MONTH_NUM="01" ;;
                  Feb|February) MONTH_NUM="02" ;;
                  Mar|March) MONTH_NUM="03" ;;
                  Apr|April) MONTH_NUM="04" ;;
                  May) MONTH_NUM="05" ;;
                  Jun|June) MONTH_NUM="06" ;;
                  Jul|July) MONTH_NUM="07" ;;
                  Aug|August) MONTH_NUM="08" ;;
                  Sep|September) MONTH_NUM="09" ;;
                  Oct|October) MONTH_NUM="10" ;;
                  Nov|November) MONTH_NUM="11" ;;
                  Dec|December) MONTH_NUM="12" ;;
                  *) 
                    echo "ERROR: Could not parse month: '$MONTH_NAME'"
                    echo "Expected: Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec"
                    echo "Or full names: January, February, etc."
                    exit 1
                    ;;
                esac
                
                # Validate day (1-31)
                if ! [[ "$DAY_NUM" =~ ^[0-9]+$ ]] || [ "$DAY_NUM" -lt 1 ] || [ "$DAY_NUM" -gt 31 ]; then
                  echo "ERROR: Invalid day: '$DAY_NUM' (must be 1-31)"
                  exit 1
                fi
                
                # Validate year (reasonable range)
                if ! [[ "$YEAR_NUM" =~ ^[0-9]{4}$ ]] || [ "$YEAR_NUM" -lt 2020 ] || [ "$YEAR_NUM" -gt 2030 ]; then
                  echo "ERROR: Invalid year: '$YEAR_NUM' (must be 2020-2030)"
                  exit 1
                fi
                
                # Format as YYYY-MM-DD with zero padding
                FORMATTED_DATE=$(printf "%04d-%02d-%02d" "$YEAR_NUM" "$MONTH_NUM" "$DAY_NUM")
                echo "DEBUG: Manual parsing result: $FORMATTED_DATE"
                
              else
                echo "ERROR: Date format not recognized: '$DATE_CLEAN'"
                echo "Expected format: 'Jun 8, 2025' or 'June 8, 2025'"
                echo "Received: '$DATE'"
                exit 1
              fi
            fi
          else
            echo "ERROR: No date provided"
            exit 1
          fi
          
          # Final validation of formatted date
          if ! echo "$FORMATTED_DATE" | grep -qE "^[0-9]{4}-[0-9]{2}-[0-9]{2}$"; then
            echo "ERROR: Invalid formatted date: '$FORMATTED_DATE'"
            echo "Expected format: YYYY-MM-DD"
            exit 1
          fi
          
          # Additional sanity check - verify it's a valid date
          if ! date -d "$FORMATTED_DATE" >/dev/null 2>&1; then
            echo "ERROR: '$FORMATTED_DATE' is not a valid date"
            exit 1
          fi
          
          echo "formatted_date=$FORMATTED_DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Final formatted date: $FORMATTED_DATE"
          
      - name: Extract and validate CSS content
        id: css
        run: |
          echo "DEBUG: Extracting CSS content for ${{ steps.operation.outputs.type }} operation"
          
          # For GitHub issue forms, the CSS content is in the issue body
          # Look for CSS code blocks or direct CSS content
          
          # Method 1: Look for CSS content in code blocks (```css ... ```)
          if sed -n '/```css/,/```/p' issue_body.txt | sed '1d;$d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
            echo "DEBUG: Found CSS in code blocks"
          else
            # Method 2: Look for CSS content in HTML style blocks
            if grep -A 50 -B 5 "<style>" issue_body.txt | sed '/^--$/d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
              echo "DEBUG: Found CSS with <style> tags"
            else
              # Method 3: Look for any CSS-like content (fallback)
              if grep -A 20 -i "css\|style" issue_body.txt | grep -E "(background|width|height|margin|padding|color)" > css_content_raw.txt && [ -s css_content_raw.txt ]; then
                echo "DEBUG: Found CSS-like content"
              else
                echo "ERROR: No CSS content found in issue"
                echo "DEBUG: Issue body for troubleshooting:"
                echo "--- ISSUE BODY START ---"
                cat issue_body.txt
                echo "--- ISSUE BODY END ---"
                echo ""
                echo "Expected: CSS code in \`\`\`css blocks or <style> tags"
                exit 1
              fi
            fi
          fi
          
          # Clean up the CSS content
          # Remove empty lines and clean up formatting
          sed '/^[[:space:]]*$/d' css_content_raw.txt > css_content.txt
          
          # Validate CSS content exists after cleaning
          if [ ! -s css_content.txt ]; then
            echo "ERROR: CSS content is empty after processing"
            echo "DEBUG: Raw CSS content was:"
            cat css_content_raw.txt
            exit 1
          fi
          
          echo "DEBUG: CSS content extracted successfully:"
          echo "--- CSS CONTENT START ---"
          head -10 css_content.txt
          if [ $(wc -l < css_content.txt) -gt 10 ]; then
            echo "... (truncated, total lines: $(wc -l < css_content.txt))"
          fi
          echo "--- CSS CONTENT END ---"
          
          # Count versions by counting ---VERSION--- separators
          VERSION_COUNT=$(grep -c "---VERSION---" css_content.txt 2>/dev/null || echo 0)
          VERSION_COUNT=$((VERSION_COUNT + 1))
          echo "version_count=$VERSION_COUNT" >> $GITHUB_OUTPUT
          echo "DEBUG: Found $VERSION_COUNT CSS versions"
          
      - name: Create directory structure
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          echo "DEBUG: Creating directory: $TARGET_DIR"
          
          mkdir -p "$TARGET_DIR"
          
          # Verify directory creation
          if [ ! -d "$TARGET_DIR" ]; then
            echo "ERROR: Failed to create directory: $TARGET_DIR"
            exit 1
          fi
          
          echo "DEBUG: Directory created successfully"
          ls -la daily-targets/
          
      - name: Create or update solutions file
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          SOLUTIONS_FILE="$TARGET_DIR/solutions.html"
          
          echo "DEBUG: Processing solutions file: $SOLUTIONS_FILE"
          
          # Clean CSS content - remove ```css and ``` markers, keep only the actual CSS
          sed -e '/^```css$/d' -e '/^```$/d' css_content.txt > css_cleaned.txt
          
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "Creating new solutions file..."
            
            # Start with Version 1 comment
            echo "<!-- Version 1 -->" > "$SOLUTIONS_FILE"
            
            # Process CSS content with version separation
            version_num=1
            while IFS= read -r line || [ -n "$line" ]; do
              if [[ "$line" == "---VERSION---" ]]; then
                # Close current version and start new one
                echo "</style>" >> "$SOLUTIONS_FILE"
                echo "" >> "$SOLUTIONS_FILE"
                version_num=$((version_num + 1))
                echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
              else
                echo "$line" >> "$SOLUTIONS_FILE"
              fi
            done < css_cleaned.txt
            
            # Ensure file ends with </style>
            if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
              echo "</style>" >> "$SOLUTIONS_FILE"
            fi
            
          else
            echo "Updating existing solutions file..."
            
            if [ ! -f "$SOLUTIONS_FILE" ]; then
              echo "ERROR: Solutions file not found: $SOLUTIONS_FILE"
              echo "Available dates:"
              ls daily-targets/ 2>/dev/null || echo "No existing solutions found"
              exit 1
            fi
            
            case "${{ steps.extract.outputs.update_type }}" in
              "Add new CSS version(s)")
                echo "Adding new CSS versions..."
                # Find last version number
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                # Ensure file ends with </style>
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              "Replace existing CSS version(s)")
                if [ -n "${{ steps.extract.outputs.version_number }}" ]; then
                  echo "Note: Version replacement is complex and not fully implemented"
                  echo "Adding as new version instead..."
                  LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                  NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                  
                  echo "" >> "$SOLUTIONS_FILE"
                  echo "<!-- Version $NEXT_VERSION (replacement for Version ${{ steps.extract.outputs.version_number }}) -->" >> "$SOLUTIONS_FILE"
                  
                  # Add cleaned CSS content
                  cat css_cleaned.txt >> "$SOLUTIONS_FILE"
                  
                  if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                    echo "</style>" >> "$SOLUTIONS_FILE"
                  fi
                else
                  echo "ERROR: Version number required for replacement"
                  exit 1
                fi
                ;;
                
              "Add new comparison image(s)")
                echo "Images will be processed in next step..."
                ;;
                
              "Add both CSS and images")
                echo "Adding new CSS versions and images..."
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              *)
                echo "ERROR: Unknown update type: ${{ steps.extract.outputs.update_type }}"
                exit 1
                ;;
            esac
          fi
          
          echo "Solutions file processing complete"
          echo "DEBUG: Final solutions file content:"
          cat "$SOLUTIONS_FILE"
          
      - name: Download and process images
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          ISSUE_NUM="${{ github.event.issue.number }}"
          
          echo "DEBUG: Processing images for issue #$ISSUE_NUM"
          echo "DEBUG: Target directory: $TARGET_DIR"
          
          # Determine next available image number
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            NEXT_NUM=1
          else
            # Find existing images and get next number
            EXISTING_IMAGES=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | sort)
            if [ -n "$EXISTING_IMAGES" ]; then
              LAST_NUM=$(echo "$EXISTING_IMAGES" | sed 's/.*target-\([0-9]\+\)-comparison\..*/\1/' | sort -n | tail -1)
              NEXT_NUM=$((LAST_NUM + 1))
              echo "DEBUG: Found existing images, starting from number: $NEXT_NUM"
            else
              NEXT_NUM=1
              echo "DEBUG: No existing images found, starting from: $NEXT_NUM"
            fi
          fi
          
          # Get the full issue data including uploaded assets
          echo "DEBUG: Fetching issue data..."
          gh issue view "$ISSUE_NUM" --repo "${{ github.repository }}" --json body,url > issue_data.json
          
          # Debug: Show what we got
          echo "DEBUG: Issue data received:"
          cat issue_data.json
          
          # Extract the issue body
          ISSUE_BODY=$(jq -r '.body' issue_data.json)
          echo "DEBUG: Issue body extracted, length: ${#ISSUE_BODY}"
          
          # Save issue body for debugging
          echo "$ISSUE_BODY" > issue_body_full.txt
          echo "DEBUG: Full issue body saved to file"
          
          # Look for multiple image URL patterns that GitHub uses
          echo "DEBUG: Searching for image URLs..."
          
          # Clear any existing image URLs file
          > image_urls.txt
          
          # Pattern 1: GitHub user content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 2: GitHub assets URLs  
          echo "$ISSUE_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/assets/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 3: Generic GitHub content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://[^.]*\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 4: Any https image URLs (broader catch)
          echo "$ISSUE_BODY" | grep -oE 'https://[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Remove duplicates and empty lines
          if [ -f image_urls.txt ]; then
            sort image_urls.txt | uniq | grep -v '^name: Create or Update Solutions File for Daily CSSBattle
on:
  issues:
    types: [opened]

permissions:
  contents: write
  issues: write
  
jobs:
  process-solutions-file:
    runs-on: ubuntu-latest
    if: contains(github.event.issue.title, '[CSSBattle]') || contains(github.event.issue.title, '[CSSBattle-UPDATE]')
    
    env:
      GIT_USER_EMAIL: ${{ secrets.GIT_USER_EMAIL }}
      GIT_USER_NAME: ${{ secrets.GIT_USER_NAME }}
    
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
      
      - name: Determine operation type
        id: operation
        run: |
          if [[ "${{ github.event.issue.title }}" == *"[CSSBattle-UPDATE]"* ]]; then
            echo "type=update" >> $GITHUB_OUTPUT
            echo "Operation: UPDATE"
          else
            echo "type=create" >> $GITHUB_OUTPUT
            echo "Operation: CREATE"
          fi
      
      - name: Extract and validate issue data
        id: extract
        run: |
          # Save issue body to file for processing
          cat > issue_body.txt << 'EOF'
          ${{ github.event.issue.body }}
          EOF
          
          echo "DEBUG: Issue body content:"
          cat issue_body.txt
          echo "DEBUG: ===== END OF ISSUE BODY ====="
          
          # Validate issue body is not empty
          if [ ! -s issue_body.txt ]; then
            echo "ERROR: Issue body is empty"
            exit 1
          fi
          
          # Extract date based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "DEBUG: Extracting date for CREATE operation"
            
            # GitHub issue forms create structured output, look for the date field
            # The issue body will contain the date value after field processing
            
            # Method 1: Look for date pattern directly (for "Jun 8, 2025" format)
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Method 2: If not found, look for numeric date formats
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{1,2}/[0-9]{1,2}/[0-9]{4}" issue_body.txt | head -1)
            fi
            
            # Method 3: Look for ISO format dates
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{4}-[0-9]{2}-[0-9]{2}" issue_body.txt | head -1)
            fi
            
            # Method 4: Search around common labels (fallback)
            if [ -z "$DATE" ]; then
              # Look for lines that might contain dates after field labels
              DATE=$(grep -A 5 -i "date\|when\|day" issue_body.txt | grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" | head -1)
            fi
            
          else
            echo "DEBUG: Extracting date for UPDATE operation"
            # For update operations, look for target date
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Extract update type and version number (implement as needed for UPDATE template)
            UPDATE_TYPE=$(grep -A 3 -i "update.*type" issue_body.txt | grep -v -i "update.*type" | head -1 | xargs)
            VERSION_NUMBER=$(grep -A 3 -i "version.*number" issue_body.txt | grep -v -i "version.*number" | head -1 | xargs)
            
            echo "update_type=$UPDATE_TYPE" >> $GITHUB_OUTPUT
            echo "version_number=$VERSION_NUMBER" >> $GITHUB_OUTPUT
          fi
          
          echo "parsed_date=$DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Extracted date: '$DATE'"
          
          # Validate date was extracted
          if [ -z "$DATE" ]; then
            echo "ERROR: Could not extract date from issue."
            echo "DEBUG: Issue body for troubleshooting:"
            echo "--- ISSUE BODY START ---"
            cat issue_body.txt
            echo "--- ISSUE BODY END ---"
            echo ""
            echo "Expected format examples:"
            echo "  - Jun 8, 2025"
            echo "  - January 15, 2025"
            echo "  - 6/8/2025"
            echo "  - 2025-06-08"
            exit 1
          fi
          
      - name: Convert and validate date format
        id: date
        run: |
          DATE="${{ steps.extract.outputs.parsed_date }}"
          echo "DEBUG: Converting date: '$DATE'"
          
          # Enhanced date parsing specifically for your formats
          if [ -n "$DATE" ]; then
            # Try GNU date first (handles "Jun 8, 2025" format perfectly)
            if FORMATTED_DATE=$(date -d "$DATE" +%Y-%m-%d 2>/dev/null); then
              echo "DEBUG: Successfully parsed with GNU date: $FORMATTED_DATE"
            else
              echo "DEBUG: GNU date failed, attempting manual parsing for format like 'Jun 8, 2025'"
              
              # Clean up the date string - remove extra spaces and commas
              DATE_CLEAN=$(echo "$DATE" | sed 's/,/ /g' | tr -s ' ' | xargs)
              echo "DEBUG: Cleaned date: '$DATE_CLEAN'"
              
              # Extract components for "Mon D, YYYY" or "Mon D YYYY" format
              if echo "$DATE_CLEAN" | grep -qE "^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2}[[:space:]]+[0-9]{4}$"; then
                
                # Extract month name
                MONTH_NAME=$(echo "$DATE_CLEAN" | cut -d' ' -f1)
                # Extract day
                DAY_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f2)
                # Extract year  
                YEAR_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f3)
                
                echo "DEBUG: Extracted - Month: '$MONTH_NAME', Day: '$DAY_NUM', Year: '$YEAR_NUM'"
                
                # Convert month abbreviation to number
                case "$MONTH_NAME" in
                  Jan|January) MONTH_NUM="01" ;;
                  Feb|February) MONTH_NUM="02" ;;
                  Mar|March) MONTH_NUM="03" ;;
                  Apr|April) MONTH_NUM="04" ;;
                  May) MONTH_NUM="05" ;;
                  Jun|June) MONTH_NUM="06" ;;
                  Jul|July) MONTH_NUM="07" ;;
                  Aug|August) MONTH_NUM="08" ;;
                  Sep|September) MONTH_NUM="09" ;;
                  Oct|October) MONTH_NUM="10" ;;
                  Nov|November) MONTH_NUM="11" ;;
                  Dec|December) MONTH_NUM="12" ;;
                  *) 
                    echo "ERROR: Could not parse month: '$MONTH_NAME'"
                    echo "Expected: Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec"
                    echo "Or full names: January, February, etc."
                    exit 1
                    ;;
                esac
                
                # Validate day (1-31)
                if ! [[ "$DAY_NUM" =~ ^[0-9]+$ ]] || [ "$DAY_NUM" -lt 1 ] || [ "$DAY_NUM" -gt 31 ]; then
                  echo "ERROR: Invalid day: '$DAY_NUM' (must be 1-31)"
                  exit 1
                fi
                
                # Validate year (reasonable range)
                if ! [[ "$YEAR_NUM" =~ ^[0-9]{4}$ ]] || [ "$YEAR_NUM" -lt 2020 ] || [ "$YEAR_NUM" -gt 2030 ]; then
                  echo "ERROR: Invalid year: '$YEAR_NUM' (must be 2020-2030)"
                  exit 1
                fi
                
                # Format as YYYY-MM-DD with zero padding
                FORMATTED_DATE=$(printf "%04d-%02d-%02d" "$YEAR_NUM" "$MONTH_NUM" "$DAY_NUM")
                echo "DEBUG: Manual parsing result: $FORMATTED_DATE"
                
              else
                echo "ERROR: Date format not recognized: '$DATE_CLEAN'"
                echo "Expected format: 'Jun 8, 2025' or 'June 8, 2025'"
                echo "Received: '$DATE'"
                exit 1
              fi
            fi
          else
            echo "ERROR: No date provided"
            exit 1
          fi
          
          # Final validation of formatted date
          if ! echo "$FORMATTED_DATE" | grep -qE "^[0-9]{4}-[0-9]{2}-[0-9]{2}$"; then
            echo "ERROR: Invalid formatted date: '$FORMATTED_DATE'"
            echo "Expected format: YYYY-MM-DD"
            exit 1
          fi
          
          # Additional sanity check - verify it's a valid date
          if ! date -d "$FORMATTED_DATE" >/dev/null 2>&1; then
            echo "ERROR: '$FORMATTED_DATE' is not a valid date"
            exit 1
          fi
          
          echo "formatted_date=$FORMATTED_DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Final formatted date: $FORMATTED_DATE"
          
      - name: Extract and validate CSS content
        id: css
        run: |
          echo "DEBUG: Extracting CSS content for ${{ steps.operation.outputs.type }} operation"
          
          # For GitHub issue forms, the CSS content is in the issue body
          # Look for CSS code blocks or direct CSS content
          
          # Method 1: Look for CSS content in code blocks (```css ... ```)
          if sed -n '/```css/,/```/p' issue_body.txt | sed '1d;$d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
            echo "DEBUG: Found CSS in code blocks"
          else
            # Method 2: Look for CSS content in HTML style blocks
            if grep -A 50 -B 5 "<style>" issue_body.txt | sed '/^--$/d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
              echo "DEBUG: Found CSS with <style> tags"
            else
              # Method 3: Look for any CSS-like content (fallback)
              if grep -A 20 -i "css\|style" issue_body.txt | grep -E "(background|width|height|margin|padding|color)" > css_content_raw.txt && [ -s css_content_raw.txt ]; then
                echo "DEBUG: Found CSS-like content"
              else
                echo "ERROR: No CSS content found in issue"
                echo "DEBUG: Issue body for troubleshooting:"
                echo "--- ISSUE BODY START ---"
                cat issue_body.txt
                echo "--- ISSUE BODY END ---"
                echo ""
                echo "Expected: CSS code in \`\`\`css blocks or <style> tags"
                exit 1
              fi
            fi
          fi
          
          # Clean up the CSS content
          # Remove empty lines and clean up formatting
          sed '/^[[:space:]]*$/d' css_content_raw.txt > css_content.txt
          
          # Validate CSS content exists after cleaning
          if [ ! -s css_content.txt ]; then
            echo "ERROR: CSS content is empty after processing"
            echo "DEBUG: Raw CSS content was:"
            cat css_content_raw.txt
            exit 1
          fi
          
          echo "DEBUG: CSS content extracted successfully:"
          echo "--- CSS CONTENT START ---"
          head -10 css_content.txt
          if [ $(wc -l < css_content.txt) -gt 10 ]; then
            echo "... (truncated, total lines: $(wc -l < css_content.txt))"
          fi
          echo "--- CSS CONTENT END ---"
          
          # Count versions by counting ---VERSION--- separators
          VERSION_COUNT=$(grep -c "---VERSION---" css_content.txt 2>/dev/null || echo 0)
          VERSION_COUNT=$((VERSION_COUNT + 1))
          echo "version_count=$VERSION_COUNT" >> $GITHUB_OUTPUT
          echo "DEBUG: Found $VERSION_COUNT CSS versions"
          
      - name: Create directory structure
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          echo "DEBUG: Creating directory: $TARGET_DIR"
          
          mkdir -p "$TARGET_DIR"
          
          # Verify directory creation
          if [ ! -d "$TARGET_DIR" ]; then
            echo "ERROR: Failed to create directory: $TARGET_DIR"
            exit 1
          fi
          
          echo "DEBUG: Directory created successfully"
          ls -la daily-targets/
          
      - name: Create or update solutions file
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          SOLUTIONS_FILE="$TARGET_DIR/solutions.html"
          
          echo "DEBUG: Processing solutions file: $SOLUTIONS_FILE"
          
          # Clean CSS content - remove ```css and ``` markers, keep only the actual CSS
          sed -e '/^```css$/d' -e '/^```$/d' css_content.txt > css_cleaned.txt
          
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "Creating new solutions file..."
            
            # Start with Version 1 comment
            echo "<!-- Version 1 -->" > "$SOLUTIONS_FILE"
            
            # Process CSS content with version separation
            version_num=1
            while IFS= read -r line || [ -n "$line" ]; do
              if [[ "$line" == "---VERSION---" ]]; then
                # Close current version and start new one
                echo "</style>" >> "$SOLUTIONS_FILE"
                echo "" >> "$SOLUTIONS_FILE"
                version_num=$((version_num + 1))
                echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
              else
                echo "$line" >> "$SOLUTIONS_FILE"
              fi
            done < css_cleaned.txt
            
            # Ensure file ends with </style>
            if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
              echo "</style>" >> "$SOLUTIONS_FILE"
            fi
            
          else
            echo "Updating existing solutions file..."
            
            if [ ! -f "$SOLUTIONS_FILE" ]; then
              echo "ERROR: Solutions file not found: $SOLUTIONS_FILE"
              echo "Available dates:"
              ls daily-targets/ 2>/dev/null || echo "No existing solutions found"
              exit 1
            fi
            
            case "${{ steps.extract.outputs.update_type }}" in
              "Add new CSS version(s)")
                echo "Adding new CSS versions..."
                # Find last version number
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                # Ensure file ends with </style>
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              "Replace existing CSS version(s)")
                if [ -n "${{ steps.extract.outputs.version_number }}" ]; then
                  echo "Note: Version replacement is complex and not fully implemented"
                  echo "Adding as new version instead..."
                  LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                  NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                  
                  echo "" >> "$SOLUTIONS_FILE"
                  echo "<!-- Version $NEXT_VERSION (replacement for Version ${{ steps.extract.outputs.version_number }}) -->" >> "$SOLUTIONS_FILE"
                  
                  # Add cleaned CSS content
                  cat css_cleaned.txt >> "$SOLUTIONS_FILE"
                  
                  if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                    echo "</style>" >> "$SOLUTIONS_FILE"
                  fi
                else
                  echo "ERROR: Version number required for replacement"
                  exit 1
                fi
                ;;
                
              "Add new comparison image(s)")
                echo "Images will be processed in next step..."
                ;;
                
              "Add both CSS and images")
                echo "Adding new CSS versions and images..."
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              *)
                echo "ERROR: Unknown update type: ${{ steps.extract.outputs.update_type }}"
                exit 1
                ;;
            esac
          fi
          
          echo "Solutions file processing complete"
          echo "DEBUG: Final solutions file content:"
          cat "$SOLUTIONS_FILE"
          
      - name: Download and process images
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          ISSUE_NUM="${{ github.event.issue.number }}"
          
          echo "DEBUG: Processing images for issue #$ISSUE_NUM"
          echo "DEBUG: Target directory: $TARGET_DIR"
          
          # Determine next available image number
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            NEXT_NUM=1
          else
            # Find existing images and get next number
            EXISTING_IMAGES=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | sort)
            if [ -n "$EXISTING_IMAGES" ]; then
              LAST_NUM=$(echo "$EXISTING_IMAGES" | sed 's/.*target-\([0-9]\+\)-comparison\..*/\1/' | sort -n | tail -1)
              NEXT_NUM=$((LAST_NUM + 1))
              echo "DEBUG: Found existing images, starting from number: $NEXT_NUM"
            else
              NEXT_NUM=1
              echo "DEBUG: No existing images found, starting from: $NEXT_NUM"
            fi
          fi
          
          # Get the full issue data including uploaded assets
          echo "DEBUG: Fetching issue data..."
          gh issue view "$ISSUE_NUM" --repo "${{ github.repository }}" --json body,url > issue_data.json
          
          # Debug: Show what we got
          echo "DEBUG: Issue data received:"
          cat issue_data.json
          
          # Extract the issue body
          ISSUE_BODY=$(jq -r '.body' issue_data.json)
          echo "DEBUG: Issue body extracted, length: ${#ISSUE_BODY}"
          
          # Save issue body for debugging
          echo "$ISSUE_BODY" > issue_body_full.txt
          echo "DEBUG: Full issue body saved to file"
          
          # Look for multiple image URL patterns that GitHub uses
          echo "DEBUG: Searching for image URLs..."
          
          # Clear any existing image URLs file
          > image_urls.txt
          
          # Pattern 1: GitHub user content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 2: GitHub assets URLs  
          echo "$ISSUE_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/assets/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 3: Generic GitHub content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://[^.]*\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 4: Any https image URLs (broader catch)
          echo "$ISSUE_BODY" | grep -oE 'https://[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Remove duplicates and empty lines
          if [ -f image_urls.txt ]; then
            sort image_urls.txt | uniq | grep -v '^$' > image_urls_clean.txt || touch image_urls_clean.txt
            mv image_urls_clean.txt image_urls.txt
          else
            touch image_urls.txt
          fi
          
          echo "DEBUG: Found image URLs:"
          cat image_urls.txt
          
          # Count images found
          IMAGE_COUNT=$(wc -l < image_urls.txt)
          echo "DEBUG: Total unique image URLs found: $IMAGE_COUNT"
          
          # Download each image with enhanced error handling
          if [ -s image_urls.txt ] && [ "$IMAGE_COUNT" -gt 0 ]; then
            echo "Found $IMAGE_COUNT image(s) to download"
            
            while IFS= read -r img_url; do
              if [ -n "$img_url" ]; then
                echo "DEBUG: Processing URL: $img_url"
                
                # Extract file extension
                ext=$(echo "$img_url" | grep -oE '\.(png|jpg|jpeg|gif|webp)$' | head -1)
                if [ -z "$ext" ]; then
                  ext=".png"  # Default extension
                  echo "DEBUG: No extension found, defaulting to .png"
                fi
                
                filename="target-${NEXT_NUM}-comparison${ext}"
                filepath="$TARGET_DIR/$filename"
                
                echo "Downloading: $img_url"
                echo "         to: $filename"
                
                # Try multiple download methods
                DOWNLOAD_SUCCESS=false
                
                # Method 1: With GitHub token (for private repos)
                if curl -L -f -s \
                        -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                        -H "User-Agent: GitHub-Actions" \
                        -H "Accept: application/vnd.github.v3+json" \
                        "$img_url" -o "$filepath" 2>/dev/null; then
                  DOWNLOAD_SUCCESS=true
                  echo "âœ… Downloaded with GitHub token"
                fi
                
                # Method 2: Without token (for public URLs)
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if curl -L -f -s \
                          -H "User-Agent: Mozilla/5.0 (GitHub Actions)" \
                          "$img_url" -o "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded without token"
                  fi
                fi
                
                # Method 3: Using wget as fallback
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if wget -q --timeout=30 --tries=2 \
                          --header="User-Agent: GitHub-Actions" \
                          "$img_url" -O "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded with wget"
                  fi
                fi
                
                # Verify download
                if [ "$DOWNLOAD_SUCCESS" = true ] && [ -f "$filepath" ] && [ -s "$filepath" ]; then
                  # Check if it's actually an image file
                  file_type=$(file "$filepath" 2>/dev/null || echo "unknown")
                  if echo "$file_type" | grep -qi "image\|png\|jpeg\|gif\|webp"; then
                    echo "âœ… Successfully downloaded and verified: $filename"
                    echo "   File type: $file_type"
                    echo "   File size: $(du -h "$filepath" | cut -f1)"
                    NEXT_NUM=$((NEXT_NUM + 1))
                  else
                    echo "âŒ Downloaded file is not an image: $filename"
                    echo "   File type detected: $file_type"
                    rm -f "$filepath"
                  fi
                else
                  echo "âŒ Failed to download: $img_url"
                  [ -f "$filepath" ] && rm -f "$filepath"
                fi
                
                echo "---"
              fi
            done < image_urls.txt
          else
            echo "No images found in issue body"
            echo "DEBUG: This could mean:"
            echo "  - No images were uploaded to the issue"
            echo "  - Images are in a format/location we're not detecting"
            echo "  - The issue template format is different than expected"
          fi
          
          # Summary
          FINAL_IMAGE_COUNT=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | wc -l)
          echo ""
          echo "SUMMARY:"
          echo "  Images found in issue: $IMAGE_COUNT"
          echo "  Images successfully downloaded: $FINAL_IMAGE_COUNT"
          echo "  Images saved in: $TARGET_DIR"
          
          if [ "$FINAL_IMAGE_COUNT" -gt 0 ]; then
            echo "  Downloaded files:"
            find "$TARGET_DIR" -name "target-*-comparison.*" | sort
          fi
          
      - name: Generate LinkedIn post
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          LINKEDIN_FILE="$TARGET_DIR/linkedin-post.md"
          
          # Extract additional notes based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            # For GitHub issue forms, look for the "Additional Notes" content
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "additional.*notes\|notes\|description" | grep -v -i "additional.*notes\|notes\|description" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          else
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "update.*notes\|notes" | grep -v -i "update.*notes\|notes" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          fi
          
          # Clean up additional notes - remove empty content
          ADDITIONAL_NOTES=$(echo "$ADDITIONAL_NOTES" | xargs)
          
          # If no additional notes found, create a default description
          if [ -z "$ADDITIONAL_NOTES" ]; then
            if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
              ADDITIONAL_NOTES="Another CSS challenge completed! ðŸŽ¯"
            else
              ADDITIONAL_NOTES="Updated my CSS solution with improvements! ðŸš€"
            fi
          fi
          
          # Generate the repository URL for the solutions.html file
          REPO_URL="https://github.com/${{ github.repository }}"
          SOLUTIONS_URL="$REPO_URL/blob/main/daily-targets/${{ steps.date.outputs.formatted_date }}/solutions.html"
          
          # Create LinkedIn post with the exact format requested
          cat > "$LINKEDIN_FILE" << EOF
# LinkedIn Post for ${{ steps.date.outputs.formatted_date }}

---

Today's CSSBattle solution:

$ADDITIONAL_NOTES

$SOLUTIONS_URL

(My journal notes.)

#cssgang #CSS #CSSBattle #HTML
EOF
          
          echo "LinkedIn post generated successfully"
          echo "DEBUG: LinkedIn post content:"
          cat "$LINKEDIN_FILE"
          
      - name: Commit and push changes
        run: |
          # Configure git
          git config --local user.email "${GIT_USER_EMAIL:-${{ github.actor }}@users.noreply.github.com}"
          git config --local user.name "${GIT_USER_NAME:-${{ github.actor }}}"
          
          # Check if there are changes to commit
          git add .
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "has_changes=false" >> $GITHUB_ENV
          else
            # Pull latest changes to avoid conflicts
            echo "Pulling latest changes..."
            git fetch origin
            git rebase origin/main || {
              echo "Rebase failed, trying merge strategy..." > image_urls_clean.txt || touch image_urls_clean.txt
            mv image_urls_clean.txt image_urls.txt
          else
            touch image_urls.txt
          fi
          
          echo "DEBUG: Found image URLs:"
          cat image_urls.txt
          
          # Count images found
          IMAGE_COUNT=$(wc -l < image_urls.txt)
          echo "DEBUG: Total unique image URLs found: $IMAGE_COUNT"
          
          # Download each image with enhanced error handling
          if [ -s image_urls.txt ] && [ "$IMAGE_COUNT" -gt 0 ]; then
            echo "Found $IMAGE_COUNT image(s) to download"
            
            while IFS= read -r img_url; do
              if [ -n "$img_url" ]; then
                echo "DEBUG: Processing URL: $img_url"
                
                # Extract file extension
                ext=$(echo "$img_url" | grep -oE '\.(png|jpg|jpeg|gif|webp)name: Create or Update Solutions File for Daily CSSBattle
on:
  issues:
    types: [opened]

permissions:
  contents: write
  issues: write
  
jobs:
  process-solutions-file:
    runs-on: ubuntu-latest
    if: contains(github.event.issue.title, '[CSSBattle]') || contains(github.event.issue.title, '[CSSBattle-UPDATE]')
    
    env:
      GIT_USER_EMAIL: ${{ secrets.GIT_USER_EMAIL }}
      GIT_USER_NAME: ${{ secrets.GIT_USER_NAME }}
    
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
      
      - name: Determine operation type
        id: operation
        run: |
          if [[ "${{ github.event.issue.title }}" == *"[CSSBattle-UPDATE]"* ]]; then
            echo "type=update" >> $GITHUB_OUTPUT
            echo "Operation: UPDATE"
          else
            echo "type=create" >> $GITHUB_OUTPUT
            echo "Operation: CREATE"
          fi
      
      - name: Extract and validate issue data
        id: extract
        run: |
          # Save issue body to file for processing
          cat > issue_body.txt << 'EOF'
          ${{ github.event.issue.body }}
          EOF
          
          echo "DEBUG: Issue body content:"
          cat issue_body.txt
          echo "DEBUG: ===== END OF ISSUE BODY ====="
          
          # Validate issue body is not empty
          if [ ! -s issue_body.txt ]; then
            echo "ERROR: Issue body is empty"
            exit 1
          fi
          
          # Extract date based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "DEBUG: Extracting date for CREATE operation"
            
            # GitHub issue forms create structured output, look for the date field
            # The issue body will contain the date value after field processing
            
            # Method 1: Look for date pattern directly (for "Jun 8, 2025" format)
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Method 2: If not found, look for numeric date formats
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{1,2}/[0-9]{1,2}/[0-9]{4}" issue_body.txt | head -1)
            fi
            
            # Method 3: Look for ISO format dates
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{4}-[0-9]{2}-[0-9]{2}" issue_body.txt | head -1)
            fi
            
            # Method 4: Search around common labels (fallback)
            if [ -z "$DATE" ]; then
              # Look for lines that might contain dates after field labels
              DATE=$(grep -A 5 -i "date\|when\|day" issue_body.txt | grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" | head -1)
            fi
            
          else
            echo "DEBUG: Extracting date for UPDATE operation"
            # For update operations, look for target date
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Extract update type and version number (implement as needed for UPDATE template)
            UPDATE_TYPE=$(grep -A 3 -i "update.*type" issue_body.txt | grep -v -i "update.*type" | head -1 | xargs)
            VERSION_NUMBER=$(grep -A 3 -i "version.*number" issue_body.txt | grep -v -i "version.*number" | head -1 | xargs)
            
            echo "update_type=$UPDATE_TYPE" >> $GITHUB_OUTPUT
            echo "version_number=$VERSION_NUMBER" >> $GITHUB_OUTPUT
          fi
          
          echo "parsed_date=$DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Extracted date: '$DATE'"
          
          # Validate date was extracted
          if [ -z "$DATE" ]; then
            echo "ERROR: Could not extract date from issue."
            echo "DEBUG: Issue body for troubleshooting:"
            echo "--- ISSUE BODY START ---"
            cat issue_body.txt
            echo "--- ISSUE BODY END ---"
            echo ""
            echo "Expected format examples:"
            echo "  - Jun 8, 2025"
            echo "  - January 15, 2025"
            echo "  - 6/8/2025"
            echo "  - 2025-06-08"
            exit 1
          fi
          
      - name: Convert and validate date format
        id: date
        run: |
          DATE="${{ steps.extract.outputs.parsed_date }}"
          echo "DEBUG: Converting date: '$DATE'"
          
          # Enhanced date parsing specifically for your formats
          if [ -n "$DATE" ]; then
            # Try GNU date first (handles "Jun 8, 2025" format perfectly)
            if FORMATTED_DATE=$(date -d "$DATE" +%Y-%m-%d 2>/dev/null); then
              echo "DEBUG: Successfully parsed with GNU date: $FORMATTED_DATE"
            else
              echo "DEBUG: GNU date failed, attempting manual parsing for format like 'Jun 8, 2025'"
              
              # Clean up the date string - remove extra spaces and commas
              DATE_CLEAN=$(echo "$DATE" | sed 's/,/ /g' | tr -s ' ' | xargs)
              echo "DEBUG: Cleaned date: '$DATE_CLEAN'"
              
              # Extract components for "Mon D, YYYY" or "Mon D YYYY" format
              if echo "$DATE_CLEAN" | grep -qE "^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2}[[:space:]]+[0-9]{4}$"; then
                
                # Extract month name
                MONTH_NAME=$(echo "$DATE_CLEAN" | cut -d' ' -f1)
                # Extract day
                DAY_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f2)
                # Extract year  
                YEAR_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f3)
                
                echo "DEBUG: Extracted - Month: '$MONTH_NAME', Day: '$DAY_NUM', Year: '$YEAR_NUM'"
                
                # Convert month abbreviation to number
                case "$MONTH_NAME" in
                  Jan|January) MONTH_NUM="01" ;;
                  Feb|February) MONTH_NUM="02" ;;
                  Mar|March) MONTH_NUM="03" ;;
                  Apr|April) MONTH_NUM="04" ;;
                  May) MONTH_NUM="05" ;;
                  Jun|June) MONTH_NUM="06" ;;
                  Jul|July) MONTH_NUM="07" ;;
                  Aug|August) MONTH_NUM="08" ;;
                  Sep|September) MONTH_NUM="09" ;;
                  Oct|October) MONTH_NUM="10" ;;
                  Nov|November) MONTH_NUM="11" ;;
                  Dec|December) MONTH_NUM="12" ;;
                  *) 
                    echo "ERROR: Could not parse month: '$MONTH_NAME'"
                    echo "Expected: Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec"
                    echo "Or full names: January, February, etc."
                    exit 1
                    ;;
                esac
                
                # Validate day (1-31)
                if ! [[ "$DAY_NUM" =~ ^[0-9]+$ ]] || [ "$DAY_NUM" -lt 1 ] || [ "$DAY_NUM" -gt 31 ]; then
                  echo "ERROR: Invalid day: '$DAY_NUM' (must be 1-31)"
                  exit 1
                fi
                
                # Validate year (reasonable range)
                if ! [[ "$YEAR_NUM" =~ ^[0-9]{4}$ ]] || [ "$YEAR_NUM" -lt 2020 ] || [ "$YEAR_NUM" -gt 2030 ]; then
                  echo "ERROR: Invalid year: '$YEAR_NUM' (must be 2020-2030)"
                  exit 1
                fi
                
                # Format as YYYY-MM-DD with zero padding
                FORMATTED_DATE=$(printf "%04d-%02d-%02d" "$YEAR_NUM" "$MONTH_NUM" "$DAY_NUM")
                echo "DEBUG: Manual parsing result: $FORMATTED_DATE"
                
              else
                echo "ERROR: Date format not recognized: '$DATE_CLEAN'"
                echo "Expected format: 'Jun 8, 2025' or 'June 8, 2025'"
                echo "Received: '$DATE'"
                exit 1
              fi
            fi
          else
            echo "ERROR: No date provided"
            exit 1
          fi
          
          # Final validation of formatted date
          if ! echo "$FORMATTED_DATE" | grep -qE "^[0-9]{4}-[0-9]{2}-[0-9]{2}$"; then
            echo "ERROR: Invalid formatted date: '$FORMATTED_DATE'"
            echo "Expected format: YYYY-MM-DD"
            exit 1
          fi
          
          # Additional sanity check - verify it's a valid date
          if ! date -d "$FORMATTED_DATE" >/dev/null 2>&1; then
            echo "ERROR: '$FORMATTED_DATE' is not a valid date"
            exit 1
          fi
          
          echo "formatted_date=$FORMATTED_DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Final formatted date: $FORMATTED_DATE"
          
      - name: Extract and validate CSS content
        id: css
        run: |
          echo "DEBUG: Extracting CSS content for ${{ steps.operation.outputs.type }} operation"
          
          # For GitHub issue forms, the CSS content is in the issue body
          # Look for CSS code blocks or direct CSS content
          
          # Method 1: Look for CSS content in code blocks (```css ... ```)
          if sed -n '/```css/,/```/p' issue_body.txt | sed '1d;$d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
            echo "DEBUG: Found CSS in code blocks"
          else
            # Method 2: Look for CSS content in HTML style blocks
            if grep -A 50 -B 5 "<style>" issue_body.txt | sed '/^--$/d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
              echo "DEBUG: Found CSS with <style> tags"
            else
              # Method 3: Look for any CSS-like content (fallback)
              if grep -A 20 -i "css\|style" issue_body.txt | grep -E "(background|width|height|margin|padding|color)" > css_content_raw.txt && [ -s css_content_raw.txt ]; then
                echo "DEBUG: Found CSS-like content"
              else
                echo "ERROR: No CSS content found in issue"
                echo "DEBUG: Issue body for troubleshooting:"
                echo "--- ISSUE BODY START ---"
                cat issue_body.txt
                echo "--- ISSUE BODY END ---"
                echo ""
                echo "Expected: CSS code in \`\`\`css blocks or <style> tags"
                exit 1
              fi
            fi
          fi
          
          # Clean up the CSS content
          # Remove empty lines and clean up formatting
          sed '/^[[:space:]]*$/d' css_content_raw.txt > css_content.txt
          
          # Validate CSS content exists after cleaning
          if [ ! -s css_content.txt ]; then
            echo "ERROR: CSS content is empty after processing"
            echo "DEBUG: Raw CSS content was:"
            cat css_content_raw.txt
            exit 1
          fi
          
          echo "DEBUG: CSS content extracted successfully:"
          echo "--- CSS CONTENT START ---"
          head -10 css_content.txt
          if [ $(wc -l < css_content.txt) -gt 10 ]; then
            echo "... (truncated, total lines: $(wc -l < css_content.txt))"
          fi
          echo "--- CSS CONTENT END ---"
          
          # Count versions by counting ---VERSION--- separators
          VERSION_COUNT=$(grep -c "---VERSION---" css_content.txt 2>/dev/null || echo 0)
          VERSION_COUNT=$((VERSION_COUNT + 1))
          echo "version_count=$VERSION_COUNT" >> $GITHUB_OUTPUT
          echo "DEBUG: Found $VERSION_COUNT CSS versions"
          
      - name: Create directory structure
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          echo "DEBUG: Creating directory: $TARGET_DIR"
          
          mkdir -p "$TARGET_DIR"
          
          # Verify directory creation
          if [ ! -d "$TARGET_DIR" ]; then
            echo "ERROR: Failed to create directory: $TARGET_DIR"
            exit 1
          fi
          
          echo "DEBUG: Directory created successfully"
          ls -la daily-targets/
          
      - name: Create or update solutions file
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          SOLUTIONS_FILE="$TARGET_DIR/solutions.html"
          
          echo "DEBUG: Processing solutions file: $SOLUTIONS_FILE"
          
          # Clean CSS content - remove ```css and ``` markers, keep only the actual CSS
          sed -e '/^```css$/d' -e '/^```$/d' css_content.txt > css_cleaned.txt
          
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "Creating new solutions file..."
            
            # Start with Version 1 comment
            echo "<!-- Version 1 -->" > "$SOLUTIONS_FILE"
            
            # Process CSS content with version separation
            version_num=1
            while IFS= read -r line || [ -n "$line" ]; do
              if [[ "$line" == "---VERSION---" ]]; then
                # Close current version and start new one
                echo "</style>" >> "$SOLUTIONS_FILE"
                echo "" >> "$SOLUTIONS_FILE"
                version_num=$((version_num + 1))
                echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
              else
                echo "$line" >> "$SOLUTIONS_FILE"
              fi
            done < css_cleaned.txt
            
            # Ensure file ends with </style>
            if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
              echo "</style>" >> "$SOLUTIONS_FILE"
            fi
            
          else
            echo "Updating existing solutions file..."
            
            if [ ! -f "$SOLUTIONS_FILE" ]; then
              echo "ERROR: Solutions file not found: $SOLUTIONS_FILE"
              echo "Available dates:"
              ls daily-targets/ 2>/dev/null || echo "No existing solutions found"
              exit 1
            fi
            
            case "${{ steps.extract.outputs.update_type }}" in
              "Add new CSS version(s)")
                echo "Adding new CSS versions..."
                # Find last version number
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                # Ensure file ends with </style>
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              "Replace existing CSS version(s)")
                if [ -n "${{ steps.extract.outputs.version_number }}" ]; then
                  echo "Note: Version replacement is complex and not fully implemented"
                  echo "Adding as new version instead..."
                  LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                  NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                  
                  echo "" >> "$SOLUTIONS_FILE"
                  echo "<!-- Version $NEXT_VERSION (replacement for Version ${{ steps.extract.outputs.version_number }}) -->" >> "$SOLUTIONS_FILE"
                  
                  # Add cleaned CSS content
                  cat css_cleaned.txt >> "$SOLUTIONS_FILE"
                  
                  if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                    echo "</style>" >> "$SOLUTIONS_FILE"
                  fi
                else
                  echo "ERROR: Version number required for replacement"
                  exit 1
                fi
                ;;
                
              "Add new comparison image(s)")
                echo "Images will be processed in next step..."
                ;;
                
              "Add both CSS and images")
                echo "Adding new CSS versions and images..."
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              *)
                echo "ERROR: Unknown update type: ${{ steps.extract.outputs.update_type }}"
                exit 1
                ;;
            esac
          fi
          
          echo "Solutions file processing complete"
          echo "DEBUG: Final solutions file content:"
          cat "$SOLUTIONS_FILE"
          
      - name: Download and process images
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          ISSUE_NUM="${{ github.event.issue.number }}"
          
          echo "DEBUG: Processing images for issue #$ISSUE_NUM"
          echo "DEBUG: Target directory: $TARGET_DIR"
          
          # Determine next available image number
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            NEXT_NUM=1
          else
            # Find existing images and get next number
            EXISTING_IMAGES=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | sort)
            if [ -n "$EXISTING_IMAGES" ]; then
              LAST_NUM=$(echo "$EXISTING_IMAGES" | sed 's/.*target-\([0-9]\+\)-comparison\..*/\1/' | sort -n | tail -1)
              NEXT_NUM=$((LAST_NUM + 1))
              echo "DEBUG: Found existing images, starting from number: $NEXT_NUM"
            else
              NEXT_NUM=1
              echo "DEBUG: No existing images found, starting from: $NEXT_NUM"
            fi
          fi
          
          # Get the full issue data including uploaded assets
          echo "DEBUG: Fetching issue data..."
          gh issue view "$ISSUE_NUM" --repo "${{ github.repository }}" --json body,url > issue_data.json
          
          # Debug: Show what we got
          echo "DEBUG: Issue data received:"
          cat issue_data.json
          
          # Extract the issue body
          ISSUE_BODY=$(jq -r '.body' issue_data.json)
          echo "DEBUG: Issue body extracted, length: ${#ISSUE_BODY}"
          
          # Save issue body for debugging
          echo "$ISSUE_BODY" > issue_body_full.txt
          echo "DEBUG: Full issue body saved to file"
          
          # Look for multiple image URL patterns that GitHub uses
          echo "DEBUG: Searching for image URLs..."
          
          # Clear any existing image URLs file
          > image_urls.txt
          
          # Pattern 1: GitHub user content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 2: GitHub assets URLs  
          echo "$ISSUE_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/assets/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 3: Generic GitHub content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://[^.]*\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 4: Any https image URLs (broader catch)
          echo "$ISSUE_BODY" | grep -oE 'https://[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Remove duplicates and empty lines
          if [ -f image_urls.txt ]; then
            sort image_urls.txt | uniq | grep -v '^$' > image_urls_clean.txt || touch image_urls_clean.txt
            mv image_urls_clean.txt image_urls.txt
          else
            touch image_urls.txt
          fi
          
          echo "DEBUG: Found image URLs:"
          cat image_urls.txt
          
          # Count images found
          IMAGE_COUNT=$(wc -l < image_urls.txt)
          echo "DEBUG: Total unique image URLs found: $IMAGE_COUNT"
          
          # Download each image with enhanced error handling
          if [ -s image_urls.txt ] && [ "$IMAGE_COUNT" -gt 0 ]; then
            echo "Found $IMAGE_COUNT image(s) to download"
            
            while IFS= read -r img_url; do
              if [ -n "$img_url" ]; then
                echo "DEBUG: Processing URL: $img_url"
                
                # Extract file extension
                ext=$(echo "$img_url" | grep -oE '\.(png|jpg|jpeg|gif|webp)$' | head -1)
                if [ -z "$ext" ]; then
                  ext=".png"  # Default extension
                  echo "DEBUG: No extension found, defaulting to .png"
                fi
                
                filename="target-${NEXT_NUM}-comparison${ext}"
                filepath="$TARGET_DIR/$filename"
                
                echo "Downloading: $img_url"
                echo "         to: $filename"
                
                # Try multiple download methods
                DOWNLOAD_SUCCESS=false
                
                # Method 1: With GitHub token (for private repos)
                if curl -L -f -s \
                        -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                        -H "User-Agent: GitHub-Actions" \
                        -H "Accept: application/vnd.github.v3+json" \
                        "$img_url" -o "$filepath" 2>/dev/null; then
                  DOWNLOAD_SUCCESS=true
                  echo "âœ… Downloaded with GitHub token"
                fi
                
                # Method 2: Without token (for public URLs)
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if curl -L -f -s \
                          -H "User-Agent: Mozilla/5.0 (GitHub Actions)" \
                          "$img_url" -o "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded without token"
                  fi
                fi
                
                # Method 3: Using wget as fallback
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if wget -q --timeout=30 --tries=2 \
                          --header="User-Agent: GitHub-Actions" \
                          "$img_url" -O "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded with wget"
                  fi
                fi
                
                # Verify download
                if [ "$DOWNLOAD_SUCCESS" = true ] && [ -f "$filepath" ] && [ -s "$filepath" ]; then
                  # Check if it's actually an image file
                  file_type=$(file "$filepath" 2>/dev/null || echo "unknown")
                  if echo "$file_type" | grep -qi "image\|png\|jpeg\|gif\|webp"; then
                    echo "âœ… Successfully downloaded and verified: $filename"
                    echo "   File type: $file_type"
                    echo "   File size: $(du -h "$filepath" | cut -f1)"
                    NEXT_NUM=$((NEXT_NUM + 1))
                  else
                    echo "âŒ Downloaded file is not an image: $filename"
                    echo "   File type detected: $file_type"
                    rm -f "$filepath"
                  fi
                else
                  echo "âŒ Failed to download: $img_url"
                  [ -f "$filepath" ] && rm -f "$filepath"
                fi
                
                echo "---"
              fi
            done < image_urls.txt
          else
            echo "No images found in issue body"
            echo "DEBUG: This could mean:"
            echo "  - No images were uploaded to the issue"
            echo "  - Images are in a format/location we're not detecting"
            echo "  - The issue template format is different than expected"
          fi
          
          # Summary
          FINAL_IMAGE_COUNT=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | wc -l)
          echo ""
          echo "SUMMARY:"
          echo "  Images found in issue: $IMAGE_COUNT"
          echo "  Images successfully downloaded: $FINAL_IMAGE_COUNT"
          echo "  Images saved in: $TARGET_DIR"
          
          if [ "$FINAL_IMAGE_COUNT" -gt 0 ]; then
            echo "  Downloaded files:"
            find "$TARGET_DIR" -name "target-*-comparison.*" | sort
          fi
          
      - name: Generate LinkedIn post
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          LINKEDIN_FILE="$TARGET_DIR/linkedin-post.md"
          
          # Extract additional notes based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            # For GitHub issue forms, look for the "Additional Notes" content
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "additional.*notes\|notes\|description" | grep -v -i "additional.*notes\|notes\|description" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          else
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "update.*notes\|notes" | grep -v -i "update.*notes\|notes" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          fi
          
          # Clean up additional notes - remove empty content
          ADDITIONAL_NOTES=$(echo "$ADDITIONAL_NOTES" | xargs)
          
          # If no additional notes found, create a default description
          if [ -z "$ADDITIONAL_NOTES" ]; then
            if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
              ADDITIONAL_NOTES="Another CSS challenge completed! ðŸŽ¯"
            else
              ADDITIONAL_NOTES="Updated my CSS solution with improvements! ðŸš€"
            fi
          fi
          
          # Generate the repository URL for the solutions.html file
          REPO_URL="https://github.com/${{ github.repository }}"
          SOLUTIONS_URL="$REPO_URL/blob/main/daily-targets/${{ steps.date.outputs.formatted_date }}/solutions.html"
          
          # Create LinkedIn post with the exact format requested
          cat > "$LINKEDIN_FILE" << EOF
# LinkedIn Post for ${{ steps.date.outputs.formatted_date }}

---

Today's CSSBattle solution:

$ADDITIONAL_NOTES

$SOLUTIONS_URL

(My journal notes.)

#cssgang #CSS #CSSBattle #HTML
EOF
          
          echo "LinkedIn post generated successfully"
          echo "DEBUG: LinkedIn post content:"
          cat "$LINKEDIN_FILE"
          
      - name: Commit and push changes
        run: |
          # Configure git
          git config --local user.email "${GIT_USER_EMAIL:-${{ github.actor }}@users.noreply.github.com}"
          git config --local user.name "${GIT_USER_NAME:-${{ github.actor }}}"
          
          # Check if there are changes to commit
          git add .
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "has_changes=false" >> $GITHUB_ENV
          else
            # Pull latest changes to avoid conflicts
            echo "Pulling latest changes..."
            git fetch origin
            git rebase origin/main || {
              echo "Rebase failed, trying merge strategy..." | head -1)
                if [ -z "$ext" ]; then
                  ext=".png"  # Default extension
                  echo "DEBUG: No extension found, defaulting to .png"
                fi
                
                filename="target-${NEXT_NUM}-comparison${ext}"
                filepath="$TARGET_DIR/$filename"
                
                echo "Downloading: $img_url"
                echo "         to: $filename"
                
                # Try multiple download methods
                DOWNLOAD_SUCCESS=false
                
                # Method 1: With GitHub token (for private repos)
                if curl -L -f -s \
                        -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                        -H "User-Agent: GitHub-Actions" \
                        -H "Accept: application/vnd.github.v3+json" \
                        "$img_url" -o "$filepath" 2>/dev/null; then
                  DOWNLOAD_SUCCESS=true
                  echo "âœ… Downloaded with GitHub token"
                fi
                
                # Method 2: Without token (for public URLs)
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if curl -L -f -s \
                          -H "User-Agent: Mozilla/5.0 (GitHub Actions)" \
                          "$img_url" -o "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded without token"
                  fi
                fi
                
                # Method 3: Using wget as fallback
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if wget -q --timeout=30 --tries=2 \
                          --header="User-Agent: GitHub-Actions" \
                          "$img_url" -O "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded with wget"
                  fi
                fi
                
                # Verify download
                if [ "$DOWNLOAD_SUCCESS" = true ] && [ -f "$filepath" ] && [ -s "$filepath" ]; then
                  # Check if it's actually an image file
                  file_type=$(file "$filepath" 2>/dev/null || echo "unknown")
                  if echo "$file_type" | grep -qi "image\|png\|jpeg\|gif\|webp"; then
                    echo "âœ… Successfully downloaded and verified: $filename"
                    echo "   File type: $file_type"
                    echo "   File size: $(du -h "$filepath" | cut -f1)"
                    NEXT_NUM=$((NEXT_NUM + 1))
                  else
                    echo "âŒ Downloaded file is not an image: $filename"
                    echo "   File type detected: $file_type"
                    rm -f "$filepath"
                  fi
                else
                  echo "âŒ Failed to download: $img_url"
                  [ -f "$filepath" ] && rm -f "$filepath"
                fi
                
                echo "---"
              fi
            done < image_urls.txt
          else
            echo "No images found in issue body"
            echo "DEBUG: This could mean:"
            echo "  - No images were uploaded to the issue"
            echo "  - Images are in a format/location we're not detecting"
            echo "  - The issue template format is different than expected"
          fi
          
          # Summary
          FINAL_IMAGE_COUNT=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | wc -l)
          echo ""
          echo "SUMMARY:"
          echo "  Images found in issue: $IMAGE_COUNT"
          echo "  Images successfully downloaded: $FINAL_IMAGE_COUNT"
          echo "  Images saved in: $TARGET_DIR"
          
          if [ "$FINAL_IMAGE_COUNT" -gt 0 ]; then
            echo "  Downloaded files:"
            find "$TARGET_DIR" -name "target-*-comparison.*" | sort
          fi
          
      - name: Generate LinkedIn post
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          LINKEDIN_FILE="$TARGET_DIR/linkedin-post.md"
          
          # Extract additional notes based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            # For GitHub issue forms, look for the "Additional Notes" content
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "additional.*notes\|notes\|description" | grep -v -i "additional.*notes\|notes\|description" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          else
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "update.*notes\|notes" | grep -v -i "update.*notes\|notes" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          fi
          
          # Clean up additional notes - remove empty content
          ADDITIONAL_NOTES=$(echo "$ADDITIONAL_NOTES" | xargs)
          
          # If no additional notes found, create a default description
          if [ -z "$ADDITIONAL_NOTES" ]; then
            if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
              ADDITIONAL_NOTES="Another CSS challenge completed! ðŸŽ¯"
            else
              ADDITIONAL_NOTES="Updated my CSS solution with improvements! ðŸš€"
            fi
          fi
          
          # Generate the repository URL for the solutions.html file
          REPO_URL="https://github.com/${{ github.repository }}"
          SOLUTIONS_URL="$REPO_URL/blob/main/daily-targets/${{ steps.date.outputs.formatted_date }}/solutions.html"
          
          # Create LinkedIn post with the exact format requested
          cat > "$LINKEDIN_FILE" << EOF
# LinkedIn Post for ${{ steps.date.outputs.formatted_date }}

---

Today's CSSBattle solution:

$ADDITIONAL_NOTES

$SOLUTIONS_URL

(My journal notes.)

#cssgang #CSS #CSSBattle #HTML
EOF
          
          echo "LinkedIn post generated successfully"
          echo "DEBUG: LinkedIn post content:"
          cat "$LINKEDIN_FILE"
          
      - name: Commit and push changes
        run: |
          # Configure git
          git config --local user.email "${GIT_USER_EMAIL:-${{ github.actor }}@users.noreply.github.com}"
          git config --local user.name "${GIT_USER_NAME:-${{ github.actor }}}"
          
          # Check if there are changes to commit
          git add .
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "has_changes=false" >> $GITHUB_ENV
          else
            # Pull latest changes to avoid conflicts
            echo "Pulling latest changes..."
            git fetch origin
            git rebase origin/main || {
              echo "Rebase failed, trying merge strategy..."
              git rebase --abort
              git merge origin/main
            }
            
            # Commit changes
            if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
              COMMIT_MSG="feat: CSS Battle solution for ${{ steps.date.outputs.formatted_date }}"
            else
              COMMIT_MSG="update: CSS Battle solution for ${{ steps.date.outputs.formatted_date }}"
            fi
            
            git commit -m "$COMMIT_MSG"
            
            # Push with retry logic
            echo "Pushing changes..."
            for i in {1..3}; do
              if git push origin main; then
                echo "âœ… Changes pushed successfully"
                echo "has_changes=true" >> $GITHUB_ENV
                break
              else
                echo "âŒ Push attempt $i failed"
                if [ $i -lt 3 ]; then
                  echo "Retrying after pull..."
                  git pull origin main --rebase
                else
                  echo "All push attempts failed"
                  exit 1
                fi
              fi
            done
          fi
          
      - name: Create success comment and close issue
        if: env.has_changes != 'false'
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          
          # Count final results
          VERSION_COUNT_IN_FILE=$(grep -c "<!-- Version" "$TARGET_DIR/solutions.html" 2>/dev/null || echo 1)
          IMAGE_COUNT=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | wc -l)
          
          # Get processing summary from the image download step
          IMAGES_FOUND=$(cat image_urls.txt 2>/dev/null | wc -l || echo 0)
          
          # Calculate character counts for each CSS version (from original cleaned CSS)
          echo "DEBUG: Calculating character counts..."
          
          # Split the cleaned CSS content by ---VERSION--- markers
          cp css_cleaned.txt css_for_counting.txt
          
          # Create individual version files for counting
          version_num=1
          current_file="version_${version_num}.css"
          > "$current_file"  # Create empty first version file
          
          while IFS= read -r line || [ -n "$line" ]; do
            if [[ "$line" == "---VERSION---" ]]; then
              # Start new version file
              version_num=$((version_num + 1))
              current_file="version_${version_num}.css"
              > "$current_file"  # Create empty new version file
            else
              # Add line to current version file
              echo "$line" >> "$current_file"
            fi
          done < css_for_counting.txt
          
          # Count characters for each version (excluding any </style> tags)
          CHAR_COUNTS=""
          for i in $(seq 1 $VERSION_COUNT_IN_FILE); do
            version_file="version_${i}.css"
            if [ -f "$version_file" ]; then
              # Remove any </style> tags and count characters
              char_count=$(sed 's|</style>||g' "$version_file" | tr -d '\n' | wc -c)
              if [ $i -eq 1 ]; then
                CHAR_COUNTS="Version $i: $char_count chars"
              else
                CHAR_COUNTS="$CHAR_COUNTS - Version $i: $char_count chars"
              fi
              echo "DEBUG: Version $i character count: $char_count"
            fi
          done
          
          # Create comprehensive success comment with detailed summary
          # Using separate echo statements to avoid heredoc quoting issues
          cat > comment.txt << 'COMMENT_EOF'
# âœ… CSS Battle Solution Processed Successfully!

## ðŸ“ Location
COMMENT_EOF
          
          echo "\`$TARGET_DIR/\`" >> comment.txt
          echo "" >> comment.txt
          echo "## ðŸ“Š Processing Summary" >> comment.txt
          echo "- ðŸŽ¯ **CSS Versions Created:** $VERSION_COUNT_IN_FILE" >> comment.txt
          echo "- ðŸ–¼ï¸ **Images Found in Issue:** $IMAGES_FOUND" >> comment.txt
          echo "- ðŸ“¥ **Images Successfully Downloaded:** $IMAGE_COUNT" >> comment.txt
          echo "- ðŸ“… **Target Date:** ${{ steps.date.outputs.formatted_date }}" >> comment.txt
          echo "- ðŸ”„ **Operation Type:** ${{ steps.operation.outputs.type }}" >> comment.txt
          echo "" >> comment.txt
          echo "## âš¡ Char Count" >> comment.txt
          echo "$CHAR_COUNTS" >> comment.txt
          echo "" >> comment.txt
          echo "## ðŸ“„ Files Created/Updated" >> comment.txt
          echo "" >> comment.txt
          echo "### Solutions" >> comment.txt
          echo "- âœ… \`solutions.html\` - Your CSS solution ($VERSION_COUNT_IN_FILE version(s))" >> comment.txt
          echo "" >> comment.txt
          echo "### Content" >> comment.txt
          echo "- âœ… \`linkedin-post.md\` - Ready-to-post LinkedIn content" >> comment.txt
          echo "" >> comment.txt
          echo "### Images" >> comment.txt
          
          if [ "$IMAGE_COUNT" -gt 0 ]; then
            echo "ðŸ“¸ **Downloaded Images:**" >> comment.txt
            find "$TARGET_DIR" -name "target-*-comparison.*" | sort | while read -r img; do
              # Get file size for each image
              size=$(du -h "$img" 2>/dev/null | cut -f1 || echo "?")
              echo "- âœ… \`$(basename "$img")\` (${size})" >> comment.txt
            done
          else
            echo "- â„¹ï¸ No images were uploaded or found" >> comment.txt
            if [ "$IMAGES_FOUND" -gt 0 ]; then
              echo "- âš ï¸ Found $IMAGES_FOUND image URL(s) but download failed" >> comment.txt
            fi
          fi
          
          echo "" >> comment.txt
          echo "## ðŸ”— Quick Links" >> comment.txt
          echo "- ðŸ“± **LinkedIn Post:** [\`linkedin-post.md\`](${{ github.server_url }}/${{ github.repository }}/blob/main/$TARGET_DIR/linkedin-post.md)" >> comment.txt
          echo "- ðŸ’» **CSS Solution:** [\`solutions.html\`](${{ github.server_url }}/${{ github.repository }}/blob/main/$TARGET_DIR/solutions.html)" >> comment.txt
          echo "- ðŸ“ **Full Directory:** [\`$TARGET_DIR/\`](${{ github.server_url }}/${{ github.repository }}/tree/main/$TARGET_DIR)" >> comment.txt
          echo "" >> comment.txt
          echo "## ðŸŽ‰ Ready for Battle!" >> comment.txt
          echo "Your solution is now organized and ready for sharing. Click the LinkedIn post link above to copy the content!" >> comment.txt
          echo "" >> comment.txt
          echo "---" >> comment.txt
          echo "*âœ¨ Processed by GitHub Actions on $(date)*" >> comment.txt
          echo "*ðŸ”§ Workflow: [\`${{ github.workflow }}\`](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*" >> comment.txt
          
          # Post comment and close issue
          gh issue comment "${{ github.event.issue.number }}" \
            --repo "${{ github.repository }}" \
            --body-file comment.txt
          
          gh issue close "${{ github.event.issue.number }}" \
            --repo "${{ github.repository }}" \
            --reason completed

      - name: Cleanup temporary files
        if: always()
        run: |
          echo "ðŸ§¹ Cleaning up temporary files..."
          
          # List of temporary files that may be created during the workflow
          TEMP_FILES=(
            "issue_body.txt"
            "css_content.txt"
            "css_content_raw.txt"
            "css_cleaned.txt"
            "css_for_counting.txt"
            "image_urls.txt"
            "image_urls_clean.txt"
            "formatted_date_backup.txt"
            "date_output.txt"
            "issue_data.json"
            "issue_body_full.txt"
            "comment.txt"
            "temp_solutions.html"
          )
          
          # Remove each temporary file if it exists
          for file in "${TEMP_FILES[@]}"; do
            if [ -f "$file" ]; then
              echo "Removing: $file"
              rm -f "$file"
            fi
          done
          
          # Remove version-specific character counting files
          rm -f version_*.css 2>/dev/null || true
          
          # Double-check for any other temporary files with common patterns
          find . -maxdepth 1 -name "*.tmp" -type f -delete 2>/dev/null || true
          find . -maxdepth 1 -name "temp_*" -type f -delete 2>/dev/null || true
          
          echo "âœ… Cleanup completed - repository is clean"
          
          # Verify cleanup (optional debug)
          echo "DEBUG: Remaining files in root directory:"
          ls -laname: Create or Update Solutions File for Daily CSSBattle
on:
  issues:
    types: [opened]

permissions:
  contents: write
  issues: write
  
jobs:
  process-solutions-file:
    runs-on: ubuntu-latest
    if: contains(github.event.issue.title, '[CSSBattle]') || contains(github.event.issue.title, '[CSSBattle-UPDATE]')
    
    env:
      GIT_USER_EMAIL: ${{ secrets.GIT_USER_EMAIL }}
      GIT_USER_NAME: ${{ secrets.GIT_USER_NAME }}
    
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
      
      - name: Determine operation type
        id: operation
        run: |
          if [[ "${{ github.event.issue.title }}" == *"[CSSBattle-UPDATE]"* ]]; then
            echo "type=update" >> $GITHUB_OUTPUT
            echo "Operation: UPDATE"
          else
            echo "type=create" >> $GITHUB_OUTPUT
            echo "Operation: CREATE"
          fi
      
      - name: Extract and validate issue data
        id: extract
        run: |
          # Save issue body to file for processing
          cat > issue_body.txt << 'EOF'
          ${{ github.event.issue.body }}
          EOF
          
          echo "DEBUG: Issue body content:"
          cat issue_body.txt
          echo "DEBUG: ===== END OF ISSUE BODY ====="
          
          # Validate issue body is not empty
          if [ ! -s issue_body.txt ]; then
            echo "ERROR: Issue body is empty"
            exit 1
          fi
          
          # Extract date based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "DEBUG: Extracting date for CREATE operation"
            
            # GitHub issue forms create structured output, look for the date field
            # The issue body will contain the date value after field processing
            
            # Method 1: Look for date pattern directly (for "Jun 8, 2025" format)
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Method 2: If not found, look for numeric date formats
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{1,2}/[0-9]{1,2}/[0-9]{4}" issue_body.txt | head -1)
            fi
            
            # Method 3: Look for ISO format dates
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{4}-[0-9]{2}-[0-9]{2}" issue_body.txt | head -1)
            fi
            
            # Method 4: Search around common labels (fallback)
            if [ -z "$DATE" ]; then
              # Look for lines that might contain dates after field labels
              DATE=$(grep -A 5 -i "date\|when\|day" issue_body.txt | grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" | head -1)
            fi
            
          else
            echo "DEBUG: Extracting date for UPDATE operation"
            # For update operations, look for target date
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Extract update type and version number (implement as needed for UPDATE template)
            UPDATE_TYPE=$(grep -A 3 -i "update.*type" issue_body.txt | grep -v -i "update.*type" | head -1 | xargs)
            VERSION_NUMBER=$(grep -A 3 -i "version.*number" issue_body.txt | grep -v -i "version.*number" | head -1 | xargs)
            
            echo "update_type=$UPDATE_TYPE" >> $GITHUB_OUTPUT
            echo "version_number=$VERSION_NUMBER" >> $GITHUB_OUTPUT
          fi
          
          echo "parsed_date=$DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Extracted date: '$DATE'"
          
          # Validate date was extracted
          if [ -z "$DATE" ]; then
            echo "ERROR: Could not extract date from issue."
            echo "DEBUG: Issue body for troubleshooting:"
            echo "--- ISSUE BODY START ---"
            cat issue_body.txt
            echo "--- ISSUE BODY END ---"
            echo ""
            echo "Expected format examples:"
            echo "  - Jun 8, 2025"
            echo "  - January 15, 2025"
            echo "  - 6/8/2025"
            echo "  - 2025-06-08"
            exit 1
          fi
          
      - name: Convert and validate date format
        id: date
        run: |
          DATE="${{ steps.extract.outputs.parsed_date }}"
          echo "DEBUG: Converting date: '$DATE'"
          
          # Enhanced date parsing specifically for your formats
          if [ -n "$DATE" ]; then
            # Try GNU date first (handles "Jun 8, 2025" format perfectly)
            if FORMATTED_DATE=$(date -d "$DATE" +%Y-%m-%d 2>/dev/null); then
              echo "DEBUG: Successfully parsed with GNU date: $FORMATTED_DATE"
            else
              echo "DEBUG: GNU date failed, attempting manual parsing for format like 'Jun 8, 2025'"
              
              # Clean up the date string - remove extra spaces and commas
              DATE_CLEAN=$(echo "$DATE" | sed 's/,/ /g' | tr -s ' ' | xargs)
              echo "DEBUG: Cleaned date: '$DATE_CLEAN'"
              
              # Extract components for "Mon D, YYYY" or "Mon D YYYY" format
              if echo "$DATE_CLEAN" | grep -qE "^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2}[[:space:]]+[0-9]{4}$"; then
                
                # Extract month name
                MONTH_NAME=$(echo "$DATE_CLEAN" | cut -d' ' -f1)
                # Extract day
                DAY_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f2)
                # Extract year  
                YEAR_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f3)
                
                echo "DEBUG: Extracted - Month: '$MONTH_NAME', Day: '$DAY_NUM', Year: '$YEAR_NUM'"
                
                # Convert month abbreviation to number
                case "$MONTH_NAME" in
                  Jan|January) MONTH_NUM="01" ;;
                  Feb|February) MONTH_NUM="02" ;;
                  Mar|March) MONTH_NUM="03" ;;
                  Apr|April) MONTH_NUM="04" ;;
                  May) MONTH_NUM="05" ;;
                  Jun|June) MONTH_NUM="06" ;;
                  Jul|July) MONTH_NUM="07" ;;
                  Aug|August) MONTH_NUM="08" ;;
                  Sep|September) MONTH_NUM="09" ;;
                  Oct|October) MONTH_NUM="10" ;;
                  Nov|November) MONTH_NUM="11" ;;
                  Dec|December) MONTH_NUM="12" ;;
                  *) 
                    echo "ERROR: Could not parse month: '$MONTH_NAME'"
                    echo "Expected: Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec"
                    echo "Or full names: January, February, etc."
                    exit 1
                    ;;
                esac
                
                # Validate day (1-31)
                if ! [[ "$DAY_NUM" =~ ^[0-9]+$ ]] || [ "$DAY_NUM" -lt 1 ] || [ "$DAY_NUM" -gt 31 ]; then
                  echo "ERROR: Invalid day: '$DAY_NUM' (must be 1-31)"
                  exit 1
                fi
                
                # Validate year (reasonable range)
                if ! [[ "$YEAR_NUM" =~ ^[0-9]{4}$ ]] || [ "$YEAR_NUM" -lt 2020 ] || [ "$YEAR_NUM" -gt 2030 ]; then
                  echo "ERROR: Invalid year: '$YEAR_NUM' (must be 2020-2030)"
                  exit 1
                fi
                
                # Format as YYYY-MM-DD with zero padding
                FORMATTED_DATE=$(printf "%04d-%02d-%02d" "$YEAR_NUM" "$MONTH_NUM" "$DAY_NUM")
                echo "DEBUG: Manual parsing result: $FORMATTED_DATE"
                
              else
                echo "ERROR: Date format not recognized: '$DATE_CLEAN'"
                echo "Expected format: 'Jun 8, 2025' or 'June 8, 2025'"
                echo "Received: '$DATE'"
                exit 1
              fi
            fi
          else
            echo "ERROR: No date provided"
            exit 1
          fi
          
          # Final validation of formatted date
          if ! echo "$FORMATTED_DATE" | grep -qE "^[0-9]{4}-[0-9]{2}-[0-9]{2}$"; then
            echo "ERROR: Invalid formatted date: '$FORMATTED_DATE'"
            echo "Expected format: YYYY-MM-DD"
            exit 1
          fi
          
          # Additional sanity check - verify it's a valid date
          if ! date -d "$FORMATTED_DATE" >/dev/null 2>&1; then
            echo "ERROR: '$FORMATTED_DATE' is not a valid date"
            exit 1
          fi
          
          echo "formatted_date=$FORMATTED_DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Final formatted date: $FORMATTED_DATE"
          
      - name: Extract and validate CSS content
        id: css
        run: |
          echo "DEBUG: Extracting CSS content for ${{ steps.operation.outputs.type }} operation"
          
          # For GitHub issue forms, the CSS content is in the issue body
          # Look for CSS code blocks or direct CSS content
          
          # Method 1: Look for CSS content in code blocks (```css ... ```)
          if sed -n '/```css/,/```/p' issue_body.txt | sed '1d;$d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
            echo "DEBUG: Found CSS in code blocks"
          else
            # Method 2: Look for CSS content in HTML style blocks
            if grep -A 50 -B 5 "<style>" issue_body.txt | sed '/^--$/d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
              echo "DEBUG: Found CSS with <style> tags"
            else
              # Method 3: Look for any CSS-like content (fallback)
              if grep -A 20 -i "css\|style" issue_body.txt | grep -E "(background|width|height|margin|padding|color)" > css_content_raw.txt && [ -s css_content_raw.txt ]; then
                echo "DEBUG: Found CSS-like content"
              else
                echo "ERROR: No CSS content found in issue"
                echo "DEBUG: Issue body for troubleshooting:"
                echo "--- ISSUE BODY START ---"
                cat issue_body.txt
                echo "--- ISSUE BODY END ---"
                echo ""
                echo "Expected: CSS code in \`\`\`css blocks or <style> tags"
                exit 1
              fi
            fi
          fi
          
          # Clean up the CSS content
          # Remove empty lines and clean up formatting
          sed '/^[[:space:]]*$/d' css_content_raw.txt > css_content.txt
          
          # Validate CSS content exists after cleaning
          if [ ! -s css_content.txt ]; then
            echo "ERROR: CSS content is empty after processing"
            echo "DEBUG: Raw CSS content was:"
            cat css_content_raw.txt
            exit 1
          fi
          
          echo "DEBUG: CSS content extracted successfully:"
          echo "--- CSS CONTENT START ---"
          head -10 css_content.txt
          if [ $(wc -l < css_content.txt) -gt 10 ]; then
            echo "... (truncated, total lines: $(wc -l < css_content.txt))"
          fi
          echo "--- CSS CONTENT END ---"
          
          # Count versions by counting ---VERSION--- separators
          VERSION_COUNT=$(grep -c "---VERSION---" css_content.txt 2>/dev/null || echo 0)
          VERSION_COUNT=$((VERSION_COUNT + 1))
          echo "version_count=$VERSION_COUNT" >> $GITHUB_OUTPUT
          echo "DEBUG: Found $VERSION_COUNT CSS versions"
          
      - name: Create directory structure
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          echo "DEBUG: Creating directory: $TARGET_DIR"
          
          mkdir -p "$TARGET_DIR"
          
          # Verify directory creation
          if [ ! -d "$TARGET_DIR" ]; then
            echo "ERROR: Failed to create directory: $TARGET_DIR"
            exit 1
          fi
          
          echo "DEBUG: Directory created successfully"
          ls -la daily-targets/
          
      - name: Create or update solutions file
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          SOLUTIONS_FILE="$TARGET_DIR/solutions.html"
          
          echo "DEBUG: Processing solutions file: $SOLUTIONS_FILE"
          
          # Clean CSS content - remove ```css and ``` markers, keep only the actual CSS
          sed -e '/^```css$/d' -e '/^```$/d' css_content.txt > css_cleaned.txt
          
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "Creating new solutions file..."
            
            # Start with Version 1 comment
            echo "<!-- Version 1 -->" > "$SOLUTIONS_FILE"
            
            # Process CSS content with version separation
            version_num=1
            while IFS= read -r line || [ -n "$line" ]; do
              if [[ "$line" == "---VERSION---" ]]; then
                # Close current version and start new one
                echo "</style>" >> "$SOLUTIONS_FILE"
                echo "" >> "$SOLUTIONS_FILE"
                version_num=$((version_num + 1))
                echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
              else
                echo "$line" >> "$SOLUTIONS_FILE"
              fi
            done < css_cleaned.txt
            
            # Ensure file ends with </style>
            if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
              echo "</style>" >> "$SOLUTIONS_FILE"
            fi
            
          else
            echo "Updating existing solutions file..."
            
            if [ ! -f "$SOLUTIONS_FILE" ]; then
              echo "ERROR: Solutions file not found: $SOLUTIONS_FILE"
              echo "Available dates:"
              ls daily-targets/ 2>/dev/null || echo "No existing solutions found"
              exit 1
            fi
            
            case "${{ steps.extract.outputs.update_type }}" in
              "Add new CSS version(s)")
                echo "Adding new CSS versions..."
                # Find last version number
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                # Ensure file ends with </style>
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              "Replace existing CSS version(s)")
                if [ -n "${{ steps.extract.outputs.version_number }}" ]; then
                  echo "Note: Version replacement is complex and not fully implemented"
                  echo "Adding as new version instead..."
                  LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                  NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                  
                  echo "" >> "$SOLUTIONS_FILE"
                  echo "<!-- Version $NEXT_VERSION (replacement for Version ${{ steps.extract.outputs.version_number }}) -->" >> "$SOLUTIONS_FILE"
                  
                  # Add cleaned CSS content
                  cat css_cleaned.txt >> "$SOLUTIONS_FILE"
                  
                  if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                    echo "</style>" >> "$SOLUTIONS_FILE"
                  fi
                else
                  echo "ERROR: Version number required for replacement"
                  exit 1
                fi
                ;;
                
              "Add new comparison image(s)")
                echo "Images will be processed in next step..."
                ;;
                
              "Add both CSS and images")
                echo "Adding new CSS versions and images..."
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              *)
                echo "ERROR: Unknown update type: ${{ steps.extract.outputs.update_type }}"
                exit 1
                ;;
            esac
          fi
          
          echo "Solutions file processing complete"
          echo "DEBUG: Final solutions file content:"
          cat "$SOLUTIONS_FILE"
          
      - name: Download and process images
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          ISSUE_NUM="${{ github.event.issue.number }}"
          
          echo "DEBUG: Processing images for issue #$ISSUE_NUM"
          echo "DEBUG: Target directory: $TARGET_DIR"
          
          # Determine next available image number
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            NEXT_NUM=1
          else
            # Find existing images and get next number
            EXISTING_IMAGES=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | sort)
            if [ -n "$EXISTING_IMAGES" ]; then
              LAST_NUM=$(echo "$EXISTING_IMAGES" | sed 's/.*target-\([0-9]\+\)-comparison\..*/\1/' | sort -n | tail -1)
              NEXT_NUM=$((LAST_NUM + 1))
              echo "DEBUG: Found existing images, starting from number: $NEXT_NUM"
            else
              NEXT_NUM=1
              echo "DEBUG: No existing images found, starting from: $NEXT_NUM"
            fi
          fi
          
          # Get the full issue data including uploaded assets
          echo "DEBUG: Fetching issue data..."
          gh issue view "$ISSUE_NUM" --repo "${{ github.repository }}" --json body,url > issue_data.json
          
          # Debug: Show what we got
          echo "DEBUG: Issue data received:"
          cat issue_data.json
          
          # Extract the issue body
          ISSUE_BODY=$(jq -r '.body' issue_data.json)
          echo "DEBUG: Issue body extracted, length: ${#ISSUE_BODY}"
          
          # Save issue body for debugging
          echo "$ISSUE_BODY" > issue_body_full.txt
          echo "DEBUG: Full issue body saved to file"
          
          # Look for multiple image URL patterns that GitHub uses
          echo "DEBUG: Searching for image URLs..."
          
          # Clear any existing image URLs file
          > image_urls.txt
          
          # Pattern 1: GitHub user content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 2: GitHub assets URLs  
          echo "$ISSUE_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/assets/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 3: Generic GitHub content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://[^.]*\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 4: Any https image URLs (broader catch)
          echo "$ISSUE_BODY" | grep -oE 'https://[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Remove duplicates and empty lines
          if [ -f image_urls.txt ]; then
            sort image_urls.txt | uniq | grep -v '^$' > image_urls_clean.txt || touch image_urls_clean.txt
            mv image_urls_clean.txt image_urls.txt
          else
            touch image_urls.txt
          fi
          
          echo "DEBUG: Found image URLs:"
          cat image_urls.txt
          
          # Count images found
          IMAGE_COUNT=$(wc -l < image_urls.txt)
          echo "DEBUG: Total unique image URLs found: $IMAGE_COUNT"
          
          # Download each image with enhanced error handling
          if [ -s image_urls.txt ] && [ "$IMAGE_COUNT" -gt 0 ]; then
            echo "Found $IMAGE_COUNT image(s) to download"
            
            while IFS= read -r img_url; do
              if [ -n "$img_url" ]; then
                echo "DEBUG: Processing URL: $img_url"
                
                # Extract file extension
                ext=$(echo "$img_url" | grep -oE '\.(png|jpg|jpeg|gif|webp)$' | head -1)
                if [ -z "$ext" ]; then
                  ext=".png"  # Default extension
                  echo "DEBUG: No extension found, defaulting to .png"
                fi
                
                filename="target-${NEXT_NUM}-comparison${ext}"
                filepath="$TARGET_DIR/$filename"
                
                echo "Downloading: $img_url"
                echo "         to: $filename"
                
                # Try multiple download methods
                DOWNLOAD_SUCCESS=false
                
                # Method 1: With GitHub token (for private repos)
                if curl -L -f -s \
                        -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                        -H "User-Agent: GitHub-Actions" \
                        -H "Accept: application/vnd.github.v3+json" \
                        "$img_url" -o "$filepath" 2>/dev/null; then
                  DOWNLOAD_SUCCESS=true
                  echo "âœ… Downloaded with GitHub token"
                fi
                
                # Method 2: Without token (for public URLs)
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if curl -L -f -s \
                          -H "User-Agent: Mozilla/5.0 (GitHub Actions)" \
                          "$img_url" -o "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded without token"
                  fi
                fi
                
                # Method 3: Using wget as fallback
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if wget -q --timeout=30 --tries=2 \
                          --header="User-Agent: GitHub-Actions" \
                          "$img_url" -O "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded with wget"
                  fi
                fi
                
                # Verify download
                if [ "$DOWNLOAD_SUCCESS" = true ] && [ -f "$filepath" ] && [ -s "$filepath" ]; then
                  # Check if it's actually an image file
                  file_type=$(file "$filepath" 2>/dev/null || echo "unknown")
                  if echo "$file_type" | grep -qi "image\|png\|jpeg\|gif\|webp"; then
                    echo "âœ… Successfully downloaded and verified: $filename"
                    echo "   File type: $file_type"
                    echo "   File size: $(du -h "$filepath" | cut -f1)"
                    NEXT_NUM=$((NEXT_NUM + 1))
                  else
                    echo "âŒ Downloaded file is not an image: $filename"
                    echo "   File type detected: $file_type"
                    rm -f "$filepath"
                  fi
                else
                  echo "âŒ Failed to download: $img_url"
                  [ -f "$filepath" ] && rm -f "$filepath"
                fi
                
                echo "---"
              fi
            done < image_urls.txt
          else
            echo "No images found in issue body"
            echo "DEBUG: This could mean:"
            echo "  - No images were uploaded to the issue"
            echo "  - Images are in a format/location we're not detecting"
            echo "  - The issue template format is different than expected"
          fi
          
          # Summary
          FINAL_IMAGE_COUNT=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | wc -l)
          echo ""
          echo "SUMMARY:"
          echo "  Images found in issue: $IMAGE_COUNT"
          echo "  Images successfully downloaded: $FINAL_IMAGE_COUNT"
          echo "  Images saved in: $TARGET_DIR"
          
          if [ "$FINAL_IMAGE_COUNT" -gt 0 ]; then
            echo "  Downloaded files:"
            find "$TARGET_DIR" -name "target-*-comparison.*" | sort
          fi
          
      - name: Generate LinkedIn post
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          LINKEDIN_FILE="$TARGET_DIR/linkedin-post.md"
          
          # Extract additional notes based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            # For GitHub issue forms, look for the "Additional Notes" content
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "additional.*notes\|notes\|description" | grep -v -i "additional.*notes\|notes\|description" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          else
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "update.*notes\|notes" | grep -v -i "update.*notes\|notes" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          fi
          
          # Clean up additional notes - remove empty content
          ADDITIONAL_NOTES=$(echo "$ADDITIONAL_NOTES" | xargs)
          
          # If no additional notes found, create a default description
          if [ -z "$ADDITIONAL_NOTES" ]; then
            if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
              ADDITIONAL_NOTES="Another CSS challenge completed! ðŸŽ¯"
            else
              ADDITIONAL_NOTES="Updated my CSS solution with improvements! ðŸš€"
            fi
          fi
          
          # Generate the repository URL for the solutions.html file
          REPO_URL="https://github.com/${{ github.repository }}"
          SOLUTIONS_URL="$REPO_URL/blob/main/daily-targets/${{ steps.date.outputs.formatted_date }}/solutions.html"
          
          # Create LinkedIn post with the exact format requested
          cat > "$LINKEDIN_FILE" << EOF
# LinkedIn Post for ${{ steps.date.outputs.formatted_date }}

---

Today's CSSBattle solution:

$ADDITIONAL_NOTES

$SOLUTIONS_URL

(My journal notes.)

#cssgang #CSS #CSSBattle #HTML
EOF
          
          echo "LinkedIn post generated successfully"
          echo "DEBUG: LinkedIn post content:"
          cat "$LINKEDIN_FILE"
          
      - name: Commit and push changes
        run: |
          # Configure git
          git config --local user.email "${GIT_USER_EMAIL:-${{ github.actor }}@users.noreply.github.com}"
          git config --local user.name "${GIT_USER_NAME:-${{ github.actor }}}"
          
          # Check if there are changes to commit
          git add .
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "has_changes=false" >> $GITHUB_ENV
          else
            # Pull latest changes to avoid conflicts
            echo "Pulling latest changes..."
            git fetch origin
            git rebase origin/main || {
              echo "Rebase failed, trying merge strategy..." | head -1)
                if [ -z "$ext" ]; then
                  ext=".png"  # Default extension
                  echo "DEBUG: No extension found, defaulting to .png"
                fi
                
                filename="target-${NEXT_NUM}-comparison${ext}"
                filepath="$TARGET_DIR/$filename"
                
                echo "Downloading: $img_url"
                echo "         to: $filename"
                
                # Try multiple download methods
                DOWNLOAD_SUCCESS=false
                
                # Method 1: With GitHub token (for private repos)
                if curl -L -f -s \
                        -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                        -H "User-Agent: GitHub-Actions" \
                        -H "Accept: application/vnd.github.v3+json" \
                        "$img_url" -o "$filepath" 2>/dev/null; then
                  DOWNLOAD_SUCCESS=true
                  echo "âœ… Downloaded with GitHub token"
                fi
                
                # Method 2: Without token (for public URLs)
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if curl -L -f -s \
                          -H "User-Agent: Mozilla/5.0 (GitHub Actions)" \
                          "$img_url" -o "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded without token"
                  fi
                fi
                
                # Method 3: Using wget as fallback
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if wget -q --timeout=30 --tries=2 \
                          --header="User-Agent: GitHub-Actions" \
                          "$img_url" -O "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded with wget"
                  fi
                fi
                
                # Verify download
                if [ "$DOWNLOAD_SUCCESS" = true ] && [ -f "$filepath" ] && [ -s "$filepath" ]; then
                  # Check if it's actually an image file
                  file_type=$(file "$filepath" 2>/dev/null || echo "unknown")
                  if echo "$file_type" | grep -qi "image\|png\|jpeg\|gif\|webp"; then
                    echo "âœ… Successfully downloaded and verified: $filename"
                    echo "   File type: $file_type"
                    echo "   File size: $(du -h "$filepath" | cut -f1)"
                    NEXT_NUM=$((NEXT_NUM + 1))
                  else
                    echo "âŒ Downloaded file is not an image: $filename"
                    echo "   File type detected: $file_type"
                    rm -f "$filepath"
                  fi
                else
                  echo "âŒ Failed to download: $img_url"
                  [ -f "$filepath" ] && rm -f "$filepath"
                fi
                
                echo "---"
              fi
            done < image_urls.txt
          else
            echo "No images found in issue body"
            echo "DEBUG: This could mean:"
            echo "  - No images were uploaded to the issue"
            echo "  - Images are in a format/location we're not detecting"
            echo "  - The issue template format is different than expected"
          fi
          
          # Summary
          FINAL_IMAGE_COUNT=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | wc -l)
          echo ""
          echo "SUMMARY:"
          echo "  Images found in issue: $IMAGE_COUNT"
          echo "  Images successfully downloaded: $FINAL_IMAGE_COUNT"
          echo "  Images saved in: $TARGET_DIR"
          
          if [ "$FINAL_IMAGE_COUNT" -gt 0 ]; then
            echo "  Downloaded files:"
            find "$TARGET_DIR" -name "target-*-comparison.*" | sort
          fi
          
      - name: Generate LinkedIn post
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          LINKEDIN_FILE="$TARGET_DIR/linkedin-post.md"
          
          # Extract additional notes based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            # For GitHub issue forms, look for the "Additional Notes" content
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "additional.*notes\|notes\|description" | grep -v -i "additional.*notes\|notes\|description" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          else
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "update.*notes\|notes" | grep -v -i "update.*notes\|notes" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          fi
          
          # Clean up additional notes - remove empty content
          ADDITIONAL_NOTES=$(echo "$ADDITIONAL_NOTES" | xargs)
          
          # If no additional notes found, create a default description
          if [ -z "$ADDITIONAL_NOTES" ]; then
            if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
              ADDITIONAL_NOTES="Another CSS challenge completed! ðŸŽ¯"
            else
              ADDITIONAL_NOTES="Updated my CSS solution with improvements! ðŸš€"
            fi
          fi
          
          # Generate the repository URL for the solutions.html file
          REPO_URL="https://github.com/${{ github.repository }}"
          SOLUTIONS_URL="$REPO_URL/blob/main/daily-targets/${{ steps.date.outputs.formatted_date }}/solutions.html"
          
          # Create LinkedIn post with the exact format requested
          cat > "$LINKEDIN_FILE" << EOF
# LinkedIn Post for ${{ steps.date.outputs.formatted_date }}

---

Today's CSSBattle solution:

$ADDITIONAL_NOTES

$SOLUTIONS_URL

(My journal notes.)

#cssgang #CSS #CSSBattle #HTML
EOF
          
          echo "LinkedIn post generated successfully"
          echo "DEBUG: LinkedIn post content:"
          cat "$LINKEDIN_FILE"
          
      - name: Commit and push changes
        run: |
          # Configure git
          git config --local user.email "${GIT_USER_EMAIL:-${{ github.actor }}@users.noreply.github.com}"
          git config --local user.name "${GIT_USER_NAME:-${{ github.actor }}}"
          
          # Check if there are changes to commit
          git add .
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "has_changes=false" >> $GITHUB_ENV
          else
            # Pull latest changes to avoid conflicts
            echo "Pulling latest changes..."
            git fetch origin
            git rebase origin/main || {
              echo "Rebase failed, trying merge strategy..."
              git rebase --abort
              git merge origin/main
            }
            
            # Commit changes
            if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
              COMMIT_MSG="feat: CSS Battle solution for ${{ steps.date.outputs.formatted_date }}"
            else
              COMMIT_MSG="update: CSS Battle solution for ${{ steps.date.outputs.formatted_date }}"
            fi
            
            git commit -m "$COMMIT_MSG"
            
            # Push with retry logic
            echo "Pushing changes..."
            for i in {1..3}; do
              if git push origin main; then
                echo "âœ… Changes pushed successfully"
                echo "has_changes=true" >> $GITHUB_ENV
                break
              else
                echo "âŒ Push attempt $i failed"
                if [ $i -lt 3 ]; then
                  echo "Retrying after pull..."
                  git pull origin main --rebase
                else
                  echo "All push attempts failed"
                  exit 1
                fi
              fi
            done
          fi
          
      - name: Create success comment and close issue
        if: env.has_changes != 'false'
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          
          # Count final results
          VERSION_COUNT_IN_FILE=$(grep -c "<!-- Version" "$TARGET_DIR/solutions.html" 2>/dev/null || echo 1)
          IMAGE_COUNT=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | wc -l)
          
          # Get processing summary from the image download step
          IMAGES_FOUND=$(cat image_urls.txt 2>/dev/null | wc -l || echo 0)
          
          # Calculate character counts for each CSS version (from original cleaned CSS)
          echo "DEBUG: Calculating character counts..."
          
          # Split the cleaned CSS content by ---VERSION--- markers
          cp css_cleaned.txt css_for_counting.txt
          
          # Create individual version files for counting
          version_num=1
          current_file="version_${version_num}.css"
          > "$current_file"  # Create empty first version file
          
          while IFS= read -r line || [ -n "$line" ]; do
            if [[ "$line" == "---VERSION---" ]]; then
              # Start new version file
              version_num=$((version_num + 1))
              current_file="version_${version_num}.css"
              > "$current_file"  # Create empty new version file
            else
              # Add line to current version file
              echo "$line" >> "$current_file"
            fi
          done < css_for_counting.txt
          
          # Count characters for each version (excluding any </style> tags)
          CHAR_COUNTS=""
          for i in $(seq 1 $VERSION_COUNT_IN_FILE); do
            version_file="version_${i}.css"
            if [ -f "$version_file" ]; then
              # Remove any </style> tags and count characters
              char_count=$(sed 's|</style>||g' "$version_file" | tr -d '\n' | wc -c)
              if [ $i -eq 1 ]; then
                CHAR_COUNTS="Version $i: $char_count chars"
              else
                CHAR_COUNTS="$CHAR_COUNTS - Version $i: $char_count chars"
              fi
              echo "DEBUG: Version $i character count: $char_count"
            fi
          done
          
          # Create comprehensive success comment with detailed summary
          # Using separate echo statements to avoid heredoc quoting issues
          cat > comment.txt << 'COMMENT_EOF'
# âœ… CSS Battle Solution Processed Successfully!

## ðŸ“ Location
COMMENT_EOF
          
          echo "\`$TARGET_DIR/\`" >> comment.txt
          echo "" >> comment.txt
          echo "## ðŸ“Š Processing Summary" >> comment.txt
          echo "- ðŸŽ¯ **CSS Versions Created:** $VERSION_COUNT_IN_FILE" >> comment.txt
          echo "- ðŸ–¼ï¸ **Images Found in Issue:** $IMAGES_FOUND" >> comment.txt
          echo "- ðŸ“¥ **Images Successfully Downloaded:** $IMAGE_COUNT" >> comment.txt
          echo "- ðŸ“… **Target Date:** ${{ steps.date.outputs.formatted_date }}" >> comment.txt
          echo "- ðŸ”„ **Operation Type:** ${{ steps.operation.outputs.type }}" >> comment.txt
          echo "" >> comment.txt
          echo "## âš¡ Char Count" >> comment.txt
          echo "$CHAR_COUNTS" >> comment.txt
          echo "" >> comment.txt
          echo "## ðŸ“„ Files Created/Updated" >> comment.txt
          echo "" >> comment.txt
          echo "### Solutions" >> comment.txt
          echo "- âœ… \`solutions.html\` - Your CSS solution ($VERSION_COUNT_IN_FILE version(s))" >> comment.txt
          echo "" >> comment.txt
          echo "### Content" >> comment.txt
          echo "- âœ… \`linkedin-post.md\` - Ready-to-post LinkedIn content" >> comment.txt
          echo "" >> comment.txt
          echo "### Images" >> comment.txt
          
          if [ "$IMAGE_COUNT" -gt 0 ]; then
            echo "ðŸ“¸ **Downloaded Images:**" >> comment.txt
            find "$TARGET_DIR" -name "target-*-comparison.*" | sort | while read -r img; do
              # Get file size for each image
              size=$(du -h "$img" 2>/dev/null | cut -f1 || echo "?")
              echo "- âœ… \`$(basename "$img")\` (${size})" >> comment.txt
            done
          else
            echo "- â„¹ï¸ No images were uploaded or found" >> comment.txt
            if [ "$IMAGES_FOUND" -gt 0 ]; then
              echo "- âš ï¸ Found $IMAGES_FOUND image URL(s) but download failed" >> comment.txt
            fi
          fi
          
          echo "" >> comment.txt
          echo "## ðŸ”— Quick Links" >> comment.txt
          echo "- ðŸ“± **LinkedIn Post:** [\`linkedin-post.md\`](${{ github.server_url }}/${{ github.repository }}/blob/main/$TARGET_DIR/linkedin-post.md)" >> comment.txt
          echo "- ðŸ’» **CSS Solution:** [\`solutions.html\`](${{ github.server_url }}/${{ github.repository }}/blob/main/$TARGET_DIR/solutions.html)" >> comment.txt
          echo "- ðŸ“ **Full Directory:** [\`$TARGET_DIR/\`](${{ github.server_url }}/${{ github.repository }}/tree/main/$TARGET_DIR)" >> comment.txt
          echo "" >> comment.txt
          echo "## ðŸŽ‰ Ready for Battle!" >> comment.txt
          echo "Your solution is now organized and ready for sharing. Click the LinkedIn post link above to copy the content!" >> comment.txt
          echo "" >> comment.txt
          echo "---" >> comment.txt
          echo "*âœ¨ Processed by GitHub Actions on $(date)*" >> comment.txt
          echo "*ðŸ”§ Workflow: [\`${{ github.workflow }}\`](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*" >> comment.txt
          
          # Post comment and close issue
          gh issue comment "${{ github.event.issue.number }}" \
            --repo "${{ github.repository }}" \
            --body-file comment.txt
          
          gh issue close "${{ github.event.issue.number }}" \
            --repo "${{ github.repository }}" \
            --reason completed

      - name: Cleanup temporary files
        if: always()
        run: |
          echo "ðŸ§¹ Cleaning up temporary files..."
          
          # List of temporary files that may be created during the workflow
          TEMP_FILES=(
            "issue_body.txt"
            "css_content.txt"
            "css_content_raw.txt"
            "css_cleaned.txt"
            "css_for_counting.txt"
            "image_urls.txt"
            "image_urls_clean.txt"
            "formatted_date_backup.txt"
            "date_output.txt"
            "issue_data.json"
            "issue_body_full.txt"
            "comment.txt"
            "temp_solutions.html"
          )
          
          # Remove each temporary file if it exists
          for file in "${TEMP_FILES[@]}"; do
            if [ -f "$file" ]; then
              echo "Removing: $file"
              rm -f "$file"
            fi
          done
          
          # Remove version-specific character counting files
          rm -f version_*.css 2>/dev/null || true
          
          # Double-check for any other temporary files with common patterns
          find . -maxdepth 1 -name "*.tmp" -type f -delete 2>/dev/null || true
          find . -maxdepth 1 -name "temp_*" -type f -delete 2>/dev/null || true
          
          echo "âœ… Cleanup completed - repository is clean"
          
          # Verify cleanup (optional debug)
          echo "DEBUG: Remaining files in root directory:"
          ls -laname: Create or Update Solutions File for Daily CSSBattle
on:
  issues:
    types: [opened]

permissions:
  contents: write
  issues: write
  
jobs:
  process-solutions-file:
    runs-on: ubuntu-latest
    if: contains(github.event.issue.title, '[CSSBattle]') || contains(github.event.issue.title, '[CSSBattle-UPDATE]')
    
    env:
      GIT_USER_EMAIL: ${{ secrets.GIT_USER_EMAIL }}
      GIT_USER_NAME: ${{ secrets.GIT_USER_NAME }}
    
    steps:
      - name: Debug trigger conditions
        run: |
          echo "ðŸ” DEBUG: Trigger Analysis"
          echo "Issue title: '${{ github.event.issue.title }}'"
          echo "Issue number: ${{ github.event.issue.number }}"
          echo "Issue author: ${{ github.event.issue.user.login }}"
          echo "Repository: ${{ github.repository }}"
          echo "Event action: ${{ github.event.action }}"
          echo ""
          echo "ðŸ” Checking trigger conditions:"
          if [[ "${{ github.event.issue.title }}" == *"[CSSBattle]"* ]]; then
            echo "âœ… Title contains '[CSSBattle]'"
          else
            echo "âŒ Title does NOT contain '[CSSBattle]'"
          fi
          
          if [[ "${{ github.event.issue.title }}" == *"[CSSBattle-UPDATE]"* ]]; then
            echo "âœ… Title contains '[CSSBattle-UPDATE]'"
          else
            echo "âŒ Title does NOT contain '[CSSBattle-UPDATE]'"
          fi
          echo ""
          
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
      
      - name: Determine operation type
        id: operation
        run: |
          if [[ "${{ github.event.issue.title }}" == *"[CSSBattle-UPDATE]"* ]]; then
            echo "type=update" >> $GITHUB_OUTPUT
            echo "Operation: UPDATE"
          else
            echo "type=create" >> $GITHUB_OUTPUT
            echo "Operation: CREATE"
          fi
      
      - name: Extract and validate issue data
        id: extract
        run: |
          # Save issue body to file for processing
          cat > issue_body.txt << 'EOF'
          ${{ github.event.issue.body }}
          EOF
          
          echo "DEBUG: Issue body content:"
          cat issue_body.txt
          echo "DEBUG: ===== END OF ISSUE BODY ====="
          
          # Validate issue body is not empty
          if [ ! -s issue_body.txt ]; then
            echo "ERROR: Issue body is empty"
            exit 1
          fi
          
          # Extract date based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "DEBUG: Extracting date for CREATE operation"
            
            # GitHub issue forms create structured output, look for the date field
            # The issue body will contain the date value after field processing
            
            # Method 1: Look for date pattern directly (for "Jun 8, 2025" format)
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Method 2: If not found, look for numeric date formats
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{1,2}/[0-9]{1,2}/[0-9]{4}" issue_body.txt | head -1)
            fi
            
            # Method 3: Look for ISO format dates
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{4}-[0-9]{2}-[0-9]{2}" issue_body.txt | head -1)
            fi
            
            # Method 4: Search around common labels (fallback)
            if [ -z "$DATE" ]; then
              # Look for lines that might contain dates after field labels
              DATE=$(grep -A 5 -i "date\|when\|day" issue_body.txt | grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" | head -1)
            fi
            
          else
            echo "DEBUG: Extracting date for UPDATE operation"
            # For update operations, look for target date
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Extract update type and version number (implement as needed for UPDATE template)
            UPDATE_TYPE=$(grep -A 3 -i "update.*type" issue_body.txt | grep -v -i "update.*type" | head -1 | xargs)
            VERSION_NUMBER=$(grep -A 3 -i "version.*number" issue_body.txt | grep -v -i "version.*number" | head -1 | xargs)
            
            echo "update_type=$UPDATE_TYPE" >> $GITHUB_OUTPUT
            echo "version_number=$VERSION_NUMBER" >> $GITHUB_OUTPUT
          fi
          
          echo "parsed_date=$DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Extracted date: '$DATE'"
          
          # Validate date was extracted
          if [ -z "$DATE" ]; then
            echo "ERROR: Could not extract date from issue."
            echo "DEBUG: Issue body for troubleshooting:"
            echo "--- ISSUE BODY START ---"
            cat issue_body.txt
            echo "--- ISSUE BODY END ---"
            echo ""
            echo "Expected format examples:"
            echo "  - Jun 8, 2025"
            echo "  - January 15, 2025"
            echo "  - 6/8/2025"
            echo "  - 2025-06-08"
            exit 1
          fi
          
      - name: Convert and validate date format
        id: date
        run: |
          DATE="${{ steps.extract.outputs.parsed_date }}"
          echo "DEBUG: Converting date: '$DATE'"
          
          # Enhanced date parsing specifically for your formats
          if [ -n "$DATE" ]; then
            # Try GNU date first (handles "Jun 8, 2025" format perfectly)
            if FORMATTED_DATE=$(date -d "$DATE" +%Y-%m-%d 2>/dev/null); then
              echo "DEBUG: Successfully parsed with GNU date: $FORMATTED_DATE"
            else
              echo "DEBUG: GNU date failed, attempting manual parsing for format like 'Jun 8, 2025'"
              
              # Clean up the date string - remove extra spaces and commas
              DATE_CLEAN=$(echo "$DATE" | sed 's/,/ /g' | tr -s ' ' | xargs)
              echo "DEBUG: Cleaned date: '$DATE_CLEAN'"
              
              # Extract components for "Mon D, YYYY" or "Mon D YYYY" format
              if echo "$DATE_CLEAN" | grep -qE "^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2}[[:space:]]+[0-9]{4}$"; then
                
                # Extract month name
                MONTH_NAME=$(echo "$DATE_CLEAN" | cut -d' ' -f1)
                # Extract day
                DAY_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f2)
                # Extract year  
                YEAR_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f3)
                
                echo "DEBUG: Extracted - Month: '$MONTH_NAME', Day: '$DAY_NUM', Year: '$YEAR_NUM'"
                
                # Convert month abbreviation to number
                case "$MONTH_NAME" in
                  Jan|January) MONTH_NUM="01" ;;
                  Feb|February) MONTH_NUM="02" ;;
                  Mar|March) MONTH_NUM="03" ;;
                  Apr|April) MONTH_NUM="04" ;;
                  May) MONTH_NUM="05" ;;
                  Jun|June) MONTH_NUM="06" ;;
                  Jul|July) MONTH_NUM="07" ;;
                  Aug|August) MONTH_NUM="08" ;;
                  Sep|September) MONTH_NUM="09" ;;
                  Oct|October) MONTH_NUM="10" ;;
                  Nov|November) MONTH_NUM="11" ;;
                  Dec|December) MONTH_NUM="12" ;;
                  *) 
                    echo "ERROR: Could not parse month: '$MONTH_NAME'"
                    echo "Expected: Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec"
                    echo "Or full names: January, February, etc."
                    exit 1
                    ;;
                esac
                
                # Validate day (1-31)
                if ! [[ "$DAY_NUM" =~ ^[0-9]+$ ]] || [ "$DAY_NUM" -lt 1 ] || [ "$DAY_NUM" -gt 31 ]; then
                  echo "ERROR: Invalid day: '$DAY_NUM' (must be 1-31)"
                  exit 1
                fi
                
                # Validate year (reasonable range)
                if ! [[ "$YEAR_NUM" =~ ^[0-9]{4}$ ]] || [ "$YEAR_NUM" -lt 2020 ] || [ "$YEAR_NUM" -gt 2030 ]; then
                  echo "ERROR: Invalid year: '$YEAR_NUM' (must be 2020-2030)"
                  exit 1
                fi
                
                # Format as YYYY-MM-DD with zero padding
                FORMATTED_DATE=$(printf "%04d-%02d-%02d" "$YEAR_NUM" "$MONTH_NUM" "$DAY_NUM")
                echo "DEBUG: Manual parsing result: $FORMATTED_DATE"
                
              else
                echo "ERROR: Date format not recognized: '$DATE_CLEAN'"
                echo "Expected format: 'Jun 8, 2025' or 'June 8, 2025'"
                echo "Received: '$DATE'"
                exit 1
              fi
            fi
          else
            echo "ERROR: No date provided"
            exit 1
          fi
          
          # Final validation of formatted date
          if ! echo "$FORMATTED_DATE" | grep -qE "^[0-9]{4}-[0-9]{2}-[0-9]{2}$"; then
            echo "ERROR: Invalid formatted date: '$FORMATTED_DATE'"
            echo "Expected format: YYYY-MM-DD"
            exit 1
          fi
          
          # Additional sanity check - verify it's a valid date
          if ! date -d "$FORMATTED_DATE" >/dev/null 2>&1; then
            echo "ERROR: '$FORMATTED_DATE' is not a valid date"
            exit 1
          fi
          
          echo "formatted_date=$FORMATTED_DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Final formatted date: $FORMATTED_DATE"
          
      - name: Extract and validate CSS content
        id: css
        run: |
          echo "DEBUG: Extracting CSS content for ${{ steps.operation.outputs.type }} operation"
          
          # For GitHub issue forms, the CSS content is in the issue body
          # Look for CSS code blocks or direct CSS content
          
          # Method 1: Look for CSS content in code blocks (```css ... ```)
          if sed -n '/```css/,/```/p' issue_body.txt | sed '1d;$d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
            echo "DEBUG: Found CSS in code blocks"
          else
            # Method 2: Look for CSS content in HTML style blocks
            if grep -A 50 -B 5 "<style>" issue_body.txt | sed '/^--$/d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
              echo "DEBUG: Found CSS with <style> tags"
            else
              # Method 3: Look for any CSS-like content (fallback)
              if grep -A 20 -i "css\|style" issue_body.txt | grep -E "(background|width|height|margin|padding|color)" > css_content_raw.txt && [ -s css_content_raw.txt ]; then
                echo "DEBUG: Found CSS-like content"
              else
                echo "ERROR: No CSS content found in issue"
                echo "DEBUG: Issue body for troubleshooting:"
                echo "--- ISSUE BODY START ---"
                cat issue_body.txt
                echo "--- ISSUE BODY END ---"
                echo ""
                echo "Expected: CSS code in \`\`\`css blocks or <style> tags"
                exit 1
              fi
            fi
          fi
          
          # Clean up the CSS content
          # Remove empty lines and clean up formatting
          sed '/^[[:space:]]*$/d' css_content_raw.txt > css_content.txt
          
          # Validate CSS content exists after cleaning
          if [ ! -s css_content.txt ]; then
            echo "ERROR: CSS content is empty after processing"
            echo "DEBUG: Raw CSS content was:"
            cat css_content_raw.txt
            exit 1
          fi
          
          echo "DEBUG: CSS content extracted successfully:"
          echo "--- CSS CONTENT START ---"
          head -10 css_content.txt
          if [ $(wc -l < css_content.txt) -gt 10 ]; then
            echo "... (truncated, total lines: $(wc -l < css_content.txt))"
          fi
          echo "--- CSS CONTENT END ---"
          
          # Count versions by counting ---VERSION--- separators
          VERSION_COUNT=$(grep -c "---VERSION---" css_content.txt 2>/dev/null || echo 0)
          VERSION_COUNT=$((VERSION_COUNT + 1))
          echo "version_count=$VERSION_COUNT" >> $GITHUB_OUTPUT
          echo "DEBUG: Found $VERSION_COUNT CSS versions"
          
      - name: Create directory structure
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          echo "DEBUG: Creating directory: $TARGET_DIR"
          
          mkdir -p "$TARGET_DIR"
          
          # Verify directory creation
          if [ ! -d "$TARGET_DIR" ]; then
            echo "ERROR: Failed to create directory: $TARGET_DIR"
            exit 1
          fi
          
          echo "DEBUG: Directory created successfully"
          ls -la daily-targets/
          
      - name: Create or update solutions file
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          SOLUTIONS_FILE="$TARGET_DIR/solutions.html"
          
          echo "DEBUG: Processing solutions file: $SOLUTIONS_FILE"
          
          # Clean CSS content - remove ```css and ``` markers, keep only the actual CSS
          sed -e '/^```css$/d' -e '/^```$/d' css_content.txt > css_cleaned.txt
          
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "Creating new solutions file..."
            
            # Start with Version 1 comment
            echo "<!-- Version 1 -->" > "$SOLUTIONS_FILE"
            
            # Process CSS content with version separation
            version_num=1
            while IFS= read -r line || [ -n "$line" ]; do
              if [[ "$line" == "---VERSION---" ]]; then
                # Close current version and start new one
                echo "</style>" >> "$SOLUTIONS_FILE"
                echo "" >> "$SOLUTIONS_FILE"
                version_num=$((version_num + 1))
                echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
              else
                echo "$line" >> "$SOLUTIONS_FILE"
              fi
            done < css_cleaned.txt
            
            # Ensure file ends with </style>
            if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
              echo "</style>" >> "$SOLUTIONS_FILE"
            fi
            
          else
            echo "Updating existing solutions file..."
            
            if [ ! -f "$SOLUTIONS_FILE" ]; then
              echo "ERROR: Solutions file not found: $SOLUTIONS_FILE"
              echo "Available dates:"
              ls daily-targets/ 2>/dev/null || echo "No existing solutions found"
              exit 1
            fi
            
            case "${{ steps.extract.outputs.update_type }}" in
              "Add new CSS version(s)")
                echo "Adding new CSS versions..."
                # Find last version number
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                # Ensure file ends with </style>
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              "Replace existing CSS version(s)")
                if [ -n "${{ steps.extract.outputs.version_number }}" ]; then
                  echo "Note: Version replacement is complex and not fully implemented"
                  echo "Adding as new version instead..."
                  LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                  NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                  
                  echo "" >> "$SOLUTIONS_FILE"
                  echo "<!-- Version $NEXT_VERSION (replacement for Version ${{ steps.extract.outputs.version_number }}) -->" >> "$SOLUTIONS_FILE"
                  
                  # Add cleaned CSS content
                  cat css_cleaned.txt >> "$SOLUTIONS_FILE"
                  
                  if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                    echo "</style>" >> "$SOLUTIONS_FILE"
                  fi
                else
                  echo "ERROR: Version number required for replacement"
                  exit 1
                fi
                ;;
                
              "Add new comparison image(s)")
                echo "Images will be processed in next step..."
                ;;
                
              "Add both CSS and images")
                echo "Adding new CSS versions and images..."
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              *)
                echo "ERROR: Unknown update type: ${{ steps.extract.outputs.update_type }}"
                exit 1
                ;;
            esac
          fi
          
          echo "Solutions file processing complete"
          echo "DEBUG: Final solutions file content:"
          cat "$SOLUTIONS_FILE"
          
      - name: Download and process images
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          ISSUE_NUM="${{ github.event.issue.number }}"
          
          echo "DEBUG: Processing images for issue #$ISSUE_NUM"
          echo "DEBUG: Target directory: $TARGET_DIR"
          
          # Determine next available image number
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            NEXT_NUM=1
          else
            # Find existing images and get next number
            EXISTING_IMAGES=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | sort)
            if [ -n "$EXISTING_IMAGES" ]; then
              LAST_NUM=$(echo "$EXISTING_IMAGES" | sed 's/.*target-\([0-9]\+\)-comparison\..*/\1/' | sort -n | tail -1)
              NEXT_NUM=$((LAST_NUM + 1))
              echo "DEBUG: Found existing images, starting from number: $NEXT_NUM"
            else
              NEXT_NUM=1
              echo "DEBUG: No existing images found, starting from: $NEXT_NUM"
            fi
          fi
          
          # Get the full issue data including uploaded assets
          echo "DEBUG: Fetching issue data..."
          gh issue view "$ISSUE_NUM" --repo "${{ github.repository }}" --json body,url > issue_data.json
          
          # Debug: Show what we got
          echo "DEBUG: Issue data received:"
          cat issue_data.json
          
          # Extract the issue body
          ISSUE_BODY=$(jq -r '.body' issue_data.json)
          echo "DEBUG: Issue body extracted, length: ${#ISSUE_BODY}"
          
          # Save issue body for debugging
          echo "$ISSUE_BODY" > issue_body_full.txt
          echo "DEBUG: Full issue body saved to file"
          
          # Look for multiple image URL patterns that GitHub uses
          echo "DEBUG: Searching for image URLs..."
          
          # Clear any existing image URLs file
          > image_urls.txt
          
          # Pattern 1: GitHub user content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 2: GitHub assets URLs  
          echo "$ISSUE_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/assets/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 3: Generic GitHub content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://[^.]*\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 4: Any https image URLs (broader catch)
          echo "$ISSUE_BODY" | grep -oE 'https://[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Remove duplicates and empty lines
          if [ -f image_urls.txt ]; then
            sort image_urls.txt | uniq | grep -v '^name: Create or Update Solutions File for Daily CSSBattle
on:
  issues:
    types: [opened]

permissions:
  contents: write
  issues: write
  
jobs:
  process-solutions-file:
    runs-on: ubuntu-latest
    if: contains(github.event.issue.title, '[CSSBattle]') || contains(github.event.issue.title, '[CSSBattle-UPDATE]')
    
    env:
      GIT_USER_EMAIL: ${{ secrets.GIT_USER_EMAIL }}
      GIT_USER_NAME: ${{ secrets.GIT_USER_NAME }}
    
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
      
      - name: Determine operation type
        id: operation
        run: |
          if [[ "${{ github.event.issue.title }}" == *"[CSSBattle-UPDATE]"* ]]; then
            echo "type=update" >> $GITHUB_OUTPUT
            echo "Operation: UPDATE"
          else
            echo "type=create" >> $GITHUB_OUTPUT
            echo "Operation: CREATE"
          fi
      
      - name: Extract and validate issue data
        id: extract
        run: |
          # Save issue body to file for processing
          cat > issue_body.txt << 'EOF'
          ${{ github.event.issue.body }}
          EOF
          
          echo "DEBUG: Issue body content:"
          cat issue_body.txt
          echo "DEBUG: ===== END OF ISSUE BODY ====="
          
          # Validate issue body is not empty
          if [ ! -s issue_body.txt ]; then
            echo "ERROR: Issue body is empty"
            exit 1
          fi
          
          # Extract date based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "DEBUG: Extracting date for CREATE operation"
            
            # GitHub issue forms create structured output, look for the date field
            # The issue body will contain the date value after field processing
            
            # Method 1: Look for date pattern directly (for "Jun 8, 2025" format)
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Method 2: If not found, look for numeric date formats
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{1,2}/[0-9]{1,2}/[0-9]{4}" issue_body.txt | head -1)
            fi
            
            # Method 3: Look for ISO format dates
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{4}-[0-9]{2}-[0-9]{2}" issue_body.txt | head -1)
            fi
            
            # Method 4: Search around common labels (fallback)
            if [ -z "$DATE" ]; then
              # Look for lines that might contain dates after field labels
              DATE=$(grep -A 5 -i "date\|when\|day" issue_body.txt | grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" | head -1)
            fi
            
          else
            echo "DEBUG: Extracting date for UPDATE operation"
            # For update operations, look for target date
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Extract update type and version number (implement as needed for UPDATE template)
            UPDATE_TYPE=$(grep -A 3 -i "update.*type" issue_body.txt | grep -v -i "update.*type" | head -1 | xargs)
            VERSION_NUMBER=$(grep -A 3 -i "version.*number" issue_body.txt | grep -v -i "version.*number" | head -1 | xargs)
            
            echo "update_type=$UPDATE_TYPE" >> $GITHUB_OUTPUT
            echo "version_number=$VERSION_NUMBER" >> $GITHUB_OUTPUT
          fi
          
          echo "parsed_date=$DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Extracted date: '$DATE'"
          
          # Validate date was extracted
          if [ -z "$DATE" ]; then
            echo "ERROR: Could not extract date from issue."
            echo "DEBUG: Issue body for troubleshooting:"
            echo "--- ISSUE BODY START ---"
            cat issue_body.txt
            echo "--- ISSUE BODY END ---"
            echo ""
            echo "Expected format examples:"
            echo "  - Jun 8, 2025"
            echo "  - January 15, 2025"
            echo "  - 6/8/2025"
            echo "  - 2025-06-08"
            exit 1
          fi
          
      - name: Convert and validate date format
        id: date
        run: |
          DATE="${{ steps.extract.outputs.parsed_date }}"
          echo "DEBUG: Converting date: '$DATE'"
          
          # Enhanced date parsing specifically for your formats
          if [ -n "$DATE" ]; then
            # Try GNU date first (handles "Jun 8, 2025" format perfectly)
            if FORMATTED_DATE=$(date -d "$DATE" +%Y-%m-%d 2>/dev/null); then
              echo "DEBUG: Successfully parsed with GNU date: $FORMATTED_DATE"
            else
              echo "DEBUG: GNU date failed, attempting manual parsing for format like 'Jun 8, 2025'"
              
              # Clean up the date string - remove extra spaces and commas
              DATE_CLEAN=$(echo "$DATE" | sed 's/,/ /g' | tr -s ' ' | xargs)
              echo "DEBUG: Cleaned date: '$DATE_CLEAN'"
              
              # Extract components for "Mon D, YYYY" or "Mon D YYYY" format
              if echo "$DATE_CLEAN" | grep -qE "^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2}[[:space:]]+[0-9]{4}$"; then
                
                # Extract month name
                MONTH_NAME=$(echo "$DATE_CLEAN" | cut -d' ' -f1)
                # Extract day
                DAY_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f2)
                # Extract year  
                YEAR_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f3)
                
                echo "DEBUG: Extracted - Month: '$MONTH_NAME', Day: '$DAY_NUM', Year: '$YEAR_NUM'"
                
                # Convert month abbreviation to number
                case "$MONTH_NAME" in
                  Jan|January) MONTH_NUM="01" ;;
                  Feb|February) MONTH_NUM="02" ;;
                  Mar|March) MONTH_NUM="03" ;;
                  Apr|April) MONTH_NUM="04" ;;
                  May) MONTH_NUM="05" ;;
                  Jun|June) MONTH_NUM="06" ;;
                  Jul|July) MONTH_NUM="07" ;;
                  Aug|August) MONTH_NUM="08" ;;
                  Sep|September) MONTH_NUM="09" ;;
                  Oct|October) MONTH_NUM="10" ;;
                  Nov|November) MONTH_NUM="11" ;;
                  Dec|December) MONTH_NUM="12" ;;
                  *) 
                    echo "ERROR: Could not parse month: '$MONTH_NAME'"
                    echo "Expected: Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec"
                    echo "Or full names: January, February, etc."
                    exit 1
                    ;;
                esac
                
                # Validate day (1-31)
                if ! [[ "$DAY_NUM" =~ ^[0-9]+$ ]] || [ "$DAY_NUM" -lt 1 ] || [ "$DAY_NUM" -gt 31 ]; then
                  echo "ERROR: Invalid day: '$DAY_NUM' (must be 1-31)"
                  exit 1
                fi
                
                # Validate year (reasonable range)
                if ! [[ "$YEAR_NUM" =~ ^[0-9]{4}$ ]] || [ "$YEAR_NUM" -lt 2020 ] || [ "$YEAR_NUM" -gt 2030 ]; then
                  echo "ERROR: Invalid year: '$YEAR_NUM' (must be 2020-2030)"
                  exit 1
                fi
                
                # Format as YYYY-MM-DD with zero padding
                FORMATTED_DATE=$(printf "%04d-%02d-%02d" "$YEAR_NUM" "$MONTH_NUM" "$DAY_NUM")
                echo "DEBUG: Manual parsing result: $FORMATTED_DATE"
                
              else
                echo "ERROR: Date format not recognized: '$DATE_CLEAN'"
                echo "Expected format: 'Jun 8, 2025' or 'June 8, 2025'"
                echo "Received: '$DATE'"
                exit 1
              fi
            fi
          else
            echo "ERROR: No date provided"
            exit 1
          fi
          
          # Final validation of formatted date
          if ! echo "$FORMATTED_DATE" | grep -qE "^[0-9]{4}-[0-9]{2}-[0-9]{2}$"; then
            echo "ERROR: Invalid formatted date: '$FORMATTED_DATE'"
            echo "Expected format: YYYY-MM-DD"
            exit 1
          fi
          
          # Additional sanity check - verify it's a valid date
          if ! date -d "$FORMATTED_DATE" >/dev/null 2>&1; then
            echo "ERROR: '$FORMATTED_DATE' is not a valid date"
            exit 1
          fi
          
          echo "formatted_date=$FORMATTED_DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Final formatted date: $FORMATTED_DATE"
          
      - name: Extract and validate CSS content
        id: css
        run: |
          echo "DEBUG: Extracting CSS content for ${{ steps.operation.outputs.type }} operation"
          
          # For GitHub issue forms, the CSS content is in the issue body
          # Look for CSS code blocks or direct CSS content
          
          # Method 1: Look for CSS content in code blocks (```css ... ```)
          if sed -n '/```css/,/```/p' issue_body.txt | sed '1d;$d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
            echo "DEBUG: Found CSS in code blocks"
          else
            # Method 2: Look for CSS content in HTML style blocks
            if grep -A 50 -B 5 "<style>" issue_body.txt | sed '/^--$/d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
              echo "DEBUG: Found CSS with <style> tags"
            else
              # Method 3: Look for any CSS-like content (fallback)
              if grep -A 20 -i "css\|style" issue_body.txt | grep -E "(background|width|height|margin|padding|color)" > css_content_raw.txt && [ -s css_content_raw.txt ]; then
                echo "DEBUG: Found CSS-like content"
              else
                echo "ERROR: No CSS content found in issue"
                echo "DEBUG: Issue body for troubleshooting:"
                echo "--- ISSUE BODY START ---"
                cat issue_body.txt
                echo "--- ISSUE BODY END ---"
                echo ""
                echo "Expected: CSS code in \`\`\`css blocks or <style> tags"
                exit 1
              fi
            fi
          fi
          
          # Clean up the CSS content
          # Remove empty lines and clean up formatting
          sed '/^[[:space:]]*$/d' css_content_raw.txt > css_content.txt
          
          # Validate CSS content exists after cleaning
          if [ ! -s css_content.txt ]; then
            echo "ERROR: CSS content is empty after processing"
            echo "DEBUG: Raw CSS content was:"
            cat css_content_raw.txt
            exit 1
          fi
          
          echo "DEBUG: CSS content extracted successfully:"
          echo "--- CSS CONTENT START ---"
          head -10 css_content.txt
          if [ $(wc -l < css_content.txt) -gt 10 ]; then
            echo "... (truncated, total lines: $(wc -l < css_content.txt))"
          fi
          echo "--- CSS CONTENT END ---"
          
          # Count versions by counting ---VERSION--- separators
          VERSION_COUNT=$(grep -c "---VERSION---" css_content.txt 2>/dev/null || echo 0)
          VERSION_COUNT=$((VERSION_COUNT + 1))
          echo "version_count=$VERSION_COUNT" >> $GITHUB_OUTPUT
          echo "DEBUG: Found $VERSION_COUNT CSS versions"
          
      - name: Create directory structure
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          echo "DEBUG: Creating directory: $TARGET_DIR"
          
          mkdir -p "$TARGET_DIR"
          
          # Verify directory creation
          if [ ! -d "$TARGET_DIR" ]; then
            echo "ERROR: Failed to create directory: $TARGET_DIR"
            exit 1
          fi
          
          echo "DEBUG: Directory created successfully"
          ls -la daily-targets/
          
      - name: Create or update solutions file
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          SOLUTIONS_FILE="$TARGET_DIR/solutions.html"
          
          echo "DEBUG: Processing solutions file: $SOLUTIONS_FILE"
          
          # Clean CSS content - remove ```css and ``` markers, keep only the actual CSS
          sed -e '/^```css$/d' -e '/^```$/d' css_content.txt > css_cleaned.txt
          
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "Creating new solutions file..."
            
            # Start with Version 1 comment
            echo "<!-- Version 1 -->" > "$SOLUTIONS_FILE"
            
            # Process CSS content with version separation
            version_num=1
            while IFS= read -r line || [ -n "$line" ]; do
              if [[ "$line" == "---VERSION---" ]]; then
                # Close current version and start new one
                echo "</style>" >> "$SOLUTIONS_FILE"
                echo "" >> "$SOLUTIONS_FILE"
                version_num=$((version_num + 1))
                echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
              else
                echo "$line" >> "$SOLUTIONS_FILE"
              fi
            done < css_cleaned.txt
            
            # Ensure file ends with </style>
            if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
              echo "</style>" >> "$SOLUTIONS_FILE"
            fi
            
          else
            echo "Updating existing solutions file..."
            
            if [ ! -f "$SOLUTIONS_FILE" ]; then
              echo "ERROR: Solutions file not found: $SOLUTIONS_FILE"
              echo "Available dates:"
              ls daily-targets/ 2>/dev/null || echo "No existing solutions found"
              exit 1
            fi
            
            case "${{ steps.extract.outputs.update_type }}" in
              "Add new CSS version(s)")
                echo "Adding new CSS versions..."
                # Find last version number
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                # Ensure file ends with </style>
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              "Replace existing CSS version(s)")
                if [ -n "${{ steps.extract.outputs.version_number }}" ]; then
                  echo "Note: Version replacement is complex and not fully implemented"
                  echo "Adding as new version instead..."
                  LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                  NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                  
                  echo "" >> "$SOLUTIONS_FILE"
                  echo "<!-- Version $NEXT_VERSION (replacement for Version ${{ steps.extract.outputs.version_number }}) -->" >> "$SOLUTIONS_FILE"
                  
                  # Add cleaned CSS content
                  cat css_cleaned.txt >> "$SOLUTIONS_FILE"
                  
                  if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                    echo "</style>" >> "$SOLUTIONS_FILE"
                  fi
                else
                  echo "ERROR: Version number required for replacement"
                  exit 1
                fi
                ;;
                
              "Add new comparison image(s)")
                echo "Images will be processed in next step..."
                ;;
                
              "Add both CSS and images")
                echo "Adding new CSS versions and images..."
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              *)
                echo "ERROR: Unknown update type: ${{ steps.extract.outputs.update_type }}"
                exit 1
                ;;
            esac
          fi
          
          echo "Solutions file processing complete"
          echo "DEBUG: Final solutions file content:"
          cat "$SOLUTIONS_FILE"
          
      - name: Download and process images
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          ISSUE_NUM="${{ github.event.issue.number }}"
          
          echo "DEBUG: Processing images for issue #$ISSUE_NUM"
          echo "DEBUG: Target directory: $TARGET_DIR"
          
          # Determine next available image number
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            NEXT_NUM=1
          else
            # Find existing images and get next number
            EXISTING_IMAGES=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | sort)
            if [ -n "$EXISTING_IMAGES" ]; then
              LAST_NUM=$(echo "$EXISTING_IMAGES" | sed 's/.*target-\([0-9]\+\)-comparison\..*/\1/' | sort -n | tail -1)
              NEXT_NUM=$((LAST_NUM + 1))
              echo "DEBUG: Found existing images, starting from number: $NEXT_NUM"
            else
              NEXT_NUM=1
              echo "DEBUG: No existing images found, starting from: $NEXT_NUM"
            fi
          fi
          
          # Get the full issue data including uploaded assets
          echo "DEBUG: Fetching issue data..."
          gh issue view "$ISSUE_NUM" --repo "${{ github.repository }}" --json body,url > issue_data.json
          
          # Debug: Show what we got
          echo "DEBUG: Issue data received:"
          cat issue_data.json
          
          # Extract the issue body
          ISSUE_BODY=$(jq -r '.body' issue_data.json)
          echo "DEBUG: Issue body extracted, length: ${#ISSUE_BODY}"
          
          # Save issue body for debugging
          echo "$ISSUE_BODY" > issue_body_full.txt
          echo "DEBUG: Full issue body saved to file"
          
          # Look for multiple image URL patterns that GitHub uses
          echo "DEBUG: Searching for image URLs..."
          
          # Clear any existing image URLs file
          > image_urls.txt
          
          # Pattern 1: GitHub user content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 2: GitHub assets URLs  
          echo "$ISSUE_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/assets/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 3: Generic GitHub content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://[^.]*\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 4: Any https image URLs (broader catch)
          echo "$ISSUE_BODY" | grep -oE 'https://[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Remove duplicates and empty lines
          if [ -f image_urls.txt ]; then
            sort image_urls.txt | uniq | grep -v '^$' > image_urls_clean.txt || touch image_urls_clean.txt
            mv image_urls_clean.txt image_urls.txt
          else
            touch image_urls.txt
          fi
          
          echo "DEBUG: Found image URLs:"
          cat image_urls.txt
          
          # Count images found
          IMAGE_COUNT=$(wc -l < image_urls.txt)
          echo "DEBUG: Total unique image URLs found: $IMAGE_COUNT"
          
          # Download each image with enhanced error handling
          if [ -s image_urls.txt ] && [ "$IMAGE_COUNT" -gt 0 ]; then
            echo "Found $IMAGE_COUNT image(s) to download"
            
            while IFS= read -r img_url; do
              if [ -n "$img_url" ]; then
                echo "DEBUG: Processing URL: $img_url"
                
                # Extract file extension
                ext=$(echo "$img_url" | grep -oE '\.(png|jpg|jpeg|gif|webp)$' | head -1)
                if [ -z "$ext" ]; then
                  ext=".png"  # Default extension
                  echo "DEBUG: No extension found, defaulting to .png"
                fi
                
                filename="target-${NEXT_NUM}-comparison${ext}"
                filepath="$TARGET_DIR/$filename"
                
                echo "Downloading: $img_url"
                echo "         to: $filename"
                
                # Try multiple download methods
                DOWNLOAD_SUCCESS=false
                
                # Method 1: With GitHub token (for private repos)
                if curl -L -f -s \
                        -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                        -H "User-Agent: GitHub-Actions" \
                        -H "Accept: application/vnd.github.v3+json" \
                        "$img_url" -o "$filepath" 2>/dev/null; then
                  DOWNLOAD_SUCCESS=true
                  echo "âœ… Downloaded with GitHub token"
                fi
                
                # Method 2: Without token (for public URLs)
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if curl -L -f -s \
                          -H "User-Agent: Mozilla/5.0 (GitHub Actions)" \
                          "$img_url" -o "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded without token"
                  fi
                fi
                
                # Method 3: Using wget as fallback
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if wget -q --timeout=30 --tries=2 \
                          --header="User-Agent: GitHub-Actions" \
                          "$img_url" -O "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded with wget"
                  fi
                fi
                
                # Verify download
                if [ "$DOWNLOAD_SUCCESS" = true ] && [ -f "$filepath" ] && [ -s "$filepath" ]; then
                  # Check if it's actually an image file
                  file_type=$(file "$filepath" 2>/dev/null || echo "unknown")
                  if echo "$file_type" | grep -qi "image\|png\|jpeg\|gif\|webp"; then
                    echo "âœ… Successfully downloaded and verified: $filename"
                    echo "   File type: $file_type"
                    echo "   File size: $(du -h "$filepath" | cut -f1)"
                    NEXT_NUM=$((NEXT_NUM + 1))
                  else
                    echo "âŒ Downloaded file is not an image: $filename"
                    echo "   File type detected: $file_type"
                    rm -f "$filepath"
                  fi
                else
                  echo "âŒ Failed to download: $img_url"
                  [ -f "$filepath" ] && rm -f "$filepath"
                fi
                
                echo "---"
              fi
            done < image_urls.txt
          else
            echo "No images found in issue body"
            echo "DEBUG: This could mean:"
            echo "  - No images were uploaded to the issue"
            echo "  - Images are in a format/location we're not detecting"
            echo "  - The issue template format is different than expected"
          fi
          
          # Summary
          FINAL_IMAGE_COUNT=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | wc -l)
          echo ""
          echo "SUMMARY:"
          echo "  Images found in issue: $IMAGE_COUNT"
          echo "  Images successfully downloaded: $FINAL_IMAGE_COUNT"
          echo "  Images saved in: $TARGET_DIR"
          
          if [ "$FINAL_IMAGE_COUNT" -gt 0 ]; then
            echo "  Downloaded files:"
            find "$TARGET_DIR" -name "target-*-comparison.*" | sort
          fi
          
      - name: Generate LinkedIn post
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          LINKEDIN_FILE="$TARGET_DIR/linkedin-post.md"
          
          # Extract additional notes based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            # For GitHub issue forms, look for the "Additional Notes" content
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "additional.*notes\|notes\|description" | grep -v -i "additional.*notes\|notes\|description" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          else
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "update.*notes\|notes" | grep -v -i "update.*notes\|notes" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          fi
          
          # Clean up additional notes - remove empty content
          ADDITIONAL_NOTES=$(echo "$ADDITIONAL_NOTES" | xargs)
          
          # If no additional notes found, create a default description
          if [ -z "$ADDITIONAL_NOTES" ]; then
            if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
              ADDITIONAL_NOTES="Another CSS challenge completed! ðŸŽ¯"
            else
              ADDITIONAL_NOTES="Updated my CSS solution with improvements! ðŸš€"
            fi
          fi
          
          # Generate the repository URL for the solutions.html file
          REPO_URL="https://github.com/${{ github.repository }}"
          SOLUTIONS_URL="$REPO_URL/blob/main/daily-targets/${{ steps.date.outputs.formatted_date }}/solutions.html"
          
          # Create LinkedIn post with the exact format requested
          cat > "$LINKEDIN_FILE" << EOF
# LinkedIn Post for ${{ steps.date.outputs.formatted_date }}

---

Today's CSSBattle solution:

$ADDITIONAL_NOTES

$SOLUTIONS_URL

(My journal notes.)

#cssgang #CSS #CSSBattle #HTML
EOF
          
          echo "LinkedIn post generated successfully"
          echo "DEBUG: LinkedIn post content:"
          cat "$LINKEDIN_FILE"
          
      - name: Commit and push changes
        run: |
          # Configure git
          git config --local user.email "${GIT_USER_EMAIL:-${{ github.actor }}@users.noreply.github.com}"
          git config --local user.name "${GIT_USER_NAME:-${{ github.actor }}}"
          
          # Check if there are changes to commit
          git add .
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "has_changes=false" >> $GITHUB_ENV
          else
            # Pull latest changes to avoid conflicts
            echo "Pulling latest changes..."
            git fetch origin
            git rebase origin/main || {
              echo "Rebase failed, trying merge strategy..." > image_urls_clean.txt || touch image_urls_clean.txt
            mv image_urls_clean.txt image_urls.txt
          else
            touch image_urls.txt
          fi
          
          echo "DEBUG: Found image URLs:"
          cat image_urls.txt
          
          # Count images found
          IMAGE_COUNT=$(wc -l < image_urls.txt)
          echo "DEBUG: Total unique image URLs found: $IMAGE_COUNT"
          
          # Download each image with enhanced error handling
          if [ -s image_urls.txt ] && [ "$IMAGE_COUNT" -gt 0 ]; then
            echo "Found $IMAGE_COUNT image(s) to download"
            
            while IFS= read -r img_url; do
              if [ -n "$img_url" ]; then
                echo "DEBUG: Processing URL: $img_url"
                
                # Extract file extension
                ext=$(echo "$img_url" | grep -oE '\.(png|jpg|jpeg|gif|webp)name: Create or Update Solutions File for Daily CSSBattle
on:
  issues:
    types: [opened]

permissions:
  contents: write
  issues: write
  
jobs:
  process-solutions-file:
    runs-on: ubuntu-latest
    if: contains(github.event.issue.title, '[CSSBattle]') || contains(github.event.issue.title, '[CSSBattle-UPDATE]')
    
    env:
      GIT_USER_EMAIL: ${{ secrets.GIT_USER_EMAIL }}
      GIT_USER_NAME: ${{ secrets.GIT_USER_NAME }}
    
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
      
      - name: Determine operation type
        id: operation
        run: |
          if [[ "${{ github.event.issue.title }}" == *"[CSSBattle-UPDATE]"* ]]; then
            echo "type=update" >> $GITHUB_OUTPUT
            echo "Operation: UPDATE"
          else
            echo "type=create" >> $GITHUB_OUTPUT
            echo "Operation: CREATE"
          fi
      
      - name: Extract and validate issue data
        id: extract
        run: |
          # Save issue body to file for processing
          cat > issue_body.txt << 'EOF'
          ${{ github.event.issue.body }}
          EOF
          
          echo "DEBUG: Issue body content:"
          cat issue_body.txt
          echo "DEBUG: ===== END OF ISSUE BODY ====="
          
          # Validate issue body is not empty
          if [ ! -s issue_body.txt ]; then
            echo "ERROR: Issue body is empty"
            exit 1
          fi
          
          # Extract date based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "DEBUG: Extracting date for CREATE operation"
            
            # GitHub issue forms create structured output, look for the date field
            # The issue body will contain the date value after field processing
            
            # Method 1: Look for date pattern directly (for "Jun 8, 2025" format)
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Method 2: If not found, look for numeric date formats
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{1,2}/[0-9]{1,2}/[0-9]{4}" issue_body.txt | head -1)
            fi
            
            # Method 3: Look for ISO format dates
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{4}-[0-9]{2}-[0-9]{2}" issue_body.txt | head -1)
            fi
            
            # Method 4: Search around common labels (fallback)
            if [ -z "$DATE" ]; then
              # Look for lines that might contain dates after field labels
              DATE=$(grep -A 5 -i "date\|when\|day" issue_body.txt | grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" | head -1)
            fi
            
          else
            echo "DEBUG: Extracting date for UPDATE operation"
            # For update operations, look for target date
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Extract update type and version number (implement as needed for UPDATE template)
            UPDATE_TYPE=$(grep -A 3 -i "update.*type" issue_body.txt | grep -v -i "update.*type" | head -1 | xargs)
            VERSION_NUMBER=$(grep -A 3 -i "version.*number" issue_body.txt | grep -v -i "version.*number" | head -1 | xargs)
            
            echo "update_type=$UPDATE_TYPE" >> $GITHUB_OUTPUT
            echo "version_number=$VERSION_NUMBER" >> $GITHUB_OUTPUT
          fi
          
          echo "parsed_date=$DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Extracted date: '$DATE'"
          
          # Validate date was extracted
          if [ -z "$DATE" ]; then
            echo "ERROR: Could not extract date from issue."
            echo "DEBUG: Issue body for troubleshooting:"
            echo "--- ISSUE BODY START ---"
            cat issue_body.txt
            echo "--- ISSUE BODY END ---"
            echo ""
            echo "Expected format examples:"
            echo "  - Jun 8, 2025"
            echo "  - January 15, 2025"
            echo "  - 6/8/2025"
            echo "  - 2025-06-08"
            exit 1
          fi
          
      - name: Convert and validate date format
        id: date
        run: |
          DATE="${{ steps.extract.outputs.parsed_date }}"
          echo "DEBUG: Converting date: '$DATE'"
          
          # Enhanced date parsing specifically for your formats
          if [ -n "$DATE" ]; then
            # Try GNU date first (handles "Jun 8, 2025" format perfectly)
            if FORMATTED_DATE=$(date -d "$DATE" +%Y-%m-%d 2>/dev/null); then
              echo "DEBUG: Successfully parsed with GNU date: $FORMATTED_DATE"
            else
              echo "DEBUG: GNU date failed, attempting manual parsing for format like 'Jun 8, 2025'"
              
              # Clean up the date string - remove extra spaces and commas
              DATE_CLEAN=$(echo "$DATE" | sed 's/,/ /g' | tr -s ' ' | xargs)
              echo "DEBUG: Cleaned date: '$DATE_CLEAN'"
              
              # Extract components for "Mon D, YYYY" or "Mon D YYYY" format
              if echo "$DATE_CLEAN" | grep -qE "^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2}[[:space:]]+[0-9]{4}$"; then
                
                # Extract month name
                MONTH_NAME=$(echo "$DATE_CLEAN" | cut -d' ' -f1)
                # Extract day
                DAY_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f2)
                # Extract year  
                YEAR_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f3)
                
                echo "DEBUG: Extracted - Month: '$MONTH_NAME', Day: '$DAY_NUM', Year: '$YEAR_NUM'"
                
                # Convert month abbreviation to number
                case "$MONTH_NAME" in
                  Jan|January) MONTH_NUM="01" ;;
                  Feb|February) MONTH_NUM="02" ;;
                  Mar|March) MONTH_NUM="03" ;;
                  Apr|April) MONTH_NUM="04" ;;
                  May) MONTH_NUM="05" ;;
                  Jun|June) MONTH_NUM="06" ;;
                  Jul|July) MONTH_NUM="07" ;;
                  Aug|August) MONTH_NUM="08" ;;
                  Sep|September) MONTH_NUM="09" ;;
                  Oct|October) MONTH_NUM="10" ;;
                  Nov|November) MONTH_NUM="11" ;;
                  Dec|December) MONTH_NUM="12" ;;
                  *) 
                    echo "ERROR: Could not parse month: '$MONTH_NAME'"
                    echo "Expected: Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec"
                    echo "Or full names: January, February, etc."
                    exit 1
                    ;;
                esac
                
                # Validate day (1-31)
                if ! [[ "$DAY_NUM" =~ ^[0-9]+$ ]] || [ "$DAY_NUM" -lt 1 ] || [ "$DAY_NUM" -gt 31 ]; then
                  echo "ERROR: Invalid day: '$DAY_NUM' (must be 1-31)"
                  exit 1
                fi
                
                # Validate year (reasonable range)
                if ! [[ "$YEAR_NUM" =~ ^[0-9]{4}$ ]] || [ "$YEAR_NUM" -lt 2020 ] || [ "$YEAR_NUM" -gt 2030 ]; then
                  echo "ERROR: Invalid year: '$YEAR_NUM' (must be 2020-2030)"
                  exit 1
                fi
                
                # Format as YYYY-MM-DD with zero padding
                FORMATTED_DATE=$(printf "%04d-%02d-%02d" "$YEAR_NUM" "$MONTH_NUM" "$DAY_NUM")
                echo "DEBUG: Manual parsing result: $FORMATTED_DATE"
                
              else
                echo "ERROR: Date format not recognized: '$DATE_CLEAN'"
                echo "Expected format: 'Jun 8, 2025' or 'June 8, 2025'"
                echo "Received: '$DATE'"
                exit 1
              fi
            fi
          else
            echo "ERROR: No date provided"
            exit 1
          fi
          
          # Final validation of formatted date
          if ! echo "$FORMATTED_DATE" | grep -qE "^[0-9]{4}-[0-9]{2}-[0-9]{2}$"; then
            echo "ERROR: Invalid formatted date: '$FORMATTED_DATE'"
            echo "Expected format: YYYY-MM-DD"
            exit 1
          fi
          
          # Additional sanity check - verify it's a valid date
          if ! date -d "$FORMATTED_DATE" >/dev/null 2>&1; then
            echo "ERROR: '$FORMATTED_DATE' is not a valid date"
            exit 1
          fi
          
          echo "formatted_date=$FORMATTED_DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Final formatted date: $FORMATTED_DATE"
          
      - name: Extract and validate CSS content
        id: css
        run: |
          echo "DEBUG: Extracting CSS content for ${{ steps.operation.outputs.type }} operation"
          
          # For GitHub issue forms, the CSS content is in the issue body
          # Look for CSS code blocks or direct CSS content
          
          # Method 1: Look for CSS content in code blocks (```css ... ```)
          if sed -n '/```css/,/```/p' issue_body.txt | sed '1d;$d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
            echo "DEBUG: Found CSS in code blocks"
          else
            # Method 2: Look for CSS content in HTML style blocks
            if grep -A 50 -B 5 "<style>" issue_body.txt | sed '/^--$/d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
              echo "DEBUG: Found CSS with <style> tags"
            else
              # Method 3: Look for any CSS-like content (fallback)
              if grep -A 20 -i "css\|style" issue_body.txt | grep -E "(background|width|height|margin|padding|color)" > css_content_raw.txt && [ -s css_content_raw.txt ]; then
                echo "DEBUG: Found CSS-like content"
              else
                echo "ERROR: No CSS content found in issue"
                echo "DEBUG: Issue body for troubleshooting:"
                echo "--- ISSUE BODY START ---"
                cat issue_body.txt
                echo "--- ISSUE BODY END ---"
                echo ""
                echo "Expected: CSS code in \`\`\`css blocks or <style> tags"
                exit 1
              fi
            fi
          fi
          
          # Clean up the CSS content
          # Remove empty lines and clean up formatting
          sed '/^[[:space:]]*$/d' css_content_raw.txt > css_content.txt
          
          # Validate CSS content exists after cleaning
          if [ ! -s css_content.txt ]; then
            echo "ERROR: CSS content is empty after processing"
            echo "DEBUG: Raw CSS content was:"
            cat css_content_raw.txt
            exit 1
          fi
          
          echo "DEBUG: CSS content extracted successfully:"
          echo "--- CSS CONTENT START ---"
          head -10 css_content.txt
          if [ $(wc -l < css_content.txt) -gt 10 ]; then
            echo "... (truncated, total lines: $(wc -l < css_content.txt))"
          fi
          echo "--- CSS CONTENT END ---"
          
          # Count versions by counting ---VERSION--- separators
          VERSION_COUNT=$(grep -c "---VERSION---" css_content.txt 2>/dev/null || echo 0)
          VERSION_COUNT=$((VERSION_COUNT + 1))
          echo "version_count=$VERSION_COUNT" >> $GITHUB_OUTPUT
          echo "DEBUG: Found $VERSION_COUNT CSS versions"
          
      - name: Create directory structure
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          echo "DEBUG: Creating directory: $TARGET_DIR"
          
          mkdir -p "$TARGET_DIR"
          
          # Verify directory creation
          if [ ! -d "$TARGET_DIR" ]; then
            echo "ERROR: Failed to create directory: $TARGET_DIR"
            exit 1
          fi
          
          echo "DEBUG: Directory created successfully"
          ls -la daily-targets/
          
      - name: Create or update solutions file
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          SOLUTIONS_FILE="$TARGET_DIR/solutions.html"
          
          echo "DEBUG: Processing solutions file: $SOLUTIONS_FILE"
          
          # Clean CSS content - remove ```css and ``` markers, keep only the actual CSS
          sed -e '/^```css$/d' -e '/^```$/d' css_content.txt > css_cleaned.txt
          
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "Creating new solutions file..."
            
            # Start with Version 1 comment
            echo "<!-- Version 1 -->" > "$SOLUTIONS_FILE"
            
            # Process CSS content with version separation
            version_num=1
            while IFS= read -r line || [ -n "$line" ]; do
              if [[ "$line" == "---VERSION---" ]]; then
                # Close current version and start new one
                echo "</style>" >> "$SOLUTIONS_FILE"
                echo "" >> "$SOLUTIONS_FILE"
                version_num=$((version_num + 1))
                echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
              else
                echo "$line" >> "$SOLUTIONS_FILE"
              fi
            done < css_cleaned.txt
            
            # Ensure file ends with </style>
            if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
              echo "</style>" >> "$SOLUTIONS_FILE"
            fi
            
          else
            echo "Updating existing solutions file..."
            
            if [ ! -f "$SOLUTIONS_FILE" ]; then
              echo "ERROR: Solutions file not found: $SOLUTIONS_FILE"
              echo "Available dates:"
              ls daily-targets/ 2>/dev/null || echo "No existing solutions found"
              exit 1
            fi
            
            case "${{ steps.extract.outputs.update_type }}" in
              "Add new CSS version(s)")
                echo "Adding new CSS versions..."
                # Find last version number
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                # Ensure file ends with </style>
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              "Replace existing CSS version(s)")
                if [ -n "${{ steps.extract.outputs.version_number }}" ]; then
                  echo "Note: Version replacement is complex and not fully implemented"
                  echo "Adding as new version instead..."
                  LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                  NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                  
                  echo "" >> "$SOLUTIONS_FILE"
                  echo "<!-- Version $NEXT_VERSION (replacement for Version ${{ steps.extract.outputs.version_number }}) -->" >> "$SOLUTIONS_FILE"
                  
                  # Add cleaned CSS content
                  cat css_cleaned.txt >> "$SOLUTIONS_FILE"
                  
                  if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                    echo "</style>" >> "$SOLUTIONS_FILE"
                  fi
                else
                  echo "ERROR: Version number required for replacement"
                  exit 1
                fi
                ;;
                
              "Add new comparison image(s)")
                echo "Images will be processed in next step..."
                ;;
                
              "Add both CSS and images")
                echo "Adding new CSS versions and images..."
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              *)
                echo "ERROR: Unknown update type: ${{ steps.extract.outputs.update_type }}"
                exit 1
                ;;
            esac
          fi
          
          echo "Solutions file processing complete"
          echo "DEBUG: Final solutions file content:"
          cat "$SOLUTIONS_FILE"
          
      - name: Download and process images
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          ISSUE_NUM="${{ github.event.issue.number }}"
          
          echo "DEBUG: Processing images for issue #$ISSUE_NUM"
          echo "DEBUG: Target directory: $TARGET_DIR"
          
          # Determine next available image number
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            NEXT_NUM=1
          else
            # Find existing images and get next number
            EXISTING_IMAGES=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | sort)
            if [ -n "$EXISTING_IMAGES" ]; then
              LAST_NUM=$(echo "$EXISTING_IMAGES" | sed 's/.*target-\([0-9]\+\)-comparison\..*/\1/' | sort -n | tail -1)
              NEXT_NUM=$((LAST_NUM + 1))
              echo "DEBUG: Found existing images, starting from number: $NEXT_NUM"
            else
              NEXT_NUM=1
              echo "DEBUG: No existing images found, starting from: $NEXT_NUM"
            fi
          fi
          
          # Get the full issue data including uploaded assets
          echo "DEBUG: Fetching issue data..."
          gh issue view "$ISSUE_NUM" --repo "${{ github.repository }}" --json body,url > issue_data.json
          
          # Debug: Show what we got
          echo "DEBUG: Issue data received:"
          cat issue_data.json
          
          # Extract the issue body
          ISSUE_BODY=$(jq -r '.body' issue_data.json)
          echo "DEBUG: Issue body extracted, length: ${#ISSUE_BODY}"
          
          # Save issue body for debugging
          echo "$ISSUE_BODY" > issue_body_full.txt
          echo "DEBUG: Full issue body saved to file"
          
          # Look for multiple image URL patterns that GitHub uses
          echo "DEBUG: Searching for image URLs..."
          
          # Clear any existing image URLs file
          > image_urls.txt
          
          # Pattern 1: GitHub user content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 2: GitHub assets URLs  
          echo "$ISSUE_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/assets/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 3: Generic GitHub content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://[^.]*\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 4: Any https image URLs (broader catch)
          echo "$ISSUE_BODY" | grep -oE 'https://[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Remove duplicates and empty lines
          if [ -f image_urls.txt ]; then
            sort image_urls.txt | uniq | grep -v '^$' > image_urls_clean.txt || touch image_urls_clean.txt
            mv image_urls_clean.txt image_urls.txt
          else
            touch image_urls.txt
          fi
          
          echo "DEBUG: Found image URLs:"
          cat image_urls.txt
          
          # Count images found
          IMAGE_COUNT=$(wc -l < image_urls.txt)
          echo "DEBUG: Total unique image URLs found: $IMAGE_COUNT"
          
          # Download each image with enhanced error handling
          if [ -s image_urls.txt ] && [ "$IMAGE_COUNT" -gt 0 ]; then
            echo "Found $IMAGE_COUNT image(s) to download"
            
            while IFS= read -r img_url; do
              if [ -n "$img_url" ]; then
                echo "DEBUG: Processing URL: $img_url"
                
                # Extract file extension
                ext=$(echo "$img_url" | grep -oE '\.(png|jpg|jpeg|gif|webp)$' | head -1)
                if [ -z "$ext" ]; then
                  ext=".png"  # Default extension
                  echo "DEBUG: No extension found, defaulting to .png"
                fi
                
                filename="target-${NEXT_NUM}-comparison${ext}"
                filepath="$TARGET_DIR/$filename"
                
                echo "Downloading: $img_url"
                echo "         to: $filename"
                
                # Try multiple download methods
                DOWNLOAD_SUCCESS=false
                
                # Method 1: With GitHub token (for private repos)
                if curl -L -f -s \
                        -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                        -H "User-Agent: GitHub-Actions" \
                        -H "Accept: application/vnd.github.v3+json" \
                        "$img_url" -o "$filepath" 2>/dev/null; then
                  DOWNLOAD_SUCCESS=true
                  echo "âœ… Downloaded with GitHub token"
                fi
                
                # Method 2: Without token (for public URLs)
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if curl -L -f -s \
                          -H "User-Agent: Mozilla/5.0 (GitHub Actions)" \
                          "$img_url" -o "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded without token"
                  fi
                fi
                
                # Method 3: Using wget as fallback
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if wget -q --timeout=30 --tries=2 \
                          --header="User-Agent: GitHub-Actions" \
                          "$img_url" -O "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded with wget"
                  fi
                fi
                
                # Verify download
                if [ "$DOWNLOAD_SUCCESS" = true ] && [ -f "$filepath" ] && [ -s "$filepath" ]; then
                  # Check if it's actually an image file
                  file_type=$(file "$filepath" 2>/dev/null || echo "unknown")
                  if echo "$file_type" | grep -qi "image\|png\|jpeg\|gif\|webp"; then
                    echo "âœ… Successfully downloaded and verified: $filename"
                    echo "   File type: $file_type"
                    echo "   File size: $(du -h "$filepath" | cut -f1)"
                    NEXT_NUM=$((NEXT_NUM + 1))
                  else
                    echo "âŒ Downloaded file is not an image: $filename"
                    echo "   File type detected: $file_type"
                    rm -f "$filepath"
                  fi
                else
                  echo "âŒ Failed to download: $img_url"
                  [ -f "$filepath" ] && rm -f "$filepath"
                fi
                
                echo "---"
              fi
            done < image_urls.txt
          else
            echo "No images found in issue body"
            echo "DEBUG: This could mean:"
            echo "  - No images were uploaded to the issue"
            echo "  - Images are in a format/location we're not detecting"
            echo "  - The issue template format is different than expected"
          fi
          
          # Summary
          FINAL_IMAGE_COUNT=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | wc -l)
          echo ""
          echo "SUMMARY:"
          echo "  Images found in issue: $IMAGE_COUNT"
          echo "  Images successfully downloaded: $FINAL_IMAGE_COUNT"
          echo "  Images saved in: $TARGET_DIR"
          
          if [ "$FINAL_IMAGE_COUNT" -gt 0 ]; then
            echo "  Downloaded files:"
            find "$TARGET_DIR" -name "target-*-comparison.*" | sort
          fi
          
      - name: Generate LinkedIn post
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          LINKEDIN_FILE="$TARGET_DIR/linkedin-post.md"
          
          # Extract additional notes based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            # For GitHub issue forms, look for the "Additional Notes" content
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "additional.*notes\|notes\|description" | grep -v -i "additional.*notes\|notes\|description" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          else
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "update.*notes\|notes" | grep -v -i "update.*notes\|notes" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          fi
          
          # Clean up additional notes - remove empty content
          ADDITIONAL_NOTES=$(echo "$ADDITIONAL_NOTES" | xargs)
          
          # If no additional notes found, create a default description
          if [ -z "$ADDITIONAL_NOTES" ]; then
            if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
              ADDITIONAL_NOTES="Another CSS challenge completed! ðŸŽ¯"
            else
              ADDITIONAL_NOTES="Updated my CSS solution with improvements! ðŸš€"
            fi
          fi
          
          # Generate the repository URL for the solutions.html file
          REPO_URL="https://github.com/${{ github.repository }}"
          SOLUTIONS_URL="$REPO_URL/blob/main/daily-targets/${{ steps.date.outputs.formatted_date }}/solutions.html"
          
          # Create LinkedIn post with the exact format requested
          cat > "$LINKEDIN_FILE" << EOF
# LinkedIn Post for ${{ steps.date.outputs.formatted_date }}

---

Today's CSSBattle solution:

$ADDITIONAL_NOTES

$SOLUTIONS_URL

(My journal notes.)

#cssgang #CSS #CSSBattle #HTML
EOF
          
          echo "LinkedIn post generated successfully"
          echo "DEBUG: LinkedIn post content:"
          cat "$LINKEDIN_FILE"
          
      - name: Commit and push changes
        run: |
          # Configure git
          git config --local user.email "${GIT_USER_EMAIL:-${{ github.actor }}@users.noreply.github.com}"
          git config --local user.name "${GIT_USER_NAME:-${{ github.actor }}}"
          
          # Check if there are changes to commit
          git add .
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "has_changes=false" >> $GITHUB_ENV
          else
            # Pull latest changes to avoid conflicts
            echo "Pulling latest changes..."
            git fetch origin
            git rebase origin/main || {
              echo "Rebase failed, trying merge strategy..." | head -1)
                if [ -z "$ext" ]; then
                  ext=".png"  # Default extension
                  echo "DEBUG: No extension found, defaulting to .png"
                fi
                
                filename="target-${NEXT_NUM}-comparison${ext}"
                filepath="$TARGET_DIR/$filename"
                
                echo "Downloading: $img_url"
                echo "         to: $filename"
                
                # Try multiple download methods
                DOWNLOAD_SUCCESS=false
                
                # Method 1: With GitHub token (for private repos)
                if curl -L -f -s \
                        -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                        -H "User-Agent: GitHub-Actions" \
                        -H "Accept: application/vnd.github.v3+json" \
                        "$img_url" -o "$filepath" 2>/dev/null; then
                  DOWNLOAD_SUCCESS=true
                  echo "âœ… Downloaded with GitHub token"
                fi
                
                # Method 2: Without token (for public URLs)
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if curl -L -f -s \
                          -H "User-Agent: Mozilla/5.0 (GitHub Actions)" \
                          "$img_url" -o "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded without token"
                  fi
                fi
                
                # Method 3: Using wget as fallback
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if wget -q --timeout=30 --tries=2 \
                          --header="User-Agent: GitHub-Actions" \
                          "$img_url" -O "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded with wget"
                  fi
                fi
                
                # Verify download
                if [ "$DOWNLOAD_SUCCESS" = true ] && [ -f "$filepath" ] && [ -s "$filepath" ]; then
                  # Check if it's actually an image file
                  file_type=$(file "$filepath" 2>/dev/null || echo "unknown")
                  if echo "$file_type" | grep -qi "image\|png\|jpeg\|gif\|webp"; then
                    echo "âœ… Successfully downloaded and verified: $filename"
                    echo "   File type: $file_type"
                    echo "   File size: $(du -h "$filepath" | cut -f1)"
                    NEXT_NUM=$((NEXT_NUM + 1))
                  else
                    echo "âŒ Downloaded file is not an image: $filename"
                    echo "   File type detected: $file_type"
                    rm -f "$filepath"
                  fi
                else
                  echo "âŒ Failed to download: $img_url"
                  [ -f "$filepath" ] && rm -f "$filepath"
                fi
                
                echo "---"
              fi
            done < image_urls.txt
          else
            echo "No images found in issue body"
            echo "DEBUG: This could mean:"
            echo "  - No images were uploaded to the issue"
            echo "  - Images are in a format/location we're not detecting"
            echo "  - The issue template format is different than expected"
          fi
          
          # Summary
          FINAL_IMAGE_COUNT=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | wc -l)
          echo ""
          echo "SUMMARY:"
          echo "  Images found in issue: $IMAGE_COUNT"
          echo "  Images successfully downloaded: $FINAL_IMAGE_COUNT"
          echo "  Images saved in: $TARGET_DIR"
          
          if [ "$FINAL_IMAGE_COUNT" -gt 0 ]; then
            echo "  Downloaded files:"
            find "$TARGET_DIR" -name "target-*-comparison.*" | sort
          fi
          
      - name: Generate LinkedIn post
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          LINKEDIN_FILE="$TARGET_DIR/linkedin-post.md"
          
          # Extract additional notes based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            # For GitHub issue forms, look for the "Additional Notes" content
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "additional.*notes\|notes\|description" | grep -v -i "additional.*notes\|notes\|description" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          else
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "update.*notes\|notes" | grep -v -i "update.*notes\|notes" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          fi
          
          # Clean up additional notes - remove empty content
          ADDITIONAL_NOTES=$(echo "$ADDITIONAL_NOTES" | xargs)
          
          # If no additional notes found, create a default description
          if [ -z "$ADDITIONAL_NOTES" ]; then
            if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
              ADDITIONAL_NOTES="Another CSS challenge completed! ðŸŽ¯"
            else
              ADDITIONAL_NOTES="Updated my CSS solution with improvements! ðŸš€"
            fi
          fi
          
          # Generate the repository URL for the solutions.html file
          REPO_URL="https://github.com/${{ github.repository }}"
          SOLUTIONS_URL="$REPO_URL/blob/main/daily-targets/${{ steps.date.outputs.formatted_date }}/solutions.html"
          
          # Create LinkedIn post with the exact format requested
          cat > "$LINKEDIN_FILE" << EOF
# LinkedIn Post for ${{ steps.date.outputs.formatted_date }}

---

Today's CSSBattle solution:

$ADDITIONAL_NOTES

$SOLUTIONS_URL

(My journal notes.)

#cssgang #CSS #CSSBattle #HTML
EOF
          
          echo "LinkedIn post generated successfully"
          echo "DEBUG: LinkedIn post content:"
          cat "$LINKEDIN_FILE"
          
      - name: Commit and push changes
        run: |
          # Configure git
          git config --local user.email "${GIT_USER_EMAIL:-${{ github.actor }}@users.noreply.github.com}"
          git config --local user.name "${GIT_USER_NAME:-${{ github.actor }}}"
          
          # Check if there are changes to commit
          git add .
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "has_changes=false" >> $GITHUB_ENV
          else
            # Pull latest changes to avoid conflicts
            echo "Pulling latest changes..."
            git fetch origin
            git rebase origin/main || {
              echo "Rebase failed, trying merge strategy..."
              git rebase --abort
              git merge origin/main
            }
            
            # Commit changes
            if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
              COMMIT_MSG="feat: CSS Battle solution for ${{ steps.date.outputs.formatted_date }}"
            else
              COMMIT_MSG="update: CSS Battle solution for ${{ steps.date.outputs.formatted_date }}"
            fi
            
            git commit -m "$COMMIT_MSG"
            
            # Push with retry logic
            echo "Pushing changes..."
            for i in {1..3}; do
              if git push origin main; then
                echo "âœ… Changes pushed successfully"
                echo "has_changes=true" >> $GITHUB_ENV
                break
              else
                echo "âŒ Push attempt $i failed"
                if [ $i -lt 3 ]; then
                  echo "Retrying after pull..."
                  git pull origin main --rebase
                else
                  echo "All push attempts failed"
                  exit 1
                fi
              fi
            done
          fi
          
      - name: Create success comment and close issue
        if: env.has_changes != 'false'
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          
          # Count final results
          VERSION_COUNT_IN_FILE=$(grep -c "<!-- Version" "$TARGET_DIR/solutions.html" 2>/dev/null || echo 1)
          IMAGE_COUNT=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | wc -l)
          
          # Get processing summary from the image download step
          IMAGES_FOUND=$(cat image_urls.txt 2>/dev/null | wc -l || echo 0)
          
          # Calculate character counts for each CSS version (from original cleaned CSS)
          echo "DEBUG: Calculating character counts..."
          
          # Split the cleaned CSS content by ---VERSION--- markers
          cp css_cleaned.txt css_for_counting.txt
          
          # Create individual version files for counting
          version_num=1
          current_file="version_${version_num}.css"
          > "$current_file"  # Create empty first version file
          
          while IFS= read -r line || [ -n "$line" ]; do
            if [[ "$line" == "---VERSION---" ]]; then
              # Start new version file
              version_num=$((version_num + 1))
              current_file="version_${version_num}.css"
              > "$current_file"  # Create empty new version file
            else
              # Add line to current version file
              echo "$line" >> "$current_file"
            fi
          done < css_for_counting.txt
          
          # Count characters for each version (excluding any </style> tags)
          CHAR_COUNTS=""
          for i in $(seq 1 $VERSION_COUNT_IN_FILE); do
            version_file="version_${i}.css"
            if [ -f "$version_file" ]; then
              # Remove any </style> tags and count characters
              char_count=$(sed 's|</style>||g' "$version_file" | tr -d '\n' | wc -c)
              if [ $i -eq 1 ]; then
                CHAR_COUNTS="Version $i: $char_count chars"
              else
                CHAR_COUNTS="$CHAR_COUNTS - Version $i: $char_count chars"
              fi
              echo "DEBUG: Version $i character count: $char_count"
            fi
          done
          
          # Create comprehensive success comment with detailed summary
          # Using separate echo statements to avoid heredoc quoting issues
          cat > comment.txt << 'COMMENT_EOF'
# âœ… CSS Battle Solution Processed Successfully!

## ðŸ“ Location
COMMENT_EOF
          
          echo "\`$TARGET_DIR/\`" >> comment.txt
          echo "" >> comment.txt
          echo "## ðŸ“Š Processing Summary" >> comment.txt
          echo "- ðŸŽ¯ **CSS Versions Created:** $VERSION_COUNT_IN_FILE" >> comment.txt
          echo "- ðŸ–¼ï¸ **Images Found in Issue:** $IMAGES_FOUND" >> comment.txt
          echo "- ðŸ“¥ **Images Successfully Downloaded:** $IMAGE_COUNT" >> comment.txt
          echo "- ðŸ“… **Target Date:** ${{ steps.date.outputs.formatted_date }}" >> comment.txt
          echo "- ðŸ”„ **Operation Type:** ${{ steps.operation.outputs.type }}" >> comment.txt
          echo "" >> comment.txt
          echo "## âš¡ Char Count" >> comment.txt
          echo "$CHAR_COUNTS" >> comment.txt
          echo "" >> comment.txt
          echo "## ðŸ“„ Files Created/Updated" >> comment.txt
          echo "" >> comment.txt
          echo "### Solutions" >> comment.txt
          echo "- âœ… \`solutions.html\` - Your CSS solution ($VERSION_COUNT_IN_FILE version(s))" >> comment.txt
          echo "" >> comment.txt
          echo "### Content" >> comment.txt
          echo "- âœ… \`linkedin-post.md\` - Ready-to-post LinkedIn content" >> comment.txt
          echo "" >> comment.txt
          echo "### Images" >> comment.txt
          
          if [ "$IMAGE_COUNT" -gt 0 ]; then
            echo "ðŸ“¸ **Downloaded Images:**" >> comment.txt
            find "$TARGET_DIR" -name "target-*-comparison.*" | sort | while read -r img; do
              # Get file size for each image
              size=$(du -h "$img" 2>/dev/null | cut -f1 || echo "?")
              echo "- âœ… \`$(basename "$img")\` (${size})" >> comment.txt
            done
          else
            echo "- â„¹ï¸ No images were uploaded or found" >> comment.txt
            if [ "$IMAGES_FOUND" -gt 0 ]; then
              echo "- âš ï¸ Found $IMAGES_FOUND image URL(s) but download failed" >> comment.txt
            fi
          fi
          
          echo "" >> comment.txt
          echo "## ðŸ”— Quick Links" >> comment.txt
          echo "- ðŸ“± **LinkedIn Post:** [\`linkedin-post.md\`](${{ github.server_url }}/${{ github.repository }}/blob/main/$TARGET_DIR/linkedin-post.md)" >> comment.txt
          echo "- ðŸ’» **CSS Solution:** [\`solutions.html\`](${{ github.server_url }}/${{ github.repository }}/blob/main/$TARGET_DIR/solutions.html)" >> comment.txt
          echo "- ðŸ“ **Full Directory:** [\`$TARGET_DIR/\`](${{ github.server_url }}/${{ github.repository }}/tree/main/$TARGET_DIR)" >> comment.txt
          echo "" >> comment.txt
          echo "## ðŸŽ‰ Ready for Battle!" >> comment.txt
          echo "Your solution is now organized and ready for sharing. Click the LinkedIn post link above to copy the content!" >> comment.txt
          echo "" >> comment.txt
          echo "---" >> comment.txt
          echo "*âœ¨ Processed by GitHub Actions on $(date)*" >> comment.txt
          echo "*ðŸ”§ Workflow: [\`${{ github.workflow }}\`](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*" >> comment.txt
          
          # Post comment and close issue
          gh issue comment "${{ github.event.issue.number }}" \
            --repo "${{ github.repository }}" \
            --body-file comment.txt
          
          gh issue close "${{ github.event.issue.number }}" \
            --repo "${{ github.repository }}" \
            --reason completed

      - name: Cleanup temporary files
        if: always()
        run: |
          echo "ðŸ§¹ Cleaning up temporary files..."
          
          # List of temporary files that may be created during the workflow
          TEMP_FILES=(
            "issue_body.txt"
            "css_content.txt"
            "css_content_raw.txt"
            "css_cleaned.txt"
            "css_for_counting.txt"
            "image_urls.txt"
            "image_urls_clean.txt"
            "formatted_date_backup.txt"
            "date_output.txt"
            "issue_data.json"
            "issue_body_full.txt"
            "comment.txt"
            "temp_solutions.html"
          )
          
          # Remove each temporary file if it exists
          for file in "${TEMP_FILES[@]}"; do
            if [ -f "$file" ]; then
              echo "Removing: $file"
              rm -f "$file"
            fi
          done
          
          # Remove version-specific character counting files
          rm -f version_*.css 2>/dev/null || true
          
          # Double-check for any other temporary files with common patterns
          find . -maxdepth 1 -name "*.tmp" -type f -delete 2>/dev/null || true
          find . -maxdepth 1 -name "temp_*" -type f -delete 2>/dev/null || true
          
          echo "âœ… Cleanup completed - repository is clean"
          
          # Verify cleanup (optional debug)
          echo "DEBUG: Remaining files in root directory:"
          ls -laname: Create or Update Solutions File for Daily CSSBattle
on:
  issues:
    types: [opened]

permissions:
  contents: write
  issues: write
  
jobs:
  process-solutions-file:
    runs-on: ubuntu-latest
    if: contains(github.event.issue.title, '[CSSBattle]') || contains(github.event.issue.title, '[CSSBattle-UPDATE]')
    
    env:
      GIT_USER_EMAIL: ${{ secrets.GIT_USER_EMAIL }}
      GIT_USER_NAME: ${{ secrets.GIT_USER_NAME }}
    
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
      
      - name: Determine operation type
        id: operation
        run: |
          if [[ "${{ github.event.issue.title }}" == *"[CSSBattle-UPDATE]"* ]]; then
            echo "type=update" >> $GITHUB_OUTPUT
            echo "Operation: UPDATE"
          else
            echo "type=create" >> $GITHUB_OUTPUT
            echo "Operation: CREATE"
          fi
      
      - name: Extract and validate issue data
        id: extract
        run: |
          # Save issue body to file for processing
          cat > issue_body.txt << 'EOF'
          ${{ github.event.issue.body }}
          EOF
          
          echo "DEBUG: Issue body content:"
          cat issue_body.txt
          echo "DEBUG: ===== END OF ISSUE BODY ====="
          
          # Validate issue body is not empty
          if [ ! -s issue_body.txt ]; then
            echo "ERROR: Issue body is empty"
            exit 1
          fi
          
          # Extract date based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "DEBUG: Extracting date for CREATE operation"
            
            # GitHub issue forms create structured output, look for the date field
            # The issue body will contain the date value after field processing
            
            # Method 1: Look for date pattern directly (for "Jun 8, 2025" format)
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Method 2: If not found, look for numeric date formats
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{1,2}/[0-9]{1,2}/[0-9]{4}" issue_body.txt | head -1)
            fi
            
            # Method 3: Look for ISO format dates
            if [ -z "$DATE" ]; then
              DATE=$(grep -oE "[0-9]{4}-[0-9]{2}-[0-9]{2}" issue_body.txt | head -1)
            fi
            
            # Method 4: Search around common labels (fallback)
            if [ -z "$DATE" ]; then
              # Look for lines that might contain dates after field labels
              DATE=$(grep -A 5 -i "date\|when\|day" issue_body.txt | grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" | head -1)
            fi
            
          else
            echo "DEBUG: Extracting date for UPDATE operation"
            # For update operations, look for target date
            DATE=$(grep -oE "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2},[[:space:]]*[0-9]{4}" issue_body.txt | head -1)
            
            # Extract update type and version number (implement as needed for UPDATE template)
            UPDATE_TYPE=$(grep -A 3 -i "update.*type" issue_body.txt | grep -v -i "update.*type" | head -1 | xargs)
            VERSION_NUMBER=$(grep -A 3 -i "version.*number" issue_body.txt | grep -v -i "version.*number" | head -1 | xargs)
            
            echo "update_type=$UPDATE_TYPE" >> $GITHUB_OUTPUT
            echo "version_number=$VERSION_NUMBER" >> $GITHUB_OUTPUT
          fi
          
          echo "parsed_date=$DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Extracted date: '$DATE'"
          
          # Validate date was extracted
          if [ -z "$DATE" ]; then
            echo "ERROR: Could not extract date from issue."
            echo "DEBUG: Issue body for troubleshooting:"
            echo "--- ISSUE BODY START ---"
            cat issue_body.txt
            echo "--- ISSUE BODY END ---"
            echo ""
            echo "Expected format examples:"
            echo "  - Jun 8, 2025"
            echo "  - January 15, 2025"
            echo "  - 6/8/2025"
            echo "  - 2025-06-08"
            exit 1
          fi
          
      - name: Convert and validate date format
        id: date
        run: |
          DATE="${{ steps.extract.outputs.parsed_date }}"
          echo "DEBUG: Converting date: '$DATE'"
          
          # Enhanced date parsing specifically for your formats
          if [ -n "$DATE" ]; then
            # Try GNU date first (handles "Jun 8, 2025" format perfectly)
            if FORMATTED_DATE=$(date -d "$DATE" +%Y-%m-%d 2>/dev/null); then
              echo "DEBUG: Successfully parsed with GNU date: $FORMATTED_DATE"
            else
              echo "DEBUG: GNU date failed, attempting manual parsing for format like 'Jun 8, 2025'"
              
              # Clean up the date string - remove extra spaces and commas
              DATE_CLEAN=$(echo "$DATE" | sed 's/,/ /g' | tr -s ' ' | xargs)
              echo "DEBUG: Cleaned date: '$DATE_CLEAN'"
              
              # Extract components for "Mon D, YYYY" or "Mon D YYYY" format
              if echo "$DATE_CLEAN" | grep -qE "^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[[:space:]]+[0-9]{1,2}[[:space:]]+[0-9]{4}$"; then
                
                # Extract month name
                MONTH_NAME=$(echo "$DATE_CLEAN" | cut -d' ' -f1)
                # Extract day
                DAY_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f2)
                # Extract year  
                YEAR_NUM=$(echo "$DATE_CLEAN" | cut -d' ' -f3)
                
                echo "DEBUG: Extracted - Month: '$MONTH_NAME', Day: '$DAY_NUM', Year: '$YEAR_NUM'"
                
                # Convert month abbreviation to number
                case "$MONTH_NAME" in
                  Jan|January) MONTH_NUM="01" ;;
                  Feb|February) MONTH_NUM="02" ;;
                  Mar|March) MONTH_NUM="03" ;;
                  Apr|April) MONTH_NUM="04" ;;
                  May) MONTH_NUM="05" ;;
                  Jun|June) MONTH_NUM="06" ;;
                  Jul|July) MONTH_NUM="07" ;;
                  Aug|August) MONTH_NUM="08" ;;
                  Sep|September) MONTH_NUM="09" ;;
                  Oct|October) MONTH_NUM="10" ;;
                  Nov|November) MONTH_NUM="11" ;;
                  Dec|December) MONTH_NUM="12" ;;
                  *) 
                    echo "ERROR: Could not parse month: '$MONTH_NAME'"
                    echo "Expected: Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec"
                    echo "Or full names: January, February, etc."
                    exit 1
                    ;;
                esac
                
                # Validate day (1-31)
                if ! [[ "$DAY_NUM" =~ ^[0-9]+$ ]] || [ "$DAY_NUM" -lt 1 ] || [ "$DAY_NUM" -gt 31 ]; then
                  echo "ERROR: Invalid day: '$DAY_NUM' (must be 1-31)"
                  exit 1
                fi
                
                # Validate year (reasonable range)
                if ! [[ "$YEAR_NUM" =~ ^[0-9]{4}$ ]] || [ "$YEAR_NUM" -lt 2020 ] || [ "$YEAR_NUM" -gt 2030 ]; then
                  echo "ERROR: Invalid year: '$YEAR_NUM' (must be 2020-2030)"
                  exit 1
                fi
                
                # Format as YYYY-MM-DD with zero padding
                FORMATTED_DATE=$(printf "%04d-%02d-%02d" "$YEAR_NUM" "$MONTH_NUM" "$DAY_NUM")
                echo "DEBUG: Manual parsing result: $FORMATTED_DATE"
                
              else
                echo "ERROR: Date format not recognized: '$DATE_CLEAN'"
                echo "Expected format: 'Jun 8, 2025' or 'June 8, 2025'"
                echo "Received: '$DATE'"
                exit 1
              fi
            fi
          else
            echo "ERROR: No date provided"
            exit 1
          fi
          
          # Final validation of formatted date
          if ! echo "$FORMATTED_DATE" | grep -qE "^[0-9]{4}-[0-9]{2}-[0-9]{2}$"; then
            echo "ERROR: Invalid formatted date: '$FORMATTED_DATE'"
            echo "Expected format: YYYY-MM-DD"
            exit 1
          fi
          
          # Additional sanity check - verify it's a valid date
          if ! date -d "$FORMATTED_DATE" >/dev/null 2>&1; then
            echo "ERROR: '$FORMATTED_DATE' is not a valid date"
            exit 1
          fi
          
          echo "formatted_date=$FORMATTED_DATE" >> $GITHUB_OUTPUT
          echo "DEBUG: Final formatted date: $FORMATTED_DATE"
          
      - name: Extract and validate CSS content
        id: css
        run: |
          echo "DEBUG: Extracting CSS content for ${{ steps.operation.outputs.type }} operation"
          
          # For GitHub issue forms, the CSS content is in the issue body
          # Look for CSS code blocks or direct CSS content
          
          # Method 1: Look for CSS content in code blocks (```css ... ```)
          if sed -n '/```css/,/```/p' issue_body.txt | sed '1d;$d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
            echo "DEBUG: Found CSS in code blocks"
          else
            # Method 2: Look for CSS content in HTML style blocks
            if grep -A 50 -B 5 "<style>" issue_body.txt | sed '/^--$/d' > css_content_raw.txt && [ -s css_content_raw.txt ]; then
              echo "DEBUG: Found CSS with <style> tags"
            else
              # Method 3: Look for any CSS-like content (fallback)
              if grep -A 20 -i "css\|style" issue_body.txt | grep -E "(background|width|height|margin|padding|color)" > css_content_raw.txt && [ -s css_content_raw.txt ]; then
                echo "DEBUG: Found CSS-like content"
              else
                echo "ERROR: No CSS content found in issue"
                echo "DEBUG: Issue body for troubleshooting:"
                echo "--- ISSUE BODY START ---"
                cat issue_body.txt
                echo "--- ISSUE BODY END ---"
                echo ""
                echo "Expected: CSS code in \`\`\`css blocks or <style> tags"
                exit 1
              fi
            fi
          fi
          
          # Clean up the CSS content
          # Remove empty lines and clean up formatting
          sed '/^[[:space:]]*$/d' css_content_raw.txt > css_content.txt
          
          # Validate CSS content exists after cleaning
          if [ ! -s css_content.txt ]; then
            echo "ERROR: CSS content is empty after processing"
            echo "DEBUG: Raw CSS content was:"
            cat css_content_raw.txt
            exit 1
          fi
          
          echo "DEBUG: CSS content extracted successfully:"
          echo "--- CSS CONTENT START ---"
          head -10 css_content.txt
          if [ $(wc -l < css_content.txt) -gt 10 ]; then
            echo "... (truncated, total lines: $(wc -l < css_content.txt))"
          fi
          echo "--- CSS CONTENT END ---"
          
          # Count versions by counting ---VERSION--- separators
          VERSION_COUNT=$(grep -c "---VERSION---" css_content.txt 2>/dev/null || echo 0)
          VERSION_COUNT=$((VERSION_COUNT + 1))
          echo "version_count=$VERSION_COUNT" >> $GITHUB_OUTPUT
          echo "DEBUG: Found $VERSION_COUNT CSS versions"
          
      - name: Create directory structure
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          echo "DEBUG: Creating directory: $TARGET_DIR"
          
          mkdir -p "$TARGET_DIR"
          
          # Verify directory creation
          if [ ! -d "$TARGET_DIR" ]; then
            echo "ERROR: Failed to create directory: $TARGET_DIR"
            exit 1
          fi
          
          echo "DEBUG: Directory created successfully"
          ls -la daily-targets/
          
      - name: Create or update solutions file
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          SOLUTIONS_FILE="$TARGET_DIR/solutions.html"
          
          echo "DEBUG: Processing solutions file: $SOLUTIONS_FILE"
          
          # Clean CSS content - remove ```css and ``` markers, keep only the actual CSS
          sed -e '/^```css$/d' -e '/^```$/d' css_content.txt > css_cleaned.txt
          
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            echo "Creating new solutions file..."
            
            # Start with Version 1 comment
            echo "<!-- Version 1 -->" > "$SOLUTIONS_FILE"
            
            # Process CSS content with version separation
            version_num=1
            while IFS= read -r line || [ -n "$line" ]; do
              if [[ "$line" == "---VERSION---" ]]; then
                # Close current version and start new one
                echo "</style>" >> "$SOLUTIONS_FILE"
                echo "" >> "$SOLUTIONS_FILE"
                version_num=$((version_num + 1))
                echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
              else
                echo "$line" >> "$SOLUTIONS_FILE"
              fi
            done < css_cleaned.txt
            
            # Ensure file ends with </style>
            if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
              echo "</style>" >> "$SOLUTIONS_FILE"
            fi
            
          else
            echo "Updating existing solutions file..."
            
            if [ ! -f "$SOLUTIONS_FILE" ]; then
              echo "ERROR: Solutions file not found: $SOLUTIONS_FILE"
              echo "Available dates:"
              ls daily-targets/ 2>/dev/null || echo "No existing solutions found"
              exit 1
            fi
            
            case "${{ steps.extract.outputs.update_type }}" in
              "Add new CSS version(s)")
                echo "Adding new CSS versions..."
                # Find last version number
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                # Ensure file ends with </style>
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              "Replace existing CSS version(s)")
                if [ -n "${{ steps.extract.outputs.version_number }}" ]; then
                  echo "Note: Version replacement is complex and not fully implemented"
                  echo "Adding as new version instead..."
                  LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                  NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                  
                  echo "" >> "$SOLUTIONS_FILE"
                  echo "<!-- Version $NEXT_VERSION (replacement for Version ${{ steps.extract.outputs.version_number }}) -->" >> "$SOLUTIONS_FILE"
                  
                  # Add cleaned CSS content
                  cat css_cleaned.txt >> "$SOLUTIONS_FILE"
                  
                  if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                    echo "</style>" >> "$SOLUTIONS_FILE"
                  fi
                else
                  echo "ERROR: Version number required for replacement"
                  exit 1
                fi
                ;;
                
              "Add new comparison image(s)")
                echo "Images will be processed in next step..."
                ;;
                
              "Add both CSS and images")
                echo "Adding new CSS versions and images..."
                LAST_VERSION=$(grep -o "<!-- Version [0-9]\+ -->" "$SOLUTIONS_FILE" | grep -o "[0-9]\+" | sort -n | tail -1)
                NEXT_VERSION=$((${LAST_VERSION:-0} + 1))
                
                echo "" >> "$SOLUTIONS_FILE"
                echo "<!-- Version $NEXT_VERSION -->" >> "$SOLUTIONS_FILE"
                
                # Process CSS content with version separation
                version_num=$NEXT_VERSION
                while IFS= read -r line || [ -n "$line" ]; do
                  if [[ "$line" == "---VERSION---" ]]; then
                    # Close current version and start new one
                    echo "</style>" >> "$SOLUTIONS_FILE"
                    echo "" >> "$SOLUTIONS_FILE"
                    version_num=$((version_num + 1))
                    echo "<!-- Version $version_num -->" >> "$SOLUTIONS_FILE"
                  else
                    echo "$line" >> "$SOLUTIONS_FILE"
                  fi
                done < css_cleaned.txt
                
                if ! tail -n1 "$SOLUTIONS_FILE" | grep -q "</style>"; then
                  echo "</style>" >> "$SOLUTIONS_FILE"
                fi
                ;;
                
              *)
                echo "ERROR: Unknown update type: ${{ steps.extract.outputs.update_type }}"
                exit 1
                ;;
            esac
          fi
          
          echo "Solutions file processing complete"
          echo "DEBUG: Final solutions file content:"
          cat "$SOLUTIONS_FILE"
          
      - name: Download and process images
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          ISSUE_NUM="${{ github.event.issue.number }}"
          
          echo "DEBUG: Processing images for issue #$ISSUE_NUM"
          echo "DEBUG: Target directory: $TARGET_DIR"
          
          # Determine next available image number
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            NEXT_NUM=1
          else
            # Find existing images and get next number
            EXISTING_IMAGES=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | sort)
            if [ -n "$EXISTING_IMAGES" ]; then
              LAST_NUM=$(echo "$EXISTING_IMAGES" | sed 's/.*target-\([0-9]\+\)-comparison\..*/\1/' | sort -n | tail -1)
              NEXT_NUM=$((LAST_NUM + 1))
              echo "DEBUG: Found existing images, starting from number: $NEXT_NUM"
            else
              NEXT_NUM=1
              echo "DEBUG: No existing images found, starting from: $NEXT_NUM"
            fi
          fi
          
          # Get the full issue data including uploaded assets
          echo "DEBUG: Fetching issue data..."
          gh issue view "$ISSUE_NUM" --repo "${{ github.repository }}" --json body,url > issue_data.json
          
          # Debug: Show what we got
          echo "DEBUG: Issue data received:"
          cat issue_data.json
          
          # Extract the issue body
          ISSUE_BODY=$(jq -r '.body' issue_data.json)
          echo "DEBUG: Issue body extracted, length: ${#ISSUE_BODY}"
          
          # Save issue body for debugging
          echo "$ISSUE_BODY" > issue_body_full.txt
          echo "DEBUG: Full issue body saved to file"
          
          # Look for multiple image URL patterns that GitHub uses
          echo "DEBUG: Searching for image URLs..."
          
          # Clear any existing image URLs file
          > image_urls.txt
          
          # Pattern 1: GitHub user content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 2: GitHub assets URLs  
          echo "$ISSUE_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/assets/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 3: Generic GitHub content URLs
          echo "$ISSUE_BODY" | grep -oE 'https://[^.]*\.githubusercontent\.com/[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Pattern 4: Any https image URLs (broader catch)
          echo "$ISSUE_BODY" | grep -oE 'https://[^)"\s]+\.(png|jpg|jpeg|gif|webp)' >> image_urls.txt || true
          
          # Remove duplicates and empty lines
          if [ -f image_urls.txt ]; then
            sort image_urls.txt | uniq | grep -v '^$' > image_urls_clean.txt || touch image_urls_clean.txt
            mv image_urls_clean.txt image_urls.txt
          else
            touch image_urls.txt
          fi
          
          echo "DEBUG: Found image URLs:"
          cat image_urls.txt
          
          # Count images found
          IMAGE_COUNT=$(wc -l < image_urls.txt)
          echo "DEBUG: Total unique image URLs found: $IMAGE_COUNT"
          
          # Download each image with enhanced error handling
          if [ -s image_urls.txt ] && [ "$IMAGE_COUNT" -gt 0 ]; then
            echo "Found $IMAGE_COUNT image(s) to download"
            
            while IFS= read -r img_url; do
              if [ -n "$img_url" ]; then
                echo "DEBUG: Processing URL: $img_url"
                
                # Extract file extension
                ext=$(echo "$img_url" | grep -oE '\.(png|jpg|jpeg|gif|webp)$' | head -1)
                if [ -z "$ext" ]; then
                  ext=".png"  # Default extension
                  echo "DEBUG: No extension found, defaulting to .png"
                fi
                
                filename="target-${NEXT_NUM}-comparison${ext}"
                filepath="$TARGET_DIR/$filename"
                
                echo "Downloading: $img_url"
                echo "         to: $filename"
                
                # Try multiple download methods
                DOWNLOAD_SUCCESS=false
                
                # Method 1: With GitHub token (for private repos)
                if curl -L -f -s \
                        -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                        -H "User-Agent: GitHub-Actions" \
                        -H "Accept: application/vnd.github.v3+json" \
                        "$img_url" -o "$filepath" 2>/dev/null; then
                  DOWNLOAD_SUCCESS=true
                  echo "âœ… Downloaded with GitHub token"
                fi
                
                # Method 2: Without token (for public URLs)
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if curl -L -f -s \
                          -H "User-Agent: Mozilla/5.0 (GitHub Actions)" \
                          "$img_url" -o "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded without token"
                  fi
                fi
                
                # Method 3: Using wget as fallback
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  if wget -q --timeout=30 --tries=2 \
                          --header="User-Agent: GitHub-Actions" \
                          "$img_url" -O "$filepath" 2>/dev/null; then
                    DOWNLOAD_SUCCESS=true
                    echo "âœ… Downloaded with wget"
                  fi
                fi
                
                # Verify download
                if [ "$DOWNLOAD_SUCCESS" = true ] && [ -f "$filepath" ] && [ -s "$filepath" ]; then
                  # Check if it's actually an image file
                  file_type=$(file "$filepath" 2>/dev/null || echo "unknown")
                  if echo "$file_type" | grep -qi "image\|png\|jpeg\|gif\|webp"; then
                    echo "âœ… Successfully downloaded and verified: $filename"
                    echo "   File type: $file_type"
                    echo "   File size: $(du -h "$filepath" | cut -f1)"
                    NEXT_NUM=$((NEXT_NUM + 1))
                  else
                    echo "âŒ Downloaded file is not an image: $filename"
                    echo "   File type detected: $file_type"
                    rm -f "$filepath"
                  fi
                else
                  echo "âŒ Failed to download: $img_url"
                  [ -f "$filepath" ] && rm -f "$filepath"
                fi
                
                echo "---"
              fi
            done < image_urls.txt
          else
            echo "No images found in issue body"
            echo "DEBUG: This could mean:"
            echo "  - No images were uploaded to the issue"
            echo "  - Images are in a format/location we're not detecting"
            echo "  - The issue template format is different than expected"
          fi
          
          # Summary
          FINAL_IMAGE_COUNT=$(find "$TARGET_DIR" -name "target-*-comparison.*" 2>/dev/null | wc -l)
          echo ""
          echo "SUMMARY:"
          echo "  Images found in issue: $IMAGE_COUNT"
          echo "  Images successfully downloaded: $FINAL_IMAGE_COUNT"
          echo "  Images saved in: $TARGET_DIR"
          
          if [ "$FINAL_IMAGE_COUNT" -gt 0 ]; then
            echo "  Downloaded files:"
            find "$TARGET_DIR" -name "target-*-comparison.*" | sort
          fi
          
      - name: Generate LinkedIn post
        run: |
          TARGET_DIR="daily-targets/${{ steps.date.outputs.formatted_date }}"
          LINKEDIN_FILE="$TARGET_DIR/linkedin-post.md"
          
          # Extract additional notes based on operation type
          if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
            # For GitHub issue forms, look for the "Additional Notes" content
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "additional.*notes\|notes\|description" | grep -v -i "additional.*notes\|notes\|description" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          else
            ADDITIONAL_NOTES=$(sed -n '/```css/,/```/!p' issue_body.txt | grep -A 10 -i "update.*notes\|notes" | grep -v -i "update.*notes\|notes" | sed '/^[[:space:]]*$/d' | head -3 | tr '\n' ' ')
          fi
          
          # Clean up additional notes - remove empty content
          ADDITIONAL_NOTES=$(echo "$ADDITIONAL_NOTES" | xargs)
          
          # If no additional notes found, create a default description
          if [ -z "$ADDITIONAL_NOTES" ]; then
            if [ "${{ steps.operation.outputs.type }}" = "create" ]; then
              ADDITIONAL_NOTES="Another CSS challenge completed! ðŸŽ¯"
            else
              ADDITIONAL_NOTES="Updated my CSS solution with improvements! ðŸš€"
            fi
          fi
          
          # Generate the repository URL for the solutions.html file
          REPO_URL="https://github.com/${{ github.repository }}"
          SOLUTIONS_URL="$REPO_URL/blob/main/daily-targets/${{ steps.date.outputs.formatted_date }}/solutions.html"
          
          # Create LinkedIn post with the exact format requested
          cat > "$LINKEDIN_FILE" << EOF
# LinkedIn Post for ${{ steps.date.outputs.formatted_date }}

---

Today's CSSBattle solution:

$ADDITIONAL_NOTES

$SOLUTIONS_URL

(My journal notes.)

#cssgang #CSS #CSSBattle #HTML
EOF
          
          echo "LinkedIn post generated successfully"
          echo "DEBUG: LinkedIn post content:"
          cat "$LINKEDIN_FILE"
          
      - name: Commit and push changes
        run: |
          # Configure git
          git config --local user.email "${GIT_USER_EMAIL:-${{ github.actor }}@users.noreply.github.com}"
          git config --local user.name "${GIT_USER_NAME:-${{ github.actor }}}"
          
          # Check if there are changes to commit
          git add .
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "has_changes=false" >> $GITHUB_ENV
          else
            # Pull latest changes to avoid conflicts
            echo "Pulling latest changes..."
            git fetch origin
            git rebase origin/main || {
              echo "Rebase failed, trying merge strategy..."
